// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mbt/test/tests-registry.ts >>>

import Foundation

public enum TestMandatory {
  case REGULAR
  case IGNORED
  case DEBUG
}
open class TestsRegistry<T> {
  private let tests: YSMap<String, MBTTest<T>> = YSMap<String, MBTTest<T>>()
  private let testMandatories: YSMap<String, TestMandatory> = YSMap<String, TestMandatory>()
  private let passedTests: YSSet<String> = YSSet<String>()
  private let failedTests: YSMap<String, Int32> = YSMap<String, Int32>()
  private var testResults: ArrayJSONItem = ArrayJSONItem()
  private var ignoreLogs: YSSet<String> = YSSet<String>()
  private var ignoreLogEvents: YSSet<String> = YSSet<String>()
  private var ignoreTestingVsModelTests: YSSet<String> = YSSet<String>()
  private var bucketIndex: Int32 = 0
  private var bucketsTotal: Int32 = 1
  private var retriesCount: Int32 = 0
  @discardableResult
  open func regular(_ test: MBTTest<T>, _ testVsModel: Bool = true) -> TestsRegistry<T> {
    if !testVsModel {
      self.ignoreTestingVsModel(test)
    }
    return self.register(test, TestMandatory.REGULAR)
  }

  @discardableResult
  open func regularAll(_ tests: YSArray<MBTTest<T>>) -> TestsRegistry<T> {
    for test in tests {
      self.regular(test)
    }
    return self
  }

  @discardableResult
  open func debug(_ test: MBTTest<T>) -> TestsRegistry<T> {
    return self.register(test, TestMandatory.DEBUG)
  }

  @discardableResult
  open func ignore(_ test: MBTTest<T>) -> TestsRegistry<T> {
    return self.register(test, TestMandatory.IGNORED)
  }

  @discardableResult
  open func onlyTestsWithCaseIds(_ include: Bool, _ ids: YSArray<Int32>, _ platform: MBTPlatform) -> TestsRegistry<T> {
    let testsToForget = include ? self.getTestsExcludingTestsWithCaseIds(ids, platform) : self.getTestsByCaseIds(ids, platform)
    for test in testsToForget.concat(self.getTestsWithoutId(platform)) {
      self.tests.delete(test.description)
    }
    return self
  }

  @discardableResult
  open func onlyWithTag(_ tag: DeviceType, _ platform: MBTPlatform) -> TestsRegistry<T> {
    let testsToForget: YSArray<MBTTest<T>> = YSArray()
    for test in self.tests.values() {
      if !self.getTestSettings(test).hasTag(tag) {
        testsToForget.push(test)
      }
    }
    for test in testsToForget {
      self.tests.delete(test.description)
    }
    return self
  }

  @discardableResult
  open func bucket(_ bucketIndex: Int32, _ totalBuckets: Int32) -> TestsRegistry<T> {
    self.bucketIndex = bucketIndex
    self.bucketsTotal = totalBuckets
    return self
  }

  @discardableResult
  open func screenOnly(_ isOnlyScreenTests: Bool) -> TestsRegistry<T> {
    let testsToForget: YSArray<MBTTest<T>> = YSArray()
    for test in valuesArray(self.tests) {
      let isTestScreen = test.scenario(self.getFakeAccounts(test), nil, YSArray()).isActionInTestPlan("AssertSnapshotAction")
      if (isTestScreen && !isOnlyScreenTests) || (!isTestScreen && isOnlyScreenTests) {
        testsToForget.push(test)
      }
    }
    for test in testsToForget {
      self.tests.delete(test.description)
    }
    return self
  }

  @discardableResult
  open func ignoreLogsTesting(_ test: MBTTest<T>) -> TestsRegistry<T> {
    self.ignoreLogs.add(test.description)
    return self
  }

  @discardableResult
  open func ignoreLogEvent(_ eventName: String) -> TestsRegistry<T> {
    self.ignoreLogEvents.add(eventName)
    return self
  }

  @discardableResult
  open func ignoreTestingVsModel(_ test: MBTTest<T>) -> TestsRegistry<T> {
    self.ignoreTestingVsModelTests.add(test.description)
    return self
  }

  @discardableResult
  open func retries(_ count: Int32) -> TestsRegistry<T> {
    self.retriesCount = count
    return self
  }

  @discardableResult
  open func getTestsPossibleToRun(_ platform: MBTPlatform, _ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> YSArray<MBTTest<T>> {
    let result: YSArray<MBTTest<T>> = YSArray()
    let testsToDebug = self.getTests(TestMandatory.DEBUG)
    if testsToDebug.length > 0 {
      for test in testsToDebug {
        for `_` in stride(from: 0, to: 1 + self.retriesCount, by: 1) {
          result.push(test)
        }
      }
      return result
    }
    for test in self.getTestBucket(platform, modelFeatures, applicationFeatures) {
      for `_` in stride(from: 0, to: 1 + self.retriesCount, by: 1) {
        result.push(test)
      }
    }
    return result
  }

  open func passed(_ test: MBTTest<T>) -> Void {
    self.passedTests.add(test.description)
  }

  open func failed(_ test: MBTTest<T>) -> Void {
    if self.failedTests.has(test.description) {
      self.failedTests.set(test.description, self.failedTests.`get`(test.description)! + 1)
    } else {
      self.failedTests.set(test.description, 1)
    }
    if self.passedTests.has(test.description) {
      self.passedTests.delete(test.description)
    }
  }

  @discardableResult
  open func isPassed(_ test: MBTTest<T>) -> Bool {
    return self.passedTests.has(test.description)
  }

  @discardableResult
  open func isNeedTryMore(_ test: MBTTest<T>) -> Bool {
    let failedNum = self.failedTests.get(test.description)
    if undefinedToNull(failedNum) != nil {
      return self.failedTests.`get`(test.description)! <= self.retriesCount
    }
    return true
  }

  @discardableResult
  open func isTestEnabled(_ test: MBTTest<T>, _ platform: MBTPlatform, _ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    if self.isTestToDebug(test) {
      return true
    }
    if self.isIgnored(test) {
      return false
    }
    let fakeAccounts = self.getFakeAccounts(test)
    let unsupportedActions = test.scenario(fakeAccounts, nil, applicationFeatures).unsupportedActions(modelFeatures, applicationFeatures)
    if unsupportedActions.length > 0 {
      var s = ""
      for action in unsupportedActions {
        s += ";\(action.tostring())"
      }
      Log.info("'\(test.description)': application should support actions: \(s)")
    }
    let settings = self.getTestSettings(test)
    let ignored = settings.isIgnored(platform)
    if ignored {
      Log.info("'\(test.description)': помечен как нерабочий. " + "Пожалуйста, почините это - тесты должны включаться/отключаться через поддержку фичей")
    }
    return unsupportedActions.length == 0 && !ignored
  }

  @discardableResult
  open func isTestToDebug(_ test: MBTTest<T>) -> Bool {
    return self.testMandatories.get(test.description) == TestMandatory.DEBUG
  }

  @discardableResult
  open func isIgnored(_ test: MBTTest<T>) -> Bool {
    return self.testMandatories.get(test.description) == TestMandatory.IGNORED
  }

  @discardableResult
  open func isIgnoredLogsTesting(_ test: MBTTest<T>) -> Bool {
    return self.ignoreLogs.has(test.description)
  }

  @discardableResult
  open func isIgnoredLogEvent(_ eventName: String) -> Bool {
    return self.ignoreLogEvents.has(eventName)
  }

  @discardableResult
  open func isIgnoredVsModelTesting(_ test: MBTTest<T>) -> Bool {
    return self.ignoreTestingVsModelTests.has(test.description)
  }

  @discardableResult
  open func getTestSettings(_ test: MBTTest<T>) -> TestSettings {
    let settings = TestSettings()
    test.setupSettings(settings)
    return settings
  }

  open func setTestResult(_ result: MapJSONItem) -> Void {
    self.testResults.add(result)
  }

  @discardableResult
  open func getTestResults() -> ArrayJSONItem {
    return self.testResults
  }

  open func clearTestResults() -> Void {
    self.testResults = ArrayJSONItem()
  }

  @discardableResult
  private func getTestBucket(_ platform: MBTPlatform, _ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> YSArray<MBTTest<T>> {
    let ignoredTests: YSArray<MBTTest<T>> = valuesArray(self.tests).filter({
      (item) in
      !self.isTestEnabled(item, platform, modelFeatures, applicationFeatures)
    }).sort({
      (l, r) in
      (l.description < r.description ? -1 : l.description == r.description ? 0 : 1)
    })
    let testsBucket: YSArray<MBTTest<T>> = valuesArray(self.tests).filter({
      (item) in
      !ignoredTests.map({
        (test) in
        test.description
      }).includes(item.description)
    }).sort({
      (l, r) in
      (l.description < r.description ? -1 : l.description == r.description ? 0 : 1)
    })
    var runTestsCount: Int32 = testsBucket.length
    var ignoredTestsCount: Int32 = ignoredTests.length
    Log.info("\(runTestsCount) tests total to run, \(ignoredTestsCount) tests total to ignore, \(self.bucketsTotal) buckets")
    let ignoredBucketSliceIndexes = getSliceIndexesForBuckets(ignoredTestsCount, self.bucketsTotal)
    let bucketSliceIndexes = getSliceIndexesForBuckets(runTestsCount, self.bucketsTotal)
    let testsToRun = testsBucket.slice(bucketSliceIndexes[self.bucketIndex], bucketSliceIndexes[self.bucketIndex + 1])
    let testsToIgnore = ignoredTests.slice(ignoredBucketSliceIndexes[self.bucketIndex], ignoredBucketSliceIndexes[self.bucketIndex + 1])
    runTestsCount = testsToRun.length
    ignoredTestsCount = testsToIgnore.length
    Log.info("\(testsToRun)")
    Log.info("\(runTestsCount) tests to run, \(ignoredTestsCount) test to ignore in current bucket")
    return testsToRun.concat(testsToIgnore)
  }

  @discardableResult
  private func register(_ test: MBTTest<T>, _ mandatory: TestMandatory) -> TestsRegistry<T> {
    self.tests.set(test.description, test)
    self.testMandatories.set(test.description, mandatory)
    return self
  }

  @discardableResult
  private func getTests(_ mandatory: TestMandatory) -> YSArray<MBTTest<T>> {
    let tests: YSArray<MBTTest<T>> = YSArray()
    for test in self.tests.values() {
      if mandatory == self.testMandatories.get(test.description) {
        tests.push(test)
      }
    }
    return tests
  }

  @discardableResult
  private func getTestsExcludingTestsWithCaseIds(_ ids: YSArray<Int32>, _ platform: MBTPlatform) -> YSArray<MBTTest<T>> {
    let tests: YSArray<MBTTest<T>> = YSArray()
    for test in self.tests.values() {
      if !ids.includes(self.getTestSettings(test).getCaseIDForPlatform(platform)) {
        tests.push(test)
      }
    }
    return tests
  }

  @discardableResult
  private func getTestsByCaseIds(_ ids: YSArray<Int32>, _ platform: MBTPlatform) -> YSArray<MBTTest<T>> {
    let tests: YSArray<MBTTest<T>> = YSArray()
    for test in self.tests.values() {
      if ids.includes(self.getTestSettings(test).getCaseIDForPlatform(platform)) {
        tests.push(test)
      }
    }
    return tests
  }

  @discardableResult
  private func getTestsWithoutId(_ platform: MBTPlatform) -> YSArray<MBTTest<T>> {
    let tests: YSArray<MBTTest<T>> = YSArray()
    for test in self.tests.values() {
      if self.getTestSettings(test).getCaseIDForPlatform(platform) == 0 {
        tests.push(test)
      }
    }
    return tests
  }

  @discardableResult
  private func getFakeAccounts(_ test: MBTTest<T>) -> YSArray<UserAccount> {
    return test.requiredAccounts().map({
      (_) in
      UserAccount("", "")
    })
  }

}

