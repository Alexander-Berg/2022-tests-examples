// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM model/payment-methods-list-model.ts >>>

import Foundation

open class PaymentMethodsListModel: PaymentMethodsList {
  private var showKeyboardFirstCvv: Bool = false
  private var addedCards: YSArray<String> = YSArray()
  private var selected: Int32 = -1
  private var cvv: String! = nil
  private var methodsListMode: MethodsListMode = MethodsListMode.regular
  private var availableMethods: AvailableMethods
  private let paymentScreenTitleModel: PaymentScreenTitleModel
  private let keyboardModel: KeyboardModel
  private let forceCvv: Bool
  private let buttonModel: PaymentButtonModel
  public init(_ availableMethods: AvailableMethods, _ paymentScreenTitleModel: PaymentScreenTitleModel, _ keyboardModel: KeyboardModel, _ forceCvv: Bool, _ buttonModel: PaymentButtonModel) {
    self.availableMethods = availableMethods
    self.paymentScreenTitleModel = paymentScreenTitleModel
    self.keyboardModel = keyboardModel
    self.forceCvv = forceCvv
    self.buttonModel = buttonModel
    self.showKeyboardFirstCvv = forceCvv
  }

  @discardableResult
  open func waitForPaymentMethods(_ mSec: Int32) throws -> Bool {
    return true
  }

  @discardableResult
  open func getAllMethods() -> YSArray<String> {
    return TestPaymentMethodsBuilder().setAvailableMethods(self.availableMethods).setAddedCards(self.addedCards).getAllMethods()
  }

  @discardableResult
  open func getAvailableMethods() -> AvailableMethods {
    return self.availableMethods
  }

  @discardableResult
  open func getMethods() -> YSArray<String> {
    return self.getAllMethods().filter({
      (pm) in
      !YSArray(PaymentMethodName.applePay, PaymentMethodName.googlePay).includes(pm)
    })
  }

  @discardableResult
  open func getCards() -> YSArray<String> {
    return self.getMethods().filter({
      (pm) in
      !YSArray(PaymentMethodName.otherCard, PaymentMethodName.cash).includes(pm)
    })
  }

  @discardableResult
  open func getSelectedMethodName() -> String! {
    let methods = self.getMethods()
    return self.selected >= 0 && methods.length > self.selected ? methods[self.selected] : nil
  }

  @discardableResult
  open func getSelectedCardName() -> String! {
    let methods = self.getCards()
    return self.selected >= 0 && methods.length > self.selected ? methods[self.selected] : nil
  }

  @discardableResult
  open func addCard(_ cardNumber: String) throws -> Bool {
    if self.getAllMethods().includes(buildPaymentMethodNameByCardNumber(cardNumber)) {
      return false
    }
    self.addedCards.push(cardNumber)
    return true
  }

  @discardableResult
  open func deleteMethod(_ method: String) throws -> Void {
    let paymentMethods = self.availableMethods.paymentMethods.filter({
      (pm) in
      buildPaymentMethodNameByPaymentMethod(pm) != method
    })
    self.availableMethods = self.availableMethods.builder().setPaymentMethods(paymentMethods).build()
    self.addedCards = self.addedCards.filter({
      (card) in
      buildPaymentMethodNameByCardNumber(card) != method
    })
  }

  @discardableResult
  open func getSelected() throws -> Int32 {
    return self.selected
  }

  @discardableResult
  open func selectMethod(_ index: Int32) throws -> Void {
    if self.selected != index {
      self.cvv = nil
      if self.showKeyboardFirstCvv {
        self.showKeyboardFirstCvv = false
      } else {
        self.keyboardModel.setNumericKeyboardStatus(false)
      }
      if self.methodsListMode == MethodsListMode.regular && self.forceCvv {
        self.buttonModel.setButtonText(PaymentButtonLabel.enterCvv)
      }
    }
    self.selected = index
  }

  @discardableResult
  open func selectSbpMethod() throws -> Void {
    self.selected = self.getAllMethods().lastIndexOf(PaymentMethodName.sbp)
    self.keyboardModel.setNumericKeyboardStatus(false)
  }

  @discardableResult
  open func setCvvFieldValue(_ cvv: String) throws -> Void {
    self.cvv = cvv
    if self.methodsListMode == MethodsListMode.regular && self.forceCvv && cvv.length == 3 {
      self.buttonModel.setButtonText(PaymentButtonLabel.pay)
    }
  }

  @discardableResult
  open func getCvvFieldValue() throws -> String! {
    return self.methodsListMode == MethodsListMode.preselect ? nil : self.forceCvv && self.cvv == nil ? "" : self.cvv
  }

  @discardableResult
  open func clickNewCard() throws -> Void {
    self.keyboardModel.setNumericKeyboardStatus(true)
    (try self.paymentScreenTitleModel.setTitle(PaymentScreenTitleLabel.cardPayment))
  }

  @discardableResult
  open func tapOnCvvField() throws -> Void {
    self.keyboardModel.setNumericKeyboardStatus(true)
  }

  open func resetFields() -> Void {
    self.keyboardModel.setNumericKeyboardStatus(false)
    self.cvv = nil
    if self.methodsListMode == MethodsListMode.regular {
      self.selected = -1
    }
  }

  @discardableResult
  open func getMethodsListMode() throws -> MethodsListMode {
    return self.methodsListMode
  }

  @discardableResult
  open func setMethodsListMode(_ mode: MethodsListMode) throws -> Void {
    self.methodsListMode = mode
  }

}

open class TestPaymentMethodsBuilder {
  private var availableMethods: AvailableMethods = AvailableMethodsBuilder().build()
  private var addedCards: YSArray<String> = YSArray()
  public init() {
  }

  @discardableResult
  open func setAvailableMethods(_ value: AvailableMethods) -> TestPaymentMethodsBuilder {
    self.availableMethods = value
    return self
  }

  @discardableResult
  open func setAddedCards(_ value: YSArray<String>) -> TestPaymentMethodsBuilder {
    self.addedCards = value
    return self
  }

  @discardableResult
  open func getAllMethods() -> YSArray<String> {
    let result: YSArray<String> = YSArray()
    for method in self.availableMethods.paymentMethods {
      result.push(buildPaymentMethodNameByPaymentMethod(method))
    }
    for cardNumber in self.addedCards {
      result.push(buildPaymentMethodNameByCardNumber(cardNumber))
    }
    if self.availableMethods.isGooglePayAvailable {
      result.push(PaymentMethodName.googlePay)
    }
    if self.availableMethods.isApplePayAvailable {
      result.push(PaymentMethodName.applePay)
    }
    if self.availableMethods.isCashAvailable {
      result.push(PaymentMethodName.cash)
    }
    if self.availableMethods.isSpbQrAvailable {
      result.push(PaymentMethodName.sbp)
    }
    if result.length > 0 {
      result.push(PaymentMethodName.otherCard)
    }
    return result
  }

}

open class PreselectModel: Preselect {
  private var cashSelected: Bool = false
  private let paymentScreenTitleModel: PaymentScreenTitleModel
  private let keyboardModel: KeyboardModel
  private let paymentMethodsListModel: PaymentMethodsListModel
  private let paymentButtonModel: PaymentButtonModel
  private let fillNewCardModel: FillNewCardModel
  public init(_ paymentScreenTitleModel: PaymentScreenTitleModel, _ keyboardModel: KeyboardModel, _ paymentMethodsListModel: PaymentMethodsListModel, _ paymentButtonModel: PaymentButtonModel, _ fillNewCardModel: FillNewCardModel) {
    self.paymentScreenTitleModel = paymentScreenTitleModel
    self.keyboardModel = keyboardModel
    self.paymentMethodsListModel = paymentMethodsListModel
    self.paymentButtonModel = paymentButtonModel
    self.fillNewCardModel = fillNewCardModel
  }

  @discardableResult
  open func isCashSelected() throws -> Bool {
    return self.cashSelected
  }

  @discardableResult
  open func selectCash() throws -> Void {
    self.cashSelected = true
  }

  @discardableResult
  open func tapOnSelectButton() throws -> Void {
    (try self.paymentScreenTitleModel.setTitle(PaymentScreenTitleLabel.paymentMethod))
  }

  @discardableResult
  open func tapOnOtherCard() throws -> Void {
    self.keyboardModel.setNumericKeyboardStatus(true)
    (try self.paymentScreenTitleModel.setTitle(PaymentScreenTitleLabel.addCard))
    self.paymentButtonModel.setButtonText(PaymentButtonLabel.addCard)
    self.fillNewCardModel.setNewCardMode(NewCardMode.bind)
  }

  @discardableResult
  open func unbindCard(_ index: Int32) throws -> Void {
    (try self.paymentMethodsListModel.deleteMethod(self.paymentMethodsListModel.getMethods()[index]))
  }

  @discardableResult
  open func tapOnAddCard() throws -> Void {
    (try self.paymentScreenTitleModel.setTitle(PaymentScreenTitleLabel.paymentMethod))
    self.paymentButtonModel.setButtonText(PaymentButtonLabel.select)
    (try self.paymentButtonModel.pressButton())
    self.fillNewCardModel.setNewCardMode(nil)
  }

}

open class PreselectCvvModel: PreselectCvv {
  private let paymentMethodsListModel: PaymentMethodsListModel
  private let forceCvv: Bool
  public init(_ paymentMethodsListModel: PaymentMethodsListModel, _ forceCvv: Bool) {
    self.paymentMethodsListModel = paymentMethodsListModel
    self.forceCvv = forceCvv
  }

  @discardableResult
  open func getCardName() throws -> String {
    return self.paymentMethodsListModel.getSelectedCardName()!
  }

  @discardableResult
  open func getCvvFieldValue() throws -> String! {
    let cvv: String! = (try self.paymentMethodsListModel.getCvvFieldValue())
    return self.forceCvv && cvv == nil ? "" : cvv
  }

  @discardableResult
  open func waitForPreselectCvv(_ mSec: Int32) throws -> Bool {
    return true
  }

}

open class ApplePayModel: ApplePay {
  private let availableMethods: AvailableMethods
  public init(_ availableMethods: AvailableMethods) {
    self.availableMethods = availableMethods
  }

  @discardableResult
  open func isAvailable() -> Bool {
    return self.availableMethods.isApplePayAvailable
  }

}

open class GooglePayModel: GooglePay {
  private let availableMethods: AvailableMethods
  public init(_ availableMethods: AvailableMethods) {
    self.availableMethods = availableMethods
  }

  @discardableResult
  open func isAvailable() -> Bool {
    return self.availableMethods.isGooglePayAvailable
  }

}

open class SBPModel: SBP {
  private let availableMethods: AvailableMethods
  public init(_ availableMethods: AvailableMethods) {
    self.availableMethods = availableMethods
  }

  @discardableResult
  open func isAvailable() -> Bool {
    return self.availableMethods.isSpbQrAvailable
  }

}

