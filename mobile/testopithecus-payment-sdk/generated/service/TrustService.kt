// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM service/trust-service.ts >>>

package com.yandex.xplat.testopithecus.payment.sdk

import com.yandex.xplat.common.*
import com.yandex.xplat.eventus.common.*
import com.yandex.xplat.testopithecus.common.*
import com.yandex.xplat.payment.sdk.*

public open class TrustService(private val networkService: NetworkService) {
    open fun createPurchase(user: OAuthUserAccount, merchant: String, product: String, force3ds: Boolean, amount: String, forceCvv: Boolean): XPromise<Purchase> {
        return this.networkService.performRequest(CreateOrderRequest(user, merchant, product),  {
            item ->
            decodeJSONItem(item, __LBL__TrustService_1@ {
                json ->
                val map = json.tryCastAsMapJSONItem()
                return@__LBL__TrustService_1 map.tryGetString("order_id")
            })
        }).flatThen( {
            orderId ->
            this.networkService.performRequest(CreatePurchaseRequest(user, merchant, orderId, force3ds, amount, forceCvv),  {
                item ->
                decodeJSONItem(item, __LBL__TrustService_2@ {
                    json ->
                    val map = json.tryCastAsMapJSONItem()
                    val purchaseToken = map.tryGetString("purchase_token")
                    return@__LBL__TrustService_2 Purchase(orderId, purchaseToken)
                })
            })
        })
    }

    open fun startPurchase(user: OAuthUserAccount, merchant: String, purchaseId: String): XPromise<Unit> {
        return this.networkService.performRequest(StartPurchaseRequest(user, merchant, purchaseId),  {
            item ->
            decodeJSONItem(item, __LBL__TrustService_3@ {
                json ->
                val status = json.tryCastAsMapJSONItem().getString("status")
                if (status != "success") {
                    throw YSError("Unable to start purchase")
                }
            })
        })
    }

    companion object {
        @JvmStatic
        open fun create(network: Network, serializer: JSONSerializer, passportToken: String?): TrustService {
            val passportInterceptor = PassportHeaderInterceptor(passportToken)
            val authorizedNetwork = NetworkIntermediate(network, mutableListOf(passportInterceptor))
            val errorProcessor = DiehardBackendErrorProcessor()
            val networkService = NetworkService(authorizedNetwork, serializer, errorProcessor)
            return TrustService(networkService)
        }

    }
}

public open class Purchase(val orderId: String, val purchaseId: String) {
}

