// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM payment-sdk-data.ts >>>

import Foundation

open class PaymentDataPreparer: AccountDataPreparer {
  public let merchantLocalizedName: String = "name"
  private var account: OAuthUserAccount! = nil
  private var merchantId: String = Merchants.paymentSDK.merchantId
  private var productId: String = Merchants.paymentSDK.productId
  private var paymentId: String = ""
  private var orderId: String = ""
  private var availableMethods: AvailableMethods = AvailableMethods.EMPTY
  private var boundCards: YSArray<BoundCard> = YSArray()
  private var code3ds: String! = nil
  private var cvv: String = BoundCardConstants.CVV
  private var amount: String = "100.00"
  private var forceCvv: Bool = false
  private var forcedErrorType: PaymentErrorType! = nil
  private var darkModeEnabled: Bool = false
  private var methodsFilter: PaymentMethodsFilter = PaymentMethodsFilter()
  private var cashEnabled: Bool = false
  private var personalInfoShowingMode: PersonalInfoMode = PersonalInfoMode.HIDE
  private var authorizationMode: AuthorizationMode = AuthorizationMode.authorized
  private var markupPurchaseNeeded: Bool = false
  private var bindingV2Enabled: Bool = false
  private var yaOplata: Bool = false
  private var acquirer: Acquirer! = nil
  private var familyInfoMode: FamilyInfoMode = FamilyInfoMode.disabled
  public let trustService: TrustService
  private var userService: PaymentUserService
  private var yaOplataService: YaOplataService
  public var mockPrepareService: MockPrepareService
  public init(_ trustService: TrustService, _ userService: PaymentUserService, _ yaOplataService: YaOplataService, _ mockPrepareService: MockPrepareService) {
    self.trustService = trustService
    self.userService = userService
    self.yaOplataService = yaOplataService
    self.mockPrepareService = mockPrepareService
  }

  @discardableResult
  open func prepare(_ account: OAuthUserAccount) -> XPromise<Void> {
    self.account = account
    if self.markupPurchaseNeeded {
      return self.createPurchase(account).flatThen({
        (_) in
        self.cleanAccountAndBindCards(account)
      }).flatThen({
        (_) in
        self.startPurchase(account)
      }).flatThen({
        (_) in
        self.getPaymentMethodList(account)
      })
    }
    return self.createPurchase(account).flatThen({
      (_) in
      self.cleanAccountAndBindCards(account)
    }).flatThen({
      (_) in
      self.getPaymentMethodList(account)
    })
  }

  @discardableResult
  private func createPurchase(_ account: OAuthUserAccount) -> XPromise<Void> {
    return self.yaOplata ? self.yaOplataService.createOrder(getTokenForAcquirer(self.acquirer!), self.amount).flatCatch({
      (e) in
      reject(YSError("Unable to create order, error: \(e.message)"))
    }).then({
      (token) in
      self.paymentId = token
      return getVoid()
    }) : self.trustService.createPurchase(account, self.merchantId, self.productId, self.code3ds != nil, self.amount, self.forceCvv).flatCatch({
      (e) in
      reject(YSError("Unable to obtain purchase id from TRUST, error: \(e.message)"))
    }).flatThen({
      (purchase) in
      self.paymentId = purchase.purchaseId
      self.orderId = purchase.orderId
      return toPromise(resultValue(getVoid()))
    })
  }

  @discardableResult
  private func cleanAccountAndBindCards(_ account: OAuthUserAccount) -> XPromise<Void> {
    return self.userService.cleanAccountAndBindCards(account, self.boundCards, self.merchantId).flatCatch({
      (e) in
      reject(YSError("Unable to clean account and bind cards, error: \(e.message)"))
    }).flatThen({
      (_: Void) in
      self.configureFamilyInfoModeIfNeeded()
    })
  }

  @discardableResult
  private func configureFamilyInfoModeIfNeeded() -> XPromise<Void> {
    if self.familyInfoMode == FamilyInfoMode.disabled {
      return (resolve(getVoid()) as XPromise<Void>)
    }
    return self.mockPrepareService.setMockFamilyInfoMode(self.familyInfoMode).then({
      (_: Bool) -> Void in
      getVoid()
    })
  }

  @discardableResult
  private func startPurchase(_ account: OAuthUserAccount) -> XPromise<Void> {
    return self.trustService.startPurchase(account, self.merchantId, self.paymentId).flatCatch({
      (e) in
      reject(YSError("Unable to start purchase, error: \(e.message)"))
    })
  }

  @discardableResult
  private func getPaymentMethodList(_ account: OAuthUserAccount) -> XPromise<Void> {
    return self.userService.getPaymentMethods(account, self.merchantId).flatCatch({
      (e) in
      reject(YSError("Unable to get payment methods, error: \(e.message)"))
    }).then({
      (paymentMethods: AvailableMethods) -> Void in
      self.availableMethods = paymentMethods.builder().setIsGooglePayAvailable(paymentMethods.isGooglePayAvailable && self.methodsFilter.isGooglePayAvailable && !self.yaOplata).setIsApplePayAvailable(paymentMethods.isGooglePayAvailable && self.methodsFilter.isGooglePayAvailable && !self.yaOplata).setIsCashAvailable(self.cashEnabled).setIsSpbQrAvailable(paymentMethods.isSpbQrAvailable && self.methodsFilter.isSBPAvailable && !self.yaOplata).build()
      return getVoid()
    })
  }

  @discardableResult
  open func getAccount() -> OAuthUserAccount {
    return self.account!
  }

  @discardableResult
  open func getMerchantId() -> String {
    return self.merchantId
  }

  @discardableResult
  open func setMerchantId(_ merchantId: String) -> PaymentDataPreparer {
    self.merchantId = merchantId
    return self
  }

  @discardableResult
  open func setBindingV2(_ bindingV2Enabled: Bool) -> PaymentDataPreparer {
    self.bindingV2Enabled = bindingV2Enabled
    return self
  }

  @discardableResult
  open func isBindingV2Enabled() -> Bool {
    return self.bindingV2Enabled
  }

  @discardableResult
  open func getPaymentId() -> String {
    return self.paymentId
  }

  @discardableResult
  open func getOrderId() -> String {
    return self.orderId
  }

  @discardableResult
  open func getAvailableMethods() -> AvailableMethods {
    return self.availableMethods
  }

  @discardableResult
  open func getProductId() -> String {
    return self.productId
  }

  @discardableResult
  open func setProductId(_ productId: String) -> PaymentDataPreparer {
    self.productId = productId
    return self
  }

  open func clearBoundCards() -> Void {
    self.boundCards = YSArray()
  }

  @discardableResult
  open func addBoundCard(_ card: BoundCard) -> PaymentDataPreparer {
    self.boundCards.push(card)
    return self
  }

  @discardableResult
  open func setFamilyInfoMode(_ mode: FamilyInfoMode) -> PaymentDataPreparer {
    self.familyInfoMode = mode
    return self
  }

  @discardableResult
  open func getCvv() -> String {
    return self.cvv
  }

  @discardableResult
  open func setCvv(_ cvv: String) -> PaymentDataPreparer {
    self.cvv = cvv
    return self
  }

  @discardableResult
  open func setUseYaOplata(_ use: Bool) -> PaymentDataPreparer {
    self.yaOplata = use
    return self
  }

  @discardableResult
  open func getAcquirer() -> Acquirer! {
    return self.acquirer
  }

  @discardableResult
  open func setAcquirer(_ acquirer: Acquirer!) -> PaymentDataPreparer {
    self.acquirer = acquirer
    return self
  }

  @discardableResult
  open func get3ds() -> String! {
    return self.code3ds
  }

  @discardableResult
  open func set3ds(_ code: String) -> PaymentDataPreparer {
    self.code3ds = code
    return self
  }

  @discardableResult
  open func enableCash() -> PaymentDataPreparer {
    self.cashEnabled = true
    return self
  }

  @discardableResult
  open func isCashEnabled() -> Bool {
    return self.cashEnabled
  }

  @discardableResult
  open func forcePaymentError(_ type: PaymentErrorType) -> PaymentDataPreparer {
    self.amount = type.toString()
    self.forcedErrorType = type
    return self
  }

  @discardableResult
  open func forcedPaymentErrorType() -> PaymentErrorType! {
    return self.forcedErrorType
  }

  @discardableResult
  open func getForceCvv() -> Bool {
    return self.forceCvv
  }

  @discardableResult
  open func setForceCvv(_ forceCvv: Bool) -> PaymentDataPreparer {
    self.forceCvv = forceCvv
    return self
  }

  @discardableResult
  open func isDarkModeEnabled() -> Bool {
    return self.darkModeEnabled
  }

  @discardableResult
  open func setDarkMode(_ enabled: Bool) -> PaymentDataPreparer {
    self.darkModeEnabled = enabled
    return self
  }

  @discardableResult
  open func getAmount() -> String {
    return self.amount
  }

  @discardableResult
  open func setAmount(_ amount: String) -> PaymentDataPreparer {
    self.amount = amount
    return self
  }

  @discardableResult
  open func getPaymentMethodsFilter() -> PaymentMethodsFilter {
    return self.methodsFilter
  }

  @discardableResult
  open func setPaymentMethodsFilter(_ filter: PaymentMethodsFilter) -> PaymentDataPreparer {
    self.methodsFilter = filter
    return self
  }

  @discardableResult
  open func getPersonalInfoShowingMode() -> PersonalInfoMode {
    return self.personalInfoShowingMode
  }

  @discardableResult
  open func setPersonalInfoShowingMode(_ mode: PersonalInfoMode) -> PaymentDataPreparer {
    self.personalInfoShowingMode = mode
    return self
  }

  @discardableResult
  open func getAuthorizationMode() -> AuthorizationMode {
    return self.authorizationMode
  }

  @discardableResult
  open func setAuthorizationMode(_ mode: AuthorizationMode) -> PaymentDataPreparer {
    self.authorizationMode = mode
    return self
  }

}

open class PaymentSdkModelProvider: AppModelProvider {
  private let preparer: PaymentDataPreparer
  public init(_ preparer: PaymentDataPreparer) {
    self.preparer = preparer
  }

  @discardableResult
  open func takeAppModel() -> AppModel {
    return PaymentSdkModel(self.preparer.getAccount(), self.preparer.getMerchantId(), self.preparer.getPaymentId(), self.preparer.getAvailableMethods(), self.preparer.getAmount(), "₽", self.preparer.get3ds(), self.preparer.getCvv() == BoundCardConstants.CVV, self.preparer.forcedPaymentErrorType(), self.preparer.getForceCvv(), self.preparer.getPaymentMethodsFilter(), self.preparer.isDarkModeEnabled(), self.preparer.getPersonalInfoShowingMode(), self.preparer.getAuthorizationMode(), self.preparer.isBindingV2Enabled(), self.preparer.isCashEnabled(), self.preparer.getAcquirer())
  }

}

open class PaymentDataPreparerProvider: AccountDataPreparerProvider<PaymentDataPreparer> {
  private var trustNetwork: Network
  private var yaOplataNetwork: Network
  private var diehardNetwork: Network
  private var mobileBackendNetwork: Network
  private var syncNetwork: SyncNetwork
  private var jsonSerializer: JSONSerializer
  private var tusConsumer: String
  private var forcedOauthHost: String!
  public init(_ trustNetwork: Network, _ yaOplataNetwork: Network, _ diehardNetwork: Network, _ mobileBackendNetwork: Network, _ syncNetwork: SyncNetwork, _ jsonSerializer: JSONSerializer, _ tusConsumer: String, _ forcedOauthHost: String! = nil) {
    self.trustNetwork = trustNetwork
    self.yaOplataNetwork = yaOplataNetwork
    self.diehardNetwork = diehardNetwork
    self.mobileBackendNetwork = mobileBackendNetwork
    self.syncNetwork = syncNetwork
    self.jsonSerializer = jsonSerializer
    self.tusConsumer = tusConsumer
    self.forcedOauthHost = forcedOauthHost
    super.init()
  }

  @discardableResult
  open class func build(_ trustNetwork: Network, _ yaOplataNetwork: Network, _ diehardNetwork: Network, _ mobileBackendNetwork: Network, _ syncNetwork: SyncNetwork, _ jsonSerializer: JSONSerializer, _ tusConsumer: String) -> PaymentDataPreparerProvider {
    return PaymentDataPreparerProvider(trustNetwork, yaOplataNetwork, diehardNetwork, mobileBackendNetwork, syncNetwork, jsonSerializer, tusConsumer)
  }

  @discardableResult
  open func providePaymentDataPreparer() -> PaymentDataPreparer {
    let trustService = TrustService.create(self.trustNetwork, self.jsonSerializer, nil)
    let yaOplataService = YaOplataService.create(self.yaOplataNetwork, self.jsonSerializer)
    let userService = PaymentUserService.build(self.diehardNetwork, self.mobileBackendNetwork, self.syncNetwork, self.jsonSerializer, nil, self.tusConsumer, self.forcedOauthHost)
    let mockPrepareService = MockPrepareService.create(self.trustNetwork, self.jsonSerializer)
    return PaymentDataPreparer(trustService, userService, yaOplataService, mockPrepareService)
  }

  @discardableResult
  open override func provide(_ lockedAccount: UserAccount, _ type: AccountType2) -> PaymentDataPreparer {
    return self.providePaymentDataPreparer()
  }

  @discardableResult
  open override func provideModelDownloader(_ fulfilledPreparers: YSArray<PaymentDataPreparer>, _ accountsWithTokens: YSArray<OAuthUserAccount>) -> AppModelProvider {
    return PaymentSdkModelProvider(fulfilledPreparers[0])
  }

}

public enum PaymentErrorType : String {
  case notEnoughFunds = "1099.00"
  case invalidTransaction = "1092.00"
  case force3ds = "1093.00"
  case restrictedCard36 = "1097.00"
  case restrictedCard62 = "1096.00"
  case transactionNotPermittedToCard57 = "1094.00"
  case transactionNotPermittedToCard58 = "1095.00"
  case doNotHonor = "1090.00"
  public func toString() -> String {
    return self.rawValue
  }
}
open class PaymentMethodName {
  public static let cash: String = "Cash"
  public static let applePay: String = "Apple Pay"
  public static let googlePay: String = "Google Pay"
  public static let sbp: String = "Faster Payments Systems"
  public static let otherCard: String = "Another card"
  public static let familyPayPrefix: String = "Family"
}

open class MerchantWithProductId {
  public let merchantId: String
  public let productId: String
  public init(_ merchantId: String, _ productId: String) {
    self.merchantId = merchantId
    self.productId = productId
  }

}

open class Merchants {
  public static let paymentSDK: MerchantWithProductId = MerchantWithProductId("payment_sdk_19d9962ddd08e7d52a2668cbcd5f7b7e", "6735968470625602946")
  public static let beru: MerchantWithProductId = MerchantWithProductId("blue_market_payments_5fac16d65c83b948a5b10577f373ea7c", "6101710988743309398")
  public static let zapravki: MerchantWithProductId = MerchantWithProductId("zapravki_ec6942354de13b309fd5324e965a94f9", "88d270966150417cb4db5093f802f5ce_goods")
}

open class PaymentSdkTusConsumer {
  public static let testTusConsumer: String = "payment_sdk_tests"
  public static let sampleTusConsumer: String = "payment_sdk_sample"
}

@discardableResult
public func getTokenForAcquirer(_ acquirer: Acquirer) -> String {
  switch acquirer {
    case Acquirer.kassa:
      return "15ef6295-4eeb-4f13-8c24-b725bac3d73b"
    case Acquirer.tinkoff:
      return "da4ad816-d160-4f47-bc08-af4b0d76756c"
  }
}

@discardableResult
public func getAcquirerByToken(_ token: String) -> Acquirer {
  switch token {
    case "15ef6295-4eeb-4f13-8c24-b725bac3d73b":
      return Acquirer.kassa
    case "da4ad816-d160-4f47-bc08-af4b0d76756c":
      return Acquirer.tinkoff
    default:
      fatalError("Unknown token: \(token)")
  }
}

@discardableResult
public func getMerchantInfoByAcquirer(_ acquirer: Acquirer) -> MerchantInfo {
  switch acquirer {
    case Acquirer.kassa:
      return MerchantInfo("Индивидуальный предприниматель Soft Kitty Little ball of fur", "c 00:00 до 05:00", "310287914385811", MerchantAddress("Москва", "RUS", "7", "Вознесенский переулок", "195027"))
    case Acquirer.tinkoff:
      return MerchantInfo("Индивидуальный предприниматель sdasdasd asdasda asdasd", "Круглосуточно", "1234567890123", MerchantAddress("Москва", "RUS", "16", "Льва Толстого", "109129"))
  }
}

