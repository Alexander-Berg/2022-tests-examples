// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM action/sample-app-actions.ts >>>

package com.yandex.xplat.testopithecus.payment.sdk

import com.yandex.xplat.common.*
import com.yandex.xplat.eventus.common.*
import com.yandex.xplat.testopithecus.common.*
import com.yandex.xplat.payment.sdk.*

public open class OpenSampleAppAction: MBTAction {
    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val readPaymentDetails = ReadPaymentDetailsFeature.`get`.forceCast(model)
        val account = readPaymentDetails.getAccount()
        val merchantId = readPaymentDetails.getMerchantId()
        val paymentId = readPaymentDetails.getPaymentId()
        val forceCvv = readPaymentDetails.getForceCvv()
        val filter = readPaymentDetails.getPaymentMethodsFilter()
        val isDarkModeEnabled = readPaymentDetails.isDarkModeEnabled()
        val personalInfoShowingMode = readPaymentDetails.getPersonalInfoShowingMode()
        val authorizationMode = readPaymentDetails.getAuthorizationMode()
        val bindingV2Enabled = readPaymentDetails.isBindingV2Enabled()
        val cashEnabled = readPaymentDetails.isCashEnabled()
        val additionalSettings = PaymentAdditionalSettings(forceCvv, filter, isDarkModeEnabled, personalInfoShowingMode, authorizationMode, bindingV2Enabled, cashEnabled)
        val modelStartPaymentProcess = SampleAppFeature.`get`.forceCast(model)
        val appStartPaymentProcess = SampleAppFeature.`get`.forceCast(application)
        modelStartPaymentProcess.startSampleApp(account, merchantId, paymentId, additionalSettings)
        appStartPaymentProcess.startSampleApp(account, merchantId, paymentId, additionalSettings)
        return SampleAppComponent()
    }

    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return (ReadPaymentDetailsFeature.`get`.included(modelFeatures) && SampleAppFeature.`get`.includedAll(modelFeatures, applicationFeatures))
    }

    open override fun canBePerformed(model: App): Boolean {
        return true
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf()
    }

    open override fun tostring(): String {
        return this.getActionType()
    }

    open override fun getActionType(): MBTActionType {
        return OpenSampleAppAction.type
    }

    companion object {
        @JvmStatic val type: MBTActionType = "OpenSampleAppAction"
    }
}

public open class StartCardBindingProcessAction(): BaseSimpleAction<SampleApp, SampleAppComponent>(StartCardBindingProcessAction.type) {
    open override fun performImpl(modelOrApplication: SampleApp, currentComponent: SampleAppComponent): MBTComponent {
        modelOrApplication.bindCard()
        return PaymentMethodNewCardComponent()
    }

    open override fun requiredFeature(): Feature<SampleApp> {
        return SampleAppFeature.`get`
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf()
    }

    companion object {
        @JvmStatic val type: MBTActionType = "StartCardBindingProcessAction"
    }
}

public open class StartRegularPaymentProcessAction: MBTAction {
    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelStartPaymentProcess = SampleAppFeature.`get`.forceCast(model)
        val appStartPaymentProcess = SampleAppFeature.`get`.forceCast(application)
        modelStartPaymentProcess.startRegularPayment()
        appStartPaymentProcess.startRegularPayment()
        val isSomePaymentMethodsAvailable = PaymentMethodsListFeature.`get`.forceCast(model).getMethods().size > 0
        return if (isSomePaymentMethodsAvailable) PaymentMethodSelectionComponent() else PaymentMethodNewCardComponent()
    }

    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return SampleAppFeature.`get`.includedAll(modelFeatures, applicationFeatures)
    }

    open override fun canBePerformed(model: App): Boolean {
        return true
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf()
    }

    open override fun tostring(): String {
        return this.getActionType()
    }

    open override fun getActionType(): MBTActionType {
        return StartRegularPaymentProcessAction.type
    }

    companion object {
        @JvmStatic val type: MBTActionType = "StartRegularPaymentProcessAction"
    }
}

public open class StartPreselectPaymentProcessAction: MBTAction {
    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelStartPaymentProcess = SampleAppFeature.`get`.forceCast(model)
        val appStartPaymentProcess = SampleAppFeature.`get`.forceCast(application)
        modelStartPaymentProcess.startPreselectPayment()
        appStartPaymentProcess.startPreselectPayment()
        val isSomePaymentMethodsAvailable = PaymentMethodsListFeature.`get`.forceCast(model).getMethods().size > 0
        return if (isSomePaymentMethodsAvailable) PaymentMethodSelectionComponent() else PaymentMethodNewCardComponent()
    }

    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return SampleAppFeature.`get`.includedAll(modelFeatures, applicationFeatures)
    }

    open override fun canBePerformed(model: App): Boolean {
        return true
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf()
    }

    open override fun tostring(): String {
        return this.getActionType()
    }

    open override fun getActionType(): MBTActionType {
        return StartPreselectPaymentProcessAction.type
    }

    companion object {
        @JvmStatic val type: MBTActionType = "StartPreselectPaymentProcessAction"
    }
}

