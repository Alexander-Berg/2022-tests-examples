// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM payment-sdk-data.ts >>>

package com.yandex.xplat.testopithecus.payment.sdk

import com.yandex.xplat.common.*
import com.yandex.xplat.eventus.common.*
import com.yandex.xplat.testopithecus.common.*
import com.yandex.xplat.payment.sdk.*

public open class PaymentDataPreparer(val trustService: TrustService, private var userService: PaymentUserService, private var yaOplataService: YaOplataService, var mockPrepareService: MockPrepareService): AccountDataPreparer {
    val merchantLocalizedName: String = "name"
    private var account: OAuthUserAccount? = null
    private var merchantId: String = Merchants.paymentSDK.merchantId
    private var productId: String = Merchants.paymentSDK.productId
    private var paymentId: String = ""
    private var orderId: String = ""
    private var availableMethods: AvailableMethods = AvailableMethods.EMPTY
    private var boundCards: YSArray<BoundCard> = mutableListOf()
    private var code3ds: String? = null
    private var cvv: String = BoundCardConstants.CVV
    private var amount: String = "100.00"
    private var forceCvv: Boolean = false
    private var forcedErrorType: PaymentErrorType? = null
    private var darkModeEnabled: Boolean = false
    private var methodsFilter: PaymentMethodsFilter = PaymentMethodsFilter()
    private var cashEnabled: Boolean = false
    private var personalInfoShowingMode: PersonalInfoMode = PersonalInfoMode.HIDE
    private var authorizationMode: AuthorizationMode = AuthorizationMode.authorized
    private var markupPurchaseNeeded: Boolean = false
    private var bindingV2Enabled: Boolean = false
    private var yaOplata: Boolean = false
    private var acquirer: Acquirer? = null
    private var familyInfoMode: FamilyInfoMode = FamilyInfoMode.disabled
    open override fun prepare(account: OAuthUserAccount): XPromise<Unit> {
        this.account = account
        if (this.markupPurchaseNeeded) {
            return this.createPurchase(account).flatThen( {
                _ ->
                this.cleanAccountAndBindCards(account)
            }).flatThen( {
                _ ->
                this.startPurchase(account)
            }).flatThen( {
                _ ->
                this.getPaymentMethodList(account)
            })
        }
        return this.createPurchase(account).flatThen( {
            _ ->
            this.cleanAccountAndBindCards(account)
        }).flatThen( {
            _ ->
            this.getPaymentMethodList(account)
        })
    }

    private fun createPurchase(account: OAuthUserAccount): XPromise<Unit> {
        return if (this.yaOplata) this.yaOplataService.createOrder(getTokenForAcquirer(this.acquirer!!), this.amount).flatCatch( {
            e ->
            reject(YSError("Unable to create order, error: ${e.message}"))
        }).then(__LBL__PaymentSdkData_1@ {
            token ->
            this.paymentId = token
            return@__LBL__PaymentSdkData_1 getVoid()
        }) else this.trustService.createPurchase(account, this.merchantId, this.productId, this.code3ds != null, this.amount, this.forceCvv).flatCatch( {
            e ->
            reject(YSError("Unable to obtain purchase id from TRUST, error: ${e.message}"))
        }).flatThen(__LBL__PaymentSdkData_2@ {
            purchase ->
            this.paymentId = purchase.purchaseId
            this.orderId = purchase.orderId
            return@__LBL__PaymentSdkData_2 toPromise(resultValue(getVoid()))
        })
    }

    private fun cleanAccountAndBindCards(account: OAuthUserAccount): XPromise<Unit> {
        return this.userService.cleanAccountAndBindCards(account, this.boundCards, this.merchantId).flatCatch( {
            e ->
            reject(YSError("Unable to clean account and bind cards, error: ${e.message}"))
        }).flatThen( {
            _: Unit ->
            this.configureFamilyInfoModeIfNeeded()
        })
    }

    private fun configureFamilyInfoModeIfNeeded(): XPromise<Unit> {
        if (this.familyInfoMode == FamilyInfoMode.disabled) {
            return resolve<Unit>(getVoid())
        }
        return this.mockPrepareService.setMockFamilyInfoMode(this.familyInfoMode).then( {
            _: Boolean ->
            getVoid()
        })
    }

    private fun startPurchase(account: OAuthUserAccount): XPromise<Unit> {
        return this.trustService.startPurchase(account, this.merchantId, this.paymentId).flatCatch( {
            e ->
            reject(YSError("Unable to start purchase, error: ${e.message}"))
        })
    }

    private fun getPaymentMethodList(account: OAuthUserAccount): XPromise<Unit> {
        return this.userService.getPaymentMethods(account, this.merchantId).flatCatch( {
            e ->
            reject(YSError("Unable to get payment methods, error: ${e.message}"))
        }).then(__LBL__PaymentSdkData_3@ {
            paymentMethods: AvailableMethods ->
            this.availableMethods = paymentMethods.builder().setIsGooglePayAvailable(paymentMethods.isGooglePayAvailable && this.methodsFilter.isGooglePayAvailable && !this.yaOplata).setIsApplePayAvailable(paymentMethods.isGooglePayAvailable && this.methodsFilter.isGooglePayAvailable && !this.yaOplata).setIsCashAvailable(this.cashEnabled).setIsSpbQrAvailable(paymentMethods.isSpbQrAvailable && this.methodsFilter.isSBPAvailable && !this.yaOplata).build()
            return@__LBL__PaymentSdkData_3 getVoid()
        })
    }

    open fun getAccount(): OAuthUserAccount {
        return this.account!!
    }

    open fun getMerchantId(): String {
        return this.merchantId
    }

    open fun setMerchantId(merchantId: String): PaymentDataPreparer {
        this.merchantId = merchantId
        return this
    }

    open fun setBindingV2(bindingV2Enabled: Boolean): PaymentDataPreparer {
        this.bindingV2Enabled = bindingV2Enabled
        return this
    }

    open fun isBindingV2Enabled(): Boolean {
        return this.bindingV2Enabled
    }

    open fun getPaymentId(): String {
        return this.paymentId
    }

    open fun getOrderId(): String {
        return this.orderId
    }

    open fun getAvailableMethods(): AvailableMethods {
        return this.availableMethods
    }

    open fun getProductId(): String {
        return this.productId
    }

    open fun setProductId(productId: String): PaymentDataPreparer {
        this.productId = productId
        return this
    }

    open fun clearBoundCards(): Unit {
        this.boundCards = mutableListOf()
    }

    open fun addBoundCard(card: BoundCard): PaymentDataPreparer {
        this.boundCards.add(card)
        return this
    }

    open fun setFamilyInfoMode(mode: FamilyInfoMode): PaymentDataPreparer {
        this.familyInfoMode = mode
        return this
    }

    open fun getCvv(): String {
        return this.cvv
    }

    open fun setCvv(cvv: String): PaymentDataPreparer {
        this.cvv = cvv
        return this
    }

    open fun setUseYaOplata(use: Boolean): PaymentDataPreparer {
        this.yaOplata = use
        return this
    }

    open fun getAcquirer(): Acquirer? {
        return this.acquirer
    }

    open fun setAcquirer(acquirer: Acquirer?): PaymentDataPreparer {
        this.acquirer = acquirer
        return this
    }

    open fun get3ds(): String? {
        return this.code3ds
    }

    open fun set3ds(code: String): PaymentDataPreparer {
        this.code3ds = code
        return this
    }

    open fun enableCash(): PaymentDataPreparer {
        this.cashEnabled = true
        return this
    }

    open fun isCashEnabled(): Boolean {
        return this.cashEnabled
    }

    open fun forcePaymentError(type: PaymentErrorType): PaymentDataPreparer {
        this.amount = type.toString()
        this.forcedErrorType = type
        return this
    }

    open fun forcedPaymentErrorType(): PaymentErrorType? {
        return this.forcedErrorType
    }

    open fun getForceCvv(): Boolean {
        return this.forceCvv
    }

    open fun setForceCvv(forceCvv: Boolean): PaymentDataPreparer {
        this.forceCvv = forceCvv
        return this
    }

    open fun isDarkModeEnabled(): Boolean {
        return this.darkModeEnabled
    }

    open fun setDarkMode(enabled: Boolean): PaymentDataPreparer {
        this.darkModeEnabled = enabled
        return this
    }

    open fun getAmount(): String {
        return this.amount
    }

    open fun setAmount(amount: String): PaymentDataPreparer {
        this.amount = amount
        return this
    }

    open fun getPaymentMethodsFilter(): PaymentMethodsFilter {
        return this.methodsFilter
    }

    open fun setPaymentMethodsFilter(filter: PaymentMethodsFilter): PaymentDataPreparer {
        this.methodsFilter = filter
        return this
    }

    open fun getPersonalInfoShowingMode(): PersonalInfoMode {
        return this.personalInfoShowingMode
    }

    open fun setPersonalInfoShowingMode(mode: PersonalInfoMode): PaymentDataPreparer {
        this.personalInfoShowingMode = mode
        return this
    }

    open fun getAuthorizationMode(): AuthorizationMode {
        return this.authorizationMode
    }

    open fun setAuthorizationMode(mode: AuthorizationMode): PaymentDataPreparer {
        this.authorizationMode = mode
        return this
    }

}

public open class PaymentSdkModelProvider(private val preparer: PaymentDataPreparer): AppModelProvider {
    open override fun takeAppModel(): AppModel {
        return PaymentSdkModel(this.preparer.getAccount(), this.preparer.getMerchantId(), this.preparer.getPaymentId(), this.preparer.getAvailableMethods(), this.preparer.getAmount(), "₽", this.preparer.get3ds(), this.preparer.getCvv() == BoundCardConstants.CVV, this.preparer.forcedPaymentErrorType(), this.preparer.getForceCvv(), this.preparer.getPaymentMethodsFilter(), this.preparer.isDarkModeEnabled(), this.preparer.getPersonalInfoShowingMode(), this.preparer.getAuthorizationMode(), this.preparer.isBindingV2Enabled(), this.preparer.isCashEnabled(), this.preparer.getAcquirer())
    }

}

public open class PaymentDataPreparerProvider(private var trustNetwork: Network, private var yaOplataNetwork: Network, private var diehardNetwork: Network, private var mobileBackendNetwork: Network, private var syncNetwork: SyncNetwork, private var jsonSerializer: JSONSerializer, private var tusConsumer: String, private var forcedOauthHost: String? = null): AccountDataPreparerProvider<PaymentDataPreparer>() {
    open fun providePaymentDataPreparer(): PaymentDataPreparer {
        val trustService = TrustService.create(this.trustNetwork, this.jsonSerializer, null)
        val yaOplataService = YaOplataService.create(this.yaOplataNetwork, this.jsonSerializer)
        val userService = PaymentUserService.build(this.diehardNetwork, this.mobileBackendNetwork, this.syncNetwork, this.jsonSerializer, null, this.tusConsumer, this.forcedOauthHost)
        val mockPrepareService = MockPrepareService.create(this.trustNetwork, this.jsonSerializer)
        return PaymentDataPreparer(trustService, userService, yaOplataService, mockPrepareService)
    }

    open override fun provide(lockedAccount: UserAccount, type: AccountType2): PaymentDataPreparer {
        return this.providePaymentDataPreparer()
    }

    open override fun provideModelDownloader(fulfilledPreparers: YSArray<PaymentDataPreparer>, accountsWithTokens: YSArray<OAuthUserAccount>): AppModelProvider {
        return PaymentSdkModelProvider(fulfilledPreparers[0])
    }

    companion object {
        @JvmStatic
        open fun build(trustNetwork: Network, yaOplataNetwork: Network, diehardNetwork: Network, mobileBackendNetwork: Network, syncNetwork: SyncNetwork, jsonSerializer: JSONSerializer, tusConsumer: String): PaymentDataPreparerProvider {
            return PaymentDataPreparerProvider(trustNetwork, yaOplataNetwork, diehardNetwork, mobileBackendNetwork, syncNetwork, jsonSerializer, tusConsumer)
        }

    }
}

public enum class PaymentErrorType(val value: String) {
    notEnoughFunds("1099.00"),
    invalidTransaction("1092.00"),
    force3ds("1093.00"),
    restrictedCard36("1097.00"),
    restrictedCard62("1096.00"),
    transactionNotPermittedToCard57("1094.00"),
    transactionNotPermittedToCard58("1095.00"),
    doNotHonor("1090.00"),
    ;
    override fun toString(): String = value
}
public open class PaymentMethodName {
    companion object {
        @JvmStatic val cash: String = "Cash"
        @JvmStatic val applePay: String = "Apple Pay"
        @JvmStatic val googlePay: String = "Google Pay"
        @JvmStatic val sbp: String = "Faster Payments Systems"
        @JvmStatic val otherCard: String = "Another card"
        @JvmStatic val familyPayPrefix: String = "Family"
    }
}

public open class MerchantWithProductId(val merchantId: String, val productId: String) {
}

public open class Merchants {
    companion object {
        @JvmStatic val paymentSDK: MerchantWithProductId = MerchantWithProductId("payment_sdk_19d9962ddd08e7d52a2668cbcd5f7b7e", "6735968470625602946")
        @JvmStatic val beru: MerchantWithProductId = MerchantWithProductId("blue_market_payments_5fac16d65c83b948a5b10577f373ea7c", "6101710988743309398")
        @JvmStatic val zapravki: MerchantWithProductId = MerchantWithProductId("zapravki_ec6942354de13b309fd5324e965a94f9", "88d270966150417cb4db5093f802f5ce_goods")
    }
}

public open class PaymentSdkTusConsumer {
    companion object {
        @JvmStatic val testTusConsumer: String = "payment_sdk_tests"
        @JvmStatic val sampleTusConsumer: String = "payment_sdk_sample"
    }
}

public fun getTokenForAcquirer(acquirer: Acquirer): String {
    when (acquirer) {
        Acquirer.kassa -> {
            return "15ef6295-4eeb-4f13-8c24-b725bac3d73b"
        }
        Acquirer.tinkoff -> {
            return "da4ad816-d160-4f47-bc08-af4b0d76756c"
        }
    }
}

public fun getAcquirerByToken(token: String): Acquirer {
    when (token) {
        "15ef6295-4eeb-4f13-8c24-b725bac3d73b" -> {
            return Acquirer.kassa
        }
        "da4ad816-d160-4f47-bc08-af4b0d76756c" -> {
            return Acquirer.tinkoff
        }
        else -> {
            throw Error("Unknown token: ${token}")
        }
    }
}

public fun getMerchantInfoByAcquirer(acquirer: Acquirer): MerchantInfo {
    when (acquirer) {
        Acquirer.kassa -> {
            return MerchantInfo("Индивидуальный предприниматель Soft Kitty Little ball of fur", "c 00:00 до 05:00", "310287914385811", MerchantAddress("Москва", "RUS", "7", "Вознесенский переулок", "195027"))
        }
        Acquirer.tinkoff -> {
            return MerchantInfo("Индивидуальный предприниматель sdasdasd asdasda asdasd", "Круглосуточно", "1234567890123", MerchantAddress("Москва", "RUS", "16", "Льва Толстого", "109129"))
        }
    }
}

