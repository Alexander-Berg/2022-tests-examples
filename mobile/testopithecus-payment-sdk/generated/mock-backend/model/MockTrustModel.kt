// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mock-backend/model/mock-trust-model.ts >>>

package com.yandex.xplat.testopithecus.payment.sdk

import com.yandex.xplat.common.*
import com.yandex.xplat.eventus.common.*
import com.yandex.xplat.testopithecus.common.*
import com.yandex.xplat.payment.sdk.*

public open class MockTrustModel(private val bindingCardExtractor: BindingCardExtractor, private val sbpSupport: Boolean = false) {
    private var cards: YSMap<String, YSArray<MockCard>> = mutableMapOf<String, YSArray<MockCard>>()
    private var orders: YSArray<MockOrder> = mutableListOf<MockOrder>()
    private var bindings: YSArray<MockBindingV2> = mutableListOf<MockBindingV2>()
    private var mockBankNameStartIndex: Int = 0
    private var mockBanks: YSArray<BankName> = getAllVisibleBankNames()
    private var familyInfoMode: FamilyInfoMode = FamilyInfoMode.disabled
    open fun createOrder(service: String?, isBinding: Boolean = false): String {
        val order = MockOrder(this.generateId(), service, isBinding)
        this.orders.add(order)
        return order.id
    }

    open fun createYaOplataOrder(amount: String, token: String, acquirer: Acquirer?): String {
        val order = MockOrder(this.generateId(), null, false, amount, token, acquirer)
        this.orders.add(order)
        return order.id
    }

    open fun checkHasPurchase(purchaseToken: String): Boolean {
        val order = undefinedToNull(this.orders.find( {
            value ->
            value.token == purchaseToken
        }))
        return order != null
    }

    open fun setupOrder(orderId: String, amount: String, force3ds: Boolean): Result<String> {
        val current = undefinedToNull(this.orders.find( {
            value ->
            value.id == orderId
        }))
        if (current == null) {
            return resultError(YSError("No order"))
        }
        current!!.amount = amount
        current!!.token = this.generateId()
        current!!.forced3ds = force3ds
        return resultValue(current!!.token)
    }

    open fun initPayment(oAuth: String?, email: String?, purchaseToken: String, service: String?, checkCvn: Boolean): Result<InitPaymentData> {
        if (oAuth == null && email == null) {
            return resultError(MobPaymentError("incorrect format", "body seems to be malformed: bad email"))
        }
        if (email != null && !this.checkEmail(email!!)) {
            return resultError(MobPaymentError("incorrect format", "body seems to be malformed: bad email"))
        }
        val order = undefinedToNull(this.orders.find( {
            order ->
            order.token == purchaseToken
        }))
        if (order == null) {
            return resultError(MobPaymentError("internal error", "internal_error"))
        }
        val isYaOplata = this.isYaOplata(purchaseToken)
        if (service != order!!.service) {
            if (!isYaOplata) {
                return resultError(MobPaymentError("internal error", "internal_error"))
            }
        }
        order!!.checkCvn = checkCvn
        var acquirer: Acquirer? = null
        var merchant: MerchantInfo? = null
        val enabledMethods: YSArray<EnabledPaymentMethod> = mutableListOf<EnabledPaymentMethod>()
        enabledMethods.add(EnabledPaymentMethod("card"))
        if (isYaOplata) {
            acquirer = order!!.acquirer!!
            merchant = getMerchantInfoByAcquirer(acquirer)
        } else if (this.sbpSupport) {
            enabledMethods.add(EnabledPaymentMethod("sbp_qr"))
        }
        return resultValue(InitPaymentData(purchaseToken, order!!.amount, PaymentMethodsData(this.getUserCards(oAuth, checkCvn), enabledMethods), acquirer, merchant))
    }

    private fun isYaOplata(purchaseToken: String): Boolean {
        return purchaseToken.startsWith("payment:")
    }

    open fun paymentMethods(oAuth: String?, checkCvn: Boolean): PaymentMethodsData {
        val enabledMethods: YSArray<EnabledPaymentMethod> = mutableListOf<EnabledPaymentMethod>()
        enabledMethods.add(EnabledPaymentMethod("card"))
        if (this.sbpSupport) {
            enabledMethods.add(EnabledPaymentMethod("sbp_qr"))
        }
        return PaymentMethodsData(this.getUserCards(oAuth, checkCvn), enabledMethods)
    }

    open fun supplyPaymentBySbp(oAuth: String?, purchaseToken: String): Result<String> {
        val order = undefinedToNull(this.orders.find( {
            value ->
            value.token == purchaseToken
        }))
        if (order == null) {
            return resultError(YSError("payment_not_found"))
        }
        if (oAuth == null) {
            return resultError(YSError("authorization_reject"))
        }
        order!!.supplied = MockSuppliedMethod("sbp_qr")
        return resultValue("success")
    }

    open fun supplyPaymentByStoredCard(oAuth: String?, purchaseToken: String, methodId: String, cvn: String?): Result<String> {
        val order = undefinedToNull(this.orders.find( {
            value ->
            value.token == purchaseToken
        }))
        if (order == null) {
            return resultError(YSError("payment_not_found"))
        }
        if (oAuth == null) {
            return resultError(YSError("authorization_reject"))
        }
        val card = this.findUserCardById(oAuth!!, methodId)
        if (card == null) {
            return resultError(YSError("technical_error"))
        }
        if (order!!.checkCvn && card!!.cvn != cvn) {
            return resultError(YSError("technical_error"))
        }
        order!!.supplied = MockSuppliedMethod(methodId, this.ask3ds(order!!))
        return resultValue("success")
    }

    open fun supplyPaymentByNewCard(oAuth: String?, purchaseToken: String, cardNumber: String, expirationMonth: String, expirationYear: String, cvn: String, bindCard: Boolean): Result<String> {
        val order = undefinedToNull(this.orders.find( {
            value ->
            value.token == purchaseToken
        }))
        if (order == null) {
            return resultError(YSError("payment_not_found"))
        }
        val card = MockCard(cardNumber, expirationMonth, expirationYear, cvn, "card-x" + this.generateId())
        if (bindCard) {
            if (oAuth == null) {
                return resultError(YSError("authorization_reject"))
            }
            val result = this.tryBindCard(card, oAuth!!)
            if (!result) {
                return resultError(YSError("too_many_cards"))
            }
        }
        if (!order!!.finished) {
            order!!.supplied = MockSuppliedMethod(card.id, this.ask3ds(order!!))
        }
        return resultValue("success")
    }

    open fun checkPayment(purchaseToken: String): Result<CheckPaymentData> {
        val order = undefinedToNull(this.orders.find( {
            value ->
            value.token == purchaseToken
        }))
        if (order == null) {
            return resultError(YSError("payment_not_found"))
        } else if (order!!.supplied != null) {
            if (order!!.supplied!!.methodId == "sbp_qr") {
                return this.handleSbp(order!!)
            }
            if (order!!.supplied!!.verification3ds != Verification3dsState.not_required) {
                return this.handle3ds(order!!.supplied!!.verification3ds, order!!.supplied!!.code3ds, order!!)
            }
            order!!.finished = true
            val special = this.handleSpecialAmount(order!!.amount)
            if (special != null) {
                return resultError(YSError(special))
            }
            if (order!!.isBinding) {
                val result = this.handleBindingV2Payment(purchaseToken)
                if (!result) {
                    return resultError(YSError("too_many_cards"))
                }
            }
            return this.respondPaidOk(order!!)
        } else {
            return resultError(YSError("unknown_error"))
        }
    }

    private fun handleSbp(order: MockOrder): Result<CheckPaymentData> {
        if (!order.supplied!!.sbpConfirmed) {
            return resultValue(CheckPaymentData("wait_for_notification", "in progress", order.token, order.amount, order.isBinding, YSDate.now().toString(), null, this.makeSbpFormUrl(order.token)))
        } else {
            order.finished = true
            return this.respondPaidOk(order)
        }
    }

    open fun bindCard(oAuth: String, cardNumber: String, expirationMonth: String, expirationYear: String, cvn: String, service: String?): Result<String> {
        val card = MockCard(cardNumber, expirationMonth, expirationYear, cvn, "card-x" + this.generateId())
        val result = this.tryBindCard(card, oAuth)
        if (!result) {
            return resultError(YSError("too_many_cards"))
        }
        return resultValue("success")
    }

    open fun unBindCard(oAuth: String, cardId: String): Result<String> {
        val userCards = undefinedToNull(this.cards.get(oAuth))
        if (userCards == null) {
            return resultError(YSError("invalid_processing_request"))
        }
        val cards = userCards!!
        var cardIndex: Int = 0
        var bound: MockCard? = null
        for (i in (0 until cards.size step 1)) {
            if (cards[i].id == cardId) {
                cardIndex = i
                bound = cards[i]
            }
        }
        if (bound == null) {
            return resultError(YSError("invalid_processing_request"))
        }
        cards.splice(cardIndex, 1)
        return resultValue("success")
    }

    open fun has3dsChallenge(purchaseToken: String): Boolean {
        val order = this.find3dsChallenge(purchaseToken)
        if (order == null) {
            return false
        }
        return order!!.supplied!!.verification3ds == Verification3dsState.required
    }

    open fun provide3ds(purchaseToken: String, code: String): Boolean {
        val order = this.find3dsChallenge(purchaseToken)
        if (order == null) {
            return false
        }
        if (order!!.supplied!!.verification3ds != Verification3dsState.required) {
            return false
        }
        order!!.supplied!!.verification3ds = Verification3dsState.provided
        order!!.supplied!!.code3ds = code
        return true
    }

    open fun startV2Binding(oAuth: String, cardData: String, hashAlgo: String, service: String): Result<String> {
        val card = this.bindingCardExtractor.createCardFromData("card-x" + this.generateId(), cardData, hashAlgo)
        if (card.isError()) {
            return resultError(YSError("invalid_processing_request"))
        }
        val bind = MockBindingV2(oAuth, service, card.getValue(), this.generateId())
        this.bindings.add(bind)
        return resultValue(bind.card.id)
    }

    open fun verifyBinding(oAuth: String, cardId: String, service: String): Result<String> {
        val existentCard = this.findUserCardById(oAuth, cardId)
        var binding: MockBindingV2? = undefinedToNull(this.bindings.find( {
            value ->
            value.card.id == cardId
        }))
        if (binding != null && binding!!.service != service) {
            return resultError(MobPaymentError("internal error", "internal_error"))
        }
        if (existentCard != null && binding == null) {
            binding = MockBindingV2(oAuth, service, existentCard!!, "")
            this.bindings.add(binding)
        } else if (existentCard != null || binding == null) {
            return resultError(MobPaymentError("internal error", "internal_error"))
        }
        val order = this.createOrder(service, true)
        val purchase = this.setupOrder(order, "2.0", true)
        if (purchase.isError()) {
            return resultError(MobPaymentError("internal error", "internal_error"))
        }
        binding!!.purchaseToken = purchase.getValue()
        var res: Result<String> = resultError(YSError("invalid_processing_request"))
        if (existentCard != null) {
            res = this.supplyPaymentByStoredCard(oAuth, purchase.getValue(), existentCard!!.id, null)
        } else {
            res = this.supplyPaymentByNewCard(oAuth, purchase.getValue(), binding!!.card.cardNumber, binding!!.card.expirationMonth, binding!!.card.expirationYear, binding!!.card.cvn, false)
        }
        if (res.isError()) {
            return res
        }
        return resultValue(binding!!.purchaseToken)
    }

    open fun confirmSbpPaid(purchaseToken: String): Boolean {
        val order = undefinedToNull(this.orders.find( {
            value ->
            value.token == purchaseToken
        }))
        if (order == null) {
            return false
        }
        if (order!!.supplied == null) {
            return false
        }
        if (order!!.supplied!!.methodId != "sbp_qr") {
            return false
        }
        order!!.supplied!!.sbpConfirmed = true
        return true
    }

    open fun setStartMockBank(bank: String): Result<Unit> {
        val index = this.mockBanks.lastIndexOf(stringToBankName(bank))
        if (index > this.mockBanks.size - 1 || index < 0) {
            return resultError(MobPaymentError("internal error", "internal_error"))
        }
        this.mockBankNameStartIndex = index
        return resultValue(getVoid())
    }

    open fun setFamilyInfoMode(mode: FamilyInfoMode): Unit {
        this.familyInfoMode = mode
    }

    private fun find3dsChallenge(purchaseToken: String): MockOrder? {
        val order = undefinedToNull(this.orders.find( {
            value ->
            value.token == purchaseToken
        }))
        if (order == null) {
            return null
        }
        if (order!!.supplied == null) {
            return null
        }
        return order
    }

    private fun getUserCards(oAuth: String?, checkCvn: Boolean): YSArray<PaymentMethod> {
        if (oAuth == null) {
            return mutableListOf<PaymentMethod>()
        }
        val userCards = undefinedToNull(this.cards.get(oAuth))
        if (userCards == null) {
            return mutableListOf<PaymentMethod>()
        }
        var cardIndex: Int = 0
        var bankIndex = this.mockBankNameStartIndex
        return userCards!!.map(__LBL__MockTrustModel_1@ {
            card ->
            val system = CardPaymentSystemChecker.instance.lookup(card.cardNumber).toString()
            val lastDigits = card.cardNumber.slice(-4)
            val masked = lastDigits.padStart(card.cardNumber.length, "*")
            val bankName = this.mockBanks[bankIndex]
            var familyInfo: FamilyInfo? = null
            if (cardIndex == 0) {
                familyInfo = this.getFamilyInfo()
            }
            bankIndex = (bankIndex + 1) % this.mockBanks.size
            cardIndex = cardIndex + 1
            return@__LBL__MockTrustModel_1 PaymentMethod(card.id, masked, system, checkCvn, bankName, familyInfo, null)
        })
    }

    private fun checkEmail(email: String): Boolean {
        if (email.length == 0) {
            return true
        }
        val str = email.split("")
        return str.contains(".") && str.size >= 5 && str.filter( {
            item ->
            item == "@"
        }).size == 1
    }

    private fun generateId(): String {
        return YSDate.now().toString()
    }

    private fun ask3ds(order: MockOrder): Verification3dsState {
        if (order.amount == "1093.00" || order.forced3ds) {
            return Verification3dsState.required
        }
        return Verification3dsState.not_required
    }

    private fun tryBindCard(card: MockCard, oAuth: String): Boolean {
        val userCards = undefinedToNull(this.cards.get(oAuth))
        if (userCards == null) {
            val added = mutableListOf<MockCard>()
            added.add(card)
            this.cards.set(oAuth, added)
        } else {
            val cards = userCards!!
            if (cards.size == 5) {
                return false
            }
            var exists = false
            cards.forEach(__LBL__MockTrustModel_2@ {
                value ->
                if (value.cardNumber == card.cardNumber) {
                    exists = true
                }
            })
            if (!exists) {
                cards.add(card)
            }
        }
        return true
    }

    private fun findUserCardById(oAuth: String, cardId: String): MockCard? {
        val userCards = undefinedToNull(this.cards.get(oAuth))
        if (userCards != null) {
            return undefinedToNull(userCards!!.find( {
                value ->
                value.id == cardId
            }))
        }
        return null
    }

    private fun respondPaidOk(order: MockOrder, redirect3dsUrl: String? = null): Result<CheckPaymentData> {
        return resultValue(CheckPaymentData("success", "paid ok", order.token, order.amount, order.isBinding, YSDate.now().toString(), redirect3dsUrl, null))
    }

    private fun handleBindingV2Payment(purchaseToken: String): Boolean {
        var bindIndex: Int = 0
        for (i in (0 until this.bindings.size step 1)) {
            if (this.bindings[i].purchaseToken == purchaseToken) {
                bindIndex = i
                break
            }
        }
        val result = this.tryBindCard(this.bindings[bindIndex].card, this.bindings[bindIndex].oAuth)
        this.bindings = this.bindings.slice(bindIndex, 1)
        return result
    }

    private fun handle3ds(state: Verification3dsState, code: String, order: MockOrder): Result<CheckPaymentData> {
        if (state == Verification3dsState.required) {
            return resultValue(CheckPaymentData("wait_for_notification", "in progress", order.token, order.amount, order.isBinding, YSDate.now().toString(), this.make3dsUrl(order.token), null))
        }
        order.finished = true
        when (code) {
            "200" -> {
                if (order.isBinding) {
                    val result = this.handleBindingV2Payment(order.token)
                    if (!result) {
                        return resultError(YSError("too_many_cards"))
                    }
                }
                return this.respondPaidOk(order, this.make3dsUrl(order.token))
            }
            "400" -> {
                return resultError(YSError("technical_error"))
            }
            "401" -> {
                return resultError(YSError("fail_3ds"))
            }
            "300" -> {
                return resultError(YSError("not_enough_funds"))
            }
            "301" -> {
                return resultError(YSError("limit_exceeded"))
            }
            "302" -> {
                return resultError(YSError("payment_timeout"))
            }
            "303" -> {
                return resultError(YSError("technical_error"))
            }
            "304" -> {
                return resultError(YSError("limit_exceeded"))
            }
            "305" -> {
                return resultError(YSError("restricted_card"))
            }
            "306" -> {
                return resultError(YSError("transaction_not_permitted"))
            }
            else -> {
                return resultError(YSError("unknown_error"))
            }
        }
    }

    private fun make3dsUrl(purchaseToken: String): String {
        return "http://127.0.0.1:8080/web/redirect_3ds?purchase_token=${purchaseToken}"
    }

    private fun makeSbpFormUrl(purchaseToken: String): String {
        return "https://qr.nspk.ru/invalid/pay_sbp?purchase_token=${purchaseToken}"
    }

    private fun handleSpecialAmount(amount: String): String? {
        when (amount) {
            "1099.00" -> {
                return "not_enough_funds"
            }
            "1092.00" -> {
                return "limit_exceeded"
            }
            "1097.00" -> {
                return "restricted_card"
            }
            "1096.00" -> {
                return "restricted_card"
            }
            "1094.00" -> {
                return "transaction_not_permitted"
            }
            "1095.00" -> {
                return "transaction_not_permitted"
            }
            else -> {
                return null
            }
        }
    }

    private fun getFamilyInfo(): FamilyInfo? {
        val frame = FamilyInfoFrame.month.toString()
        when (this.familyInfoMode) {
            FamilyInfoMode.disabled -> {
                return null
            }
            FamilyInfoMode.enabled_low_allowance -> {
                return FamilyInfo("1", "f1", 9999, 10000, "RUB", frame, false)
            }
            FamilyInfoMode.enabled_high_allowance -> {
                return FamilyInfo("1", "f1", 0, 10000, "RUB", frame, false)
            }
            FamilyInfoMode.enabled_unbound_limit -> {
                return FamilyInfo("1", "f1", 0, 100000000, "RUB", frame, true)
            }
            else -> {
                return null
            }
        }
    }

}

