// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mock-backend/model/mock-trust-model.ts >>>

import Foundation

open class MockTrustModel {
  private var cards: YSMap<String, YSArray<MockCard>> = YSMap<String, YSArray<MockCard>>()
  private var orders: YSArray<MockOrder> = YSArray<MockOrder>()
  private var bindings: YSArray<MockBindingV2> = YSArray<MockBindingV2>()
  private var mockBankNameStartIndex: Int32 = 0
  private var mockBanks: YSArray<BankName> = getAllVisibleBankNames()
  private var familyInfoMode: FamilyInfoMode = FamilyInfoMode.disabled
  private let bindingCardExtractor: BindingCardExtractor
  private let sbpSupport: Bool
  public init(_ bindingCardExtractor: BindingCardExtractor, _ sbpSupport: Bool = false) {
    self.bindingCardExtractor = bindingCardExtractor
    self.sbpSupport = sbpSupport
  }

  @discardableResult
  open func createOrder(_ service: String!, _ isBinding: Bool = false) -> String {
    let order = MockOrder(self.generateId(), service, isBinding)
    self.orders.push(order)
    return order.id
  }

  @discardableResult
  open func createYaOplataOrder(_ amount: String, _ token: String, _ acquirer: Acquirer!) -> String {
    let order = MockOrder(self.generateId(), nil, false, amount, token, acquirer)
    self.orders.push(order)
    return order.id
  }

  @discardableResult
  open func checkHasPurchase(_ purchaseToken: String) -> Bool {
    let order = undefinedToNull(self.orders.find({
      (value) in
      value.token == purchaseToken
    }))
    return order != nil
  }

  @discardableResult
  open func setupOrder(_ orderId: String, _ amount: String, _ force3ds: Bool) -> Result<String> {
    let current = undefinedToNull(self.orders.find({
      (value) in
      value.id == orderId
    }))
    if current == nil {
      return resultError(YSError("No order"))
    }
    current!.amount = amount
    current!.token = self.generateId()
    current!.forced3ds = force3ds
    return resultValue(current!.token)
  }

  @discardableResult
  open func initPayment(_ oAuth: String!, _ email: String!, _ purchaseToken: String, _ service: String!, _ checkCvn: Bool) -> Result<InitPaymentData> {
    if oAuth == nil && email == nil {
      return resultError(MobPaymentError("incorrect format", "body seems to be malformed: bad email"))
    }
    if email != nil && !self.checkEmail(email!) {
      return resultError(MobPaymentError("incorrect format", "body seems to be malformed: bad email"))
    }
    let order = undefinedToNull(self.orders.find({
      (order) in
      order.token == purchaseToken
    }))
    if order == nil {
      return resultError(MobPaymentError("internal error", "internal_error"))
    }
    let isYaOplata = self.isYaOplata(purchaseToken)
    if service != order!.service {
      if !isYaOplata {
        return resultError(MobPaymentError("internal error", "internal_error"))
      }
    }
    order!.checkCvn = checkCvn
    var acquirer: Acquirer! = nil
    var merchant: MerchantInfo! = nil
    let enabledMethods: YSArray<EnabledPaymentMethod> = YSArray<EnabledPaymentMethod>()
    enabledMethods.push(EnabledPaymentMethod("card"))
    if isYaOplata {
      acquirer = order!.acquirer!
      merchant = getMerchantInfoByAcquirer(acquirer)
    } else if self.sbpSupport {
      enabledMethods.push(EnabledPaymentMethod("sbp_qr"))
    }
    return resultValue(InitPaymentData(purchaseToken, order!.amount, PaymentMethodsData(self.getUserCards(oAuth, checkCvn), enabledMethods), acquirer, merchant))
  }

  @discardableResult
  private func isYaOplata(_ purchaseToken: String) -> Bool {
    return purchaseToken.startsWith("payment:")
  }

  @discardableResult
  open func paymentMethods(_ oAuth: String!, _ checkCvn: Bool) -> PaymentMethodsData {
    let enabledMethods: YSArray<EnabledPaymentMethod> = YSArray<EnabledPaymentMethod>()
    enabledMethods.push(EnabledPaymentMethod("card"))
    if self.sbpSupport {
      enabledMethods.push(EnabledPaymentMethod("sbp_qr"))
    }
    return PaymentMethodsData(self.getUserCards(oAuth, checkCvn), enabledMethods)
  }

  @discardableResult
  open func supplyPaymentBySbp(_ oAuth: String!, _ purchaseToken: String) -> Result<String> {
    let order = undefinedToNull(self.orders.find({
      (value) in
      value.token == purchaseToken
    }))
    if order == nil {
      return resultError(YSError("payment_not_found"))
    }
    if oAuth == nil {
      return resultError(YSError("authorization_reject"))
    }
    order!.supplied = MockSuppliedMethod("sbp_qr")
    return resultValue("success")
  }

  @discardableResult
  open func supplyPaymentByStoredCard(_ oAuth: String!, _ purchaseToken: String, _ methodId: String, _ cvn: String!) -> Result<String> {
    let order = undefinedToNull(self.orders.find({
      (value) in
      value.token == purchaseToken
    }))
    if order == nil {
      return resultError(YSError("payment_not_found"))
    }
    if oAuth == nil {
      return resultError(YSError("authorization_reject"))
    }
    let card: MockCard! = self.findUserCardById(oAuth!, methodId)
    if card == nil {
      return resultError(YSError("technical_error"))
    }
    if order!.checkCvn && card!.cvn != cvn {
      return resultError(YSError("technical_error"))
    }
    order!.supplied = MockSuppliedMethod(methodId, self.ask3ds(order!))
    return resultValue("success")
  }

  @discardableResult
  open func supplyPaymentByNewCard(_ oAuth: String!, _ purchaseToken: String, _ cardNumber: String, _ expirationMonth: String, _ expirationYear: String, _ cvn: String, _ bindCard: Bool) -> Result<String> {
    let order = undefinedToNull(self.orders.find({
      (value) in
      value.token == purchaseToken
    }))
    if order == nil {
      return resultError(YSError("payment_not_found"))
    }
    let card = MockCard(cardNumber, expirationMonth, expirationYear, cvn, "card-x" + self.generateId())
    if bindCard {
      if oAuth == nil {
        return resultError(YSError("authorization_reject"))
      }
      let result = self.tryBindCard(card, oAuth!)
      if !result {
        return resultError(YSError("too_many_cards"))
      }
    }
    if !order!.finished {
      order!.supplied = MockSuppliedMethod(card.id, self.ask3ds(order!))
    }
    return resultValue("success")
  }

  @discardableResult
  open func checkPayment(_ purchaseToken: String) -> Result<CheckPaymentData> {
    let order = undefinedToNull(self.orders.find({
      (value) in
      value.token == purchaseToken
    }))
    if order == nil {
      return resultError(YSError("payment_not_found"))
    } else if order!.supplied != nil {
      if order!.supplied!.methodId == "sbp_qr" {
        return self.handleSbp(order!)
      }
      if order!.supplied!.verification3ds != Verification3dsState.not_required {
        return self.handle3ds(order!.supplied!.verification3ds, order!.supplied!.code3ds, order!)
      }
      order!.finished = true
      let special: String! = self.handleSpecialAmount(order!.amount)
      if special != nil {
        return resultError(YSError(special))
      }
      if order!.isBinding {
        let result = self.handleBindingV2Payment(purchaseToken)
        if !result {
          return resultError(YSError("too_many_cards"))
        }
      }
      return self.respondPaidOk(order!)
    } else {
      return resultError(YSError("unknown_error"))
    }
  }

  @discardableResult
  private func handleSbp(_ order: MockOrder) -> Result<CheckPaymentData> {
    if !order.supplied!.sbpConfirmed {
      return resultValue(CheckPaymentData("wait_for_notification", "in progress", order.token, order.amount, order.isBinding, YSDate.now().toString(), nil, self.makeSbpFormUrl(order.token)))
    } else {
      order.finished = true
      return self.respondPaidOk(order)
    }
  }

  @discardableResult
  open func bindCard(_ oAuth: String, _ cardNumber: String, _ expirationMonth: String, _ expirationYear: String, _ cvn: String, _ service: String!) -> Result<String> {
    let card = MockCard(cardNumber, expirationMonth, expirationYear, cvn, "card-x" + self.generateId())
    let result = self.tryBindCard(card, oAuth)
    if !result {
      return resultError(YSError("too_many_cards"))
    }
    return resultValue("success")
  }

  @discardableResult
  open func unBindCard(_ oAuth: String, _ cardId: String) -> Result<String> {
    let userCards: YSArray<MockCard>! = undefinedToNull(self.cards.get(oAuth))
    if userCards == nil {
      return resultError(YSError("invalid_processing_request"))
    }
    let cards = userCards!
    var cardIndex: Int32 = 0
    var bound: MockCard! = nil
    for i in stride(from: 0, to: cards.length, by: 1) {
      if cards[i].id == cardId {
        cardIndex = i
        bound = cards[i]
      }
    }
    if bound == nil {
      return resultError(YSError("invalid_processing_request"))
    }
    cards.splice(cardIndex, 1)
    return resultValue("success")
  }

  @discardableResult
  open func has3dsChallenge(_ purchaseToken: String) -> Bool {
    let order: MockOrder! = self.find3dsChallenge(purchaseToken)
    if order == nil {
      return false
    }
    return order!.supplied!.verification3ds == Verification3dsState.`required`
  }

  @discardableResult
  open func provide3ds(_ purchaseToken: String, _ code: String) -> Bool {
    let order: MockOrder! = self.find3dsChallenge(purchaseToken)
    if order == nil {
      return false
    }
    if order!.supplied!.verification3ds != Verification3dsState.`required` {
      return false
    }
    order!.supplied!.verification3ds = Verification3dsState.provided
    order!.supplied!.code3ds = code
    return true
  }

  @discardableResult
  open func startV2Binding(_ oAuth: String, _ cardData: String, _ hashAlgo: String, _ service: String) -> Result<String> {
    let card = self.bindingCardExtractor.createCardFromData("card-x" + self.generateId(), cardData, hashAlgo)
    if card.isError() {
      return resultError(YSError("invalid_processing_request"))
    }
    let bind = MockBindingV2(oAuth, service, card.getValue(), self.generateId())
    self.bindings.push(bind)
    return resultValue(bind.card.id)
  }

  @discardableResult
  open func verifyBinding(_ oAuth: String, _ cardId: String, _ service: String) -> Result<String> {
    let existentCard: MockCard! = self.findUserCardById(oAuth, cardId)
    var binding: MockBindingV2! = undefinedToNull(self.bindings.find({
      (value) in
      value.card.id == cardId
    }))
    if binding != nil && binding!.service != service {
      return resultError(MobPaymentError("internal error", "internal_error"))
    }
    if existentCard != nil && binding == nil {
      binding = MockBindingV2(oAuth, service, existentCard!, "")
      self.bindings.push(binding)
    } else if existentCard != nil || binding == nil {
      return resultError(MobPaymentError("internal error", "internal_error"))
    }
    let order = self.createOrder(service, true)
    let purchase = self.setupOrder(order, "2.0", true)
    if purchase.isError() {
      return resultError(MobPaymentError("internal error", "internal_error"))
    }
    binding!.purchaseToken = purchase.getValue()
    var res: Result<String> = resultError(YSError("invalid_processing_request"))
    if existentCard != nil {
      res = self.supplyPaymentByStoredCard(oAuth, purchase.getValue(), existentCard!.id, nil)
    } else {
      res = self.supplyPaymentByNewCard(oAuth, purchase.getValue(), binding!.card.cardNumber, binding!.card.expirationMonth, binding!.card.expirationYear, binding!.card.cvn, false)
    }
    if res.isError() {
      return res
    }
    return resultValue(binding!.purchaseToken)
  }

  @discardableResult
  open func confirmSbpPaid(_ purchaseToken: String) -> Bool {
    let order = undefinedToNull(self.orders.find({
      (value) in
      value.token == purchaseToken
    }))
    if order == nil {
      return false
    }
    if order!.supplied == nil {
      return false
    }
    if order!.supplied!.methodId != "sbp_qr" {
      return false
    }
    order!.supplied!.sbpConfirmed = true
    return true
  }

  @discardableResult
  open func setStartMockBank(_ bank: String) -> Result<Void> {
    let index = self.mockBanks.lastIndexOf(stringToBankName(bank))
    if index > self.mockBanks.length - 1 || index < 0 {
      return resultError(MobPaymentError("internal error", "internal_error"))
    }
    self.mockBankNameStartIndex = index
    return resultValue(getVoid())
  }

  open func setFamilyInfoMode(_ mode: FamilyInfoMode) -> Void {
    self.familyInfoMode = mode
  }

  @discardableResult
  private func find3dsChallenge(_ purchaseToken: String) -> MockOrder! {
    let order = undefinedToNull(self.orders.find({
      (value) in
      value.token == purchaseToken
    }))
    if order == nil {
      return nil
    }
    if order!.supplied == nil {
      return nil
    }
    return order
  }

  @discardableResult
  private func getUserCards(_ oAuth: String!, _ checkCvn: Bool) -> YSArray<PaymentMethod> {
    if oAuth == nil {
      return YSArray<PaymentMethod>()
    }
    let userCards: YSArray<MockCard>! = undefinedToNull(self.cards.get(oAuth))
    if userCards == nil {
      return YSArray<PaymentMethod>()
    }
    var cardIndex: Int32 = 0
    var bankIndex = self.mockBankNameStartIndex
    return userCards!.map({
      (card) in
      let system = CardPaymentSystemChecker.instance.lookup(card.cardNumber).toString()
      let lastDigits = card.cardNumber.slice(-4)
      let masked = lastDigits.padStart(card.cardNumber.length, "*")
      let bankName = self.mockBanks[bankIndex]
      var familyInfo: FamilyInfo! = nil
      if cardIndex == 0 {
        familyInfo = self.getFamilyInfo()
      }
      bankIndex = (bankIndex + 1) % self.mockBanks.length
      cardIndex = cardIndex + 1
      return PaymentMethod(card.id, masked, system, checkCvn, bankName, familyInfo, nil)
    })
  }

  @discardableResult
  private func checkEmail(_ email: String) -> Bool {
    if email.length == 0 {
      return true
    }
    let str = email.split("")
    return str.includes(".") && str.length >= 5 && str.filter({
      (item) in
      item == "@"
    }).length == 1
  }

  @discardableResult
  private func generateId() -> String {
    return YSDate.now().toString()
  }

  @discardableResult
  private func ask3ds(_ order: MockOrder) -> Verification3dsState {
    if order.amount == "1093.00" || order.forced3ds {
      return Verification3dsState.`required`
    }
    return Verification3dsState.not_required
  }

  @discardableResult
  private func tryBindCard(_ card: MockCard, _ oAuth: String) -> Bool {
    let userCards: YSArray<MockCard>! = undefinedToNull(self.cards.get(oAuth))
    if userCards == nil {
      let added = YSArray<MockCard>()
      added.push(card)
      self.cards.set(oAuth, added)
    } else {
      let cards = userCards!
      if cards.length == 5 {
        return false
      }
      var exists = false
      cards.forEach({
        (value) in
        if value.cardNumber == card.cardNumber {
          exists = true
        }
      })
      if !exists {
        cards.push(card)
      }
    }
    return true
  }

  @discardableResult
  private func findUserCardById(_ oAuth: String, _ cardId: String) -> MockCard! {
    let userCards: YSArray<MockCard>! = undefinedToNull(self.cards.get(oAuth))
    if userCards != nil {
      return undefinedToNull(userCards!.find({
        (value) in
        value.id == cardId
      }))
    }
    return nil
  }

  @discardableResult
  private func respondPaidOk(_ order: MockOrder, _ redirect3dsUrl: String! = nil) -> Result<CheckPaymentData> {
    return resultValue(CheckPaymentData("success", "paid ok", order.token, order.amount, order.isBinding, YSDate.now().toString(), redirect3dsUrl, nil))
  }

  @discardableResult
  private func handleBindingV2Payment(_ purchaseToken: String) -> Bool {
    var bindIndex: Int32 = 0
    for i in stride(from: 0, to: self.bindings.length, by: 1) {
      if self.bindings[i].purchaseToken == purchaseToken {
        bindIndex = i
        break
      }
    }
    let result = self.tryBindCard(self.bindings[bindIndex].card, self.bindings[bindIndex].oAuth)
    self.bindings = self.bindings.slice(bindIndex, 1)
    return result
  }

  @discardableResult
  private func handle3ds(_ state: Verification3dsState, _ code: String, _ order: MockOrder) -> Result<CheckPaymentData> {
    if state == Verification3dsState.`required` {
      return resultValue(CheckPaymentData("wait_for_notification", "in progress", order.token, order.amount, order.isBinding, YSDate.now().toString(), self.make3dsUrl(order.token), nil))
    }
    order.finished = true
    switch code {
      case "200":
        if order.isBinding {
          let result = self.handleBindingV2Payment(order.token)
          if !result {
            return resultError(YSError("too_many_cards"))
          }
        }
        return self.respondPaidOk(order, self.make3dsUrl(order.token))
      case "400":
        return resultError(YSError("technical_error"))
      case "401":
        return resultError(YSError("fail_3ds"))
      case "300":
        return resultError(YSError("not_enough_funds"))
      case "301":
        return resultError(YSError("limit_exceeded"))
      case "302":
        return resultError(YSError("payment_timeout"))
      case "303":
        return resultError(YSError("technical_error"))
      case "304":
        return resultError(YSError("limit_exceeded"))
      case "305":
        return resultError(YSError("restricted_card"))
      case "306":
        return resultError(YSError("transaction_not_permitted"))
      default:
        return resultError(YSError("unknown_error"))
    }
  }

  @discardableResult
  private func make3dsUrl(_ purchaseToken: String) -> String {
    return "http://127.0.0.1:8080/web/redirect_3ds?purchase_token=\(purchaseToken)"
  }

  @discardableResult
  private func makeSbpFormUrl(_ purchaseToken: String) -> String {
    return "https://qr.nspk.ru/invalid/pay_sbp?purchase_token=\(purchaseToken)"
  }

  @discardableResult
  private func handleSpecialAmount(_ amount: String) -> String! {
    switch amount {
      case "1099.00":
        return "not_enough_funds"
      case "1092.00":
        return "limit_exceeded"
      case "1097.00":
        return "restricted_card"
      case "1096.00":
        return "restricted_card"
      case "1094.00":
        return "transaction_not_permitted"
      case "1095.00":
        return "transaction_not_permitted"
      default:
        return nil
    }
  }

  @discardableResult
  private func getFamilyInfo() -> FamilyInfo! {
    let frame = FamilyInfoFrame.month.toString()
    switch self.familyInfoMode {
      case FamilyInfoMode.disabled:
        return nil
      case FamilyInfoMode.enabled_low_allowance:
        return FamilyInfo("1", "f1", 9999, 10000, "RUB", frame, false)
      case FamilyInfoMode.enabled_high_allowance:
        return FamilyInfo("1", "f1", 0, 10000, "RUB", frame, false)
      case FamilyInfoMode.enabled_unbound_limit:
        return FamilyInfo("1", "f1", 0, 100000000, "RUB", frame, true)
      default:
        return nil
    }
  }

}

