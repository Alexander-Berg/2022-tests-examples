// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM payment-user-service.ts >>>

package com.yandex.xplat.testopithecus.payment.sdk

import com.yandex.xplat.common.*
import com.yandex.xplat.eventus.common.*
import com.yandex.xplat.testopithecus.common.*
import com.yandex.xplat.payment.sdk.*

public open class PaymentUserService(private val userAccountsMap: UserServiceEnsemble, private val oauthService: OauthService, private val diehardBackendApi: DiehardBackendApi, private val network: Network, private val jsonSerializer: JSONSerializer, private val passportToken: String?) {
    open fun getAuthorizedUser(): OAuthUserAccount? {
        val min10 = int64(10 * 60 * 1000)
        val min2 = int64(2 * 60 * 1000)
        val type = AccountType2.YandexTest
        val lock = this.userAccountsMap.getAccountByType(type).tryAcquire(min10, min2)
        if (lock == null) {
            return null
        }
        val account = lock.lockedAccount()
        val token = this.oauthService.getToken(account, type)
        return OAuthUserAccount(account, token, type)
    }

    open fun bindCard(user: OAuthUserAccount, card: BoundCard, serviceToken: String): XPromise<Unit> {
        val request = BindNewCardRequest(user.oauthToken, serviceToken, card.cardNumber, card.expirationMonth, card.expirationYear, card.cvv, RegionIds.russia)
        return this.diehardBackendApi.bindNewCard(request).then( {
            _: BindNewCardResponse ->
            getVoid()
        })
    }

    open fun unbindCards(user: OAuthUserAccount, serviceToken: String): XPromise<Unit> {
        val request = RawPaymentMethodsRequest()
        return this.mobileBackendAPI(user, serviceToken).rawPaymentMethods(request).then( {
            response: RawPaymentMethodsResponse ->
            response.paymentMethods
        }).flatThen(__LBL__PaymentUserService_1@ {
            methods: YSArray<PaymentMethod> ->
            val promises: YSArray<() -> XPromise<Unit>> = mutableListOf()
            for (i in (0 until methods.size step 1)) {
                val request = UnbindCardRequest(user.oauthToken, methods[i].identifier)
                promises.add( {
                     ->
                    this.diehardBackendApi.unbindCard(request).then( {
                        _ ->
                        getVoid()
                    })
                })
            }
            return@__LBL__PaymentUserService_1 executeSequentially<Unit>(promises).then( {
                _ ->
                getVoid()
            })
        })
    }

    open fun getPaymentMethods(user: OAuthUserAccount, serviceToken: String): XPromise<AvailableMethods> {
        val request = RawPaymentMethodsRequest()
        return this.mobileBackendAPI(user, serviceToken).rawPaymentMethods(request).then( {
            response: RawPaymentMethodsResponse ->
            AvailableMethods(response.paymentMethods, response.applePaySupported, response.googlePaySupported, isPaymentMethodEnabled(response, "sbp_qr"), false)
        }).flatThen( {
            methods: AvailableMethods ->
            EmptyPaymentMethodsDecorator().decorate(methods)
        })
    }

    open fun cleanAccountAndBindCards(user: OAuthUserAccount, cards: YSArray<BoundCard>, serviceToken: String): XPromise<Unit> {
        return this.unbindCards(user, serviceToken).then( {
            _ ->
            getVoid()
        }).flatThen(__LBL__PaymentUserService_2@ {
            _ ->
            val promises: YSArray<() -> XPromise<Unit>> = mutableListOf()
            for (i in (0 until cards.size step 1)) {
                promises.add( {
                     ->
                    this.bindCard(user, cards[i], serviceToken)
                })
            }
            return@__LBL__PaymentUserService_2 executeSequentially(promises).then( {
                _ ->
                getVoid()
            })
        })
    }

    private fun mobileBackendAPI(user: OAuthUserAccount, serviceToken: String): MobileBackendApi {
        val interceptor = MobileBackendNetworkInterceptor.create(user.oauthToken, serviceToken, user.account.uid)
        val passportInterceptor = PassportHeaderInterceptor(this.passportToken)
        val authorizedNetwork = NetworkIntermediate(this.network, mutableListOf(interceptor, passportInterceptor))
        val errorProcessor = MobileBackendErrorProcessor()
        val networkService = NetworkService(authorizedNetwork, this.jsonSerializer, errorProcessor)
        return MobileBackendApi(networkService)
    }

    companion object {
        @JvmStatic
        open fun build(diehardNetwork: Network, mobileBackendNetwork: Network, syncNetwork: SyncNetwork, jsonSerializer: JSONSerializer, passportToken: String?, tusConsumer: String, forcedAuthHost: String? = null): PaymentUserService {
            val userService = UserService(syncNetwork, jsonSerializer, EmptyLogger())
            val userAccountsMap = UserServiceEnsemble(userService, mutableListOf(AccountType2.YandexTest), tusConsumer, mutableListOf())
            val oauthHostsConfig = if (forcedAuthHost != null) OauthHostsConfig(forcedAuthHost!!, forcedAuthHost!!, forcedAuthHost!!) else OauthHostsConfig()
            val oauthService = OauthService(PaymentSdkBackendConfig.applicationCredentials, syncNetwork, jsonSerializer, oauthHostsConfig)
            val diehardBackendApi = DiehardBackendApi.create(diehardNetwork, jsonSerializer, passportToken)
            return PaymentUserService(userAccountsMap, oauthService, diehardBackendApi, mobileBackendNetwork, jsonSerializer, passportToken)
        }

    }
}

public open class EmptyLogger: Logger {
    open override fun error(message: String): Unit {
    }

    open override fun info(message: String): Unit {
    }

    open override fun warn(message: String): Unit {
    }

}

