// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/feature/compose/compose-features.ts >>>

package com.yandex.xplat.testopithecus

import com.yandex.xplat.common.*
import com.yandex.xplat.eventus.common.*
import com.yandex.xplat.eventus.*
import com.yandex.xplat.mapi.*
import com.yandex.xplat.testopithecus.common.*

public open class WysiwygFeature private constructor(): Feature<WYSIWIG>("WYSIWYG", "Фича написания письма с форматированием (What You See Is What You Get).") {
    companion object {
        @JvmStatic var `get`: WysiwygFeature = WysiwygFeature()
    }
}

public interface WYSIWIG {
    fun setStrong(from: Int, to: Int): Unit
    fun setItalic(from: Int, to: Int): Unit
    fun clearFormatting(from: Int, to: Int): Unit
    fun appendText(index: Int, text: String): Unit
}

public interface DraftView {
    var to: YSSet<String>
    var subject: String?
    fun getWysiwyg(): WysiwygView
    fun tostring(): String
}

public interface WysiwygView {
    fun getText(): String
    fun getStyles(i: Int): YSSet<String>
    fun getRichBody(): String
}

public open class ComposeEmailProvider {
    val emailToReceiveFwdMessage: String = "yndx-test-acc-to-receive-email@yandex.ru"
    val emailWithLatinAndCyrillicLetters: String = "yandex-team-user@штаны.админкапдд.рф"
    val validEmails: YSArray<String> = mutableListOf("account name<test.email@yandex.ru>", "name <test@test.tt>", "\"test@test.com\"", "yndx-test-acc-to-receive-email@yandex.ru", "yandex-team-user@штаны.админкапдд.рф")
    val invalidEmails: YSArray<String> = mutableListOf("a", "3", "ц@", "@", "@.", "te st@te st.te st")
    open fun getRandomValidEmail(): String {
        return this.validEmails[getRandomInt32(this.validEmails.size)]
    }

    open fun getRandomInvalidEmail(): String {
        return this.invalidEmails[getRandomInt32(this.invalidEmails.size)]
    }

    companion object {
        @JvmStatic val instance: ComposeEmailProvider = ComposeEmailProvider()
    }
}

public enum class YabbleType(val value: String) {
    suggested("suggested"),
    manual("manual"),
    invalid("invalid"),
    new("new"),
    ;
    override fun toString(): String = value
}
public enum class ComposeRecipientFieldType(val value: String) {
    to("to"),
    cc("cc"),
    bcc("bcc"),
    ;
    override fun toString(): String = value
}
public enum class ComposeFieldType(val value: String) {
    to("to"),
    cc("cc"),
    bcc("bcc"),
    from("from"),
    subject("subject"),
    body("body"),
    ;
    override fun toString(): String = value
}
public open class Draft(var to: YSArray<Yabble> = mutableListOf(), var cc: YSArray<Yabble> = mutableListOf(), var bcc: YSArray<Yabble> = mutableListOf(), var from: String = "", var subject: String = "", var body: String = "", var attachments: YSArray<ComposeAttachment> = mutableListOf(), var timestamp: Long = currentTimeMs()) {
    open fun copy(): Draft {
        return Draft(copyArray(this.to), copyArray(this.cc), copyArray(this.bcc), this.from, this.subject, this.body, copyArray(this.attachments))
    }

    open fun toFullMessage(threadCounter: Int, read: Boolean): FullMessage {
        return FullMessage(Message(this.from, if (this.subject == "") "(No subject)" else this.subject.slice(0, 767), this.timestamp, this.getFirstline(this.body), threadCounter, read, false, this.attachments.map( {
            attachment ->
            attachment.toMessageAttach()
        }), this.to.concat(this.cc).map( {
            to ->
            to.emailOrName()
        })[0]), YSSet<String>(this.to.map( {
            to ->
            to.emailOrName()
        })), this.body)
    }

    private fun getFirstline(body: String): String {
        return stringReplaceAll(body.split("--")[0], "\n", "")
    }

    open fun tostring(): String {
        return "To: ${this.to}, Cc: ${this.cc}, Bcc: ${this.bcc}, From: ${this.from}, Subject: ${this.subject}, Body: ${this.body}, Attachments: ${this.attachments} "
    }

    companion object {
        @JvmStatic
        open fun matches(first: Draft, second: Draft): Boolean {
            return (this.isRecipientsEqual(first.to, second.to) && this.isRecipientsEqual(first.cc, second.cc) && this.isRecipientsEqual(first.bcc, second.bcc) && first.from == second.from && first.subject == second.subject && first.body == second.body && this.isAttachmentsEqual(first.attachments, second.attachments))
        }

        @JvmStatic
        private fun isAttachmentsEqual(attachments1: YSArray<ComposeAttachment>, attachments2: YSArray<ComposeAttachment>): Boolean {
            if (attachments1.size != attachments2.size) {
                Log.error("Different number of attachments. Attachments1: ${attachments1}, Attachments2: ${attachments2}")
                return false
            }
            for (i in (0 until attachments1.size step 1)) {
                if (!ComposeAttachment.matches(attachments1[i], attachments2[i])) {
                    Log.error("Different attachment: ${attachments1[i]}, ${attachments2[i]}")
                    return false
                }
            }
            return true
        }

        @JvmStatic
        private fun isRecipientsEqual(recipients1: YSArray<Yabble>, recipients2: YSArray<Yabble>): Boolean {
            if (recipients1.size != recipients2.size) {
                Log.error("Different number of yabbles. Recipients1: ${recipients1}, Recipients2: ${recipients2}")
                return false
            }
            for (i in (0 until recipients1.size step 1)) {
                if (!Yabble.matches(recipients1[i], recipients2[i])) {
                    Log.error("Different yabbles: ${recipients1[i]}, ${recipients2[i]}")
                    return false
                }
            }
            return true
        }

    }
}

public open class ComposeAttachment(var name: String, var size: String) {
    open fun toMessageAttach(): AttachmentView {
        return MessageAttach(this.name)
    }

    companion object {
        @JvmStatic
        open fun matches(first: ComposeAttachment, second: ComposeAttachment): Boolean {
            return first.name == second.name && first.size == second.size
        }

    }
}

public interface YabbleView {
    val email: String
    val name: String
    val type: YabbleType
    val isActive: Boolean
}

public open class Yabble(override var email: String, override var name: String = "", override var type: YabbleType = YabbleType.manual, override var isActive: Boolean = false): YabbleView {
    open fun emailOrName(): String {
        return if (this.type == YabbleType.suggested && !this.isActive && this.name.length > 0) this.name else this.email
    }

    open fun copy(): Yabble {
        return Yabble(this.email, this.name, this.type, this.isActive)
    }

    open fun tostring(): String {
        return "Email: ${this.email}, name: ${this.name}, type: ${this.type.toString()}, active: ${this.isActive}"
    }

    companion object {
        @JvmStatic
        open fun matches(first: Yabble, second: Yabble): Boolean {
            return (first.emailOrName() == second.emailOrName() && first.type == second.type && first.isActive == second.isActive)
        }

    }
}

public enum class ComposeType {
    clean,
    reply,
    replyAll,
    forward,
}
public interface Compose {
    fun openCompose(): Unit
    fun isComposeOpened(): Boolean
    fun closeCompose(saveDraft: Boolean): Unit
    fun sendMessage(): Unit
    fun isSendButtonEnabled(): Boolean
}

public open class ComposeFeature private constructor(): Feature<Compose>("Compose", "Открытие/закрытие компоуза, отправка письма") {
    companion object {
        @JvmStatic var `get`: ComposeFeature = ComposeFeature()
    }
}

public open class ComposeRecipientFieldsFeature private constructor(): Feature<ComposeRecipientFields>("ComposeRecipientFields", "Взаимодействие с полями получателей (Кому/Копия/Скрытая копия) и отправителя (От кого) в Компоузе") {
    companion object {
        @JvmStatic var `get`: ComposeRecipientFieldsFeature = ComposeRecipientFieldsFeature()
    }
}

public interface ComposeRecipientFields {
    fun tapOnRecipientField(`field`: ComposeRecipientFieldType): Unit
    fun pasteToRecipientField(`field`: ComposeRecipientFieldType, value: String, generateYabble: Boolean): Unit
    fun setRecipientField(`field`: ComposeRecipientFieldType, value: String, generateYabble: Boolean): Unit
    fun generateYabbleByTapOnEnter(): Unit
    fun getRecipientFieldValue(`field`: ComposeRecipientFieldType): YSArray<Yabble>
    fun getCompactRecipientFieldValue(): String
    fun tapOnRecipient(`field`: ComposeRecipientFieldType, index: Int): Unit
    fun deleteRecipientByTapOnCross(`field`: ComposeRecipientFieldType, index: Int): Unit
    fun deleteLastRecipientByTapOnBackspace(`field`: ComposeRecipientFieldType): Unit
    fun tapOnSenderField(): Unit
    fun getSenderFieldValue(): String
    fun expandExtendedRecipientForm(): Unit
    fun minimizeExtendedRecipientForm(): Unit
    fun isExtendedRecipientFormShown(): Boolean
}

public open class ComposeRecipientSuggestFeature private constructor(): Feature<ComposeRecipientSuggest>("ComposeRecipientSuggest", "Взаимодействие с саджестом получателей для полей Кому/Копия/Скрытая копия в Компоузе") {
    companion object {
        @JvmStatic var `get`: ComposeRecipientSuggestFeature = ComposeRecipientSuggestFeature()
    }
}

public interface ComposeRecipientSuggest {
    fun isRecipientSuggestShown(): Boolean
    fun getRecipientSuggest(): YSArray<Contact>
    fun tapOnRecipientSuggestByEmail(email: String): Unit
    fun tapOnRecipientSuggestByIndex(index: Int): Unit
}

public open class ComposeSenderSuggestFeature private constructor(): Feature<ComposeSenderSuggest>("ComposeSenderSuggest", "Взаимодействие с саджестом адресов отправителя в Компоузе") {
    companion object {
        @JvmStatic var `get`: ComposeSenderSuggestFeature = ComposeSenderSuggestFeature()
    }
}

public interface ComposeSenderSuggest {
    fun isSenderSuggestShown(): Boolean
    fun getSenderSuggest(): YSArray<String>
    fun tapOnSenderSuggestByEmail(email: String): Unit
    fun tapOnSenderSuggestByIndex(index: Int): Unit
}

public open class ComposeSubjectFeature private constructor(): Feature<ComposeSubject>("ComposeSubject", "Взаимодействие с полем Тема в Компоузе") {
    companion object {
        @JvmStatic var `get`: ComposeSubjectFeature = ComposeSubjectFeature()
    }
}

public interface ComposeSubject {
    fun getSubject(): String
    fun setSubject(subject: String): Unit
    fun tapOnSubjectField(): Unit
}

public open class ComposeBodyFeature private constructor(): Feature<ComposeBody>("ComposeBody", "Взаимодействие с полем Тело в Компоузе") {
    companion object {
        @JvmStatic var `get`: ComposeBodyFeature = ComposeBodyFeature()
    }
}

public interface ComposeBody {
    fun getBody(): String
    fun setBody(body: String): Unit
    fun pasteBody(body: String): Unit
    fun clearBody(): Unit
    fun tapOnBodyField(): Unit
}

