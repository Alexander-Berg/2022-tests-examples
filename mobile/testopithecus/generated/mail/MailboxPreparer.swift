// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/mailbox-preparer.ts >>>

import Foundation

open class FolderSpec {
  public var name: String
  public var messages: YSArray<MessageSpec>
  public init(_ name: String, _ messages: YSArray<MessageSpec>) {
    self.name = name
    self.messages = messages
  }

}

open class UserSpec {
  public var email: String
  public var name: String
  public init(_ email: String, _ name: String) {
    self.email = email
    self.name = name
  }

}

open class AttachmentSpec {
  public var title: String
  public var contentType: String
  public var contentBase64: String
  public init(_ title: String, _ contentType: String, _ contentBase64: String) {
    self.title = title
    self.contentType = contentType
    self.contentBase64 = contentBase64
  }

  @discardableResult
  open class func withName(_ title: String) -> AttachmentSpec {
    return AttachmentSpec(title, "application/octet-stream", "ZXhhbXBsZQ==")
  }

}

open class MessageSpec {
  public var sender: UserSpec
  public var subject: String
  public var textBody: String
  public var timestamp: YSDate
  public var toReceivers: YSArray<UserSpec>
  public var labels: YSArray<LabelData>
  public var systemLabels: YSArray<LabelType>
  public var attachments: YSArray<AttachmentSpec>
  public init(_ builder: MessageSpecBuilder) {
    self.sender = requireNonNull(builder.sender, "Sender required!")
    self.subject = requireNonNull(builder.subject, "Subject required!")
    self.textBody = requireNonNull(builder.textBody, "Body text required!")
    self.timestamp = requireNonNull(builder.timestamp, "Timestamp required!")
    self.toReceivers = builder.toReceivers
    self.labels = builder.labels
    self.attachments = builder.attachments
    self.systemLabels = builder.systemLabels
  }

  @discardableResult
  open class func builder() -> MessageSpecBuilder {
    return MessageSpecBuilder()
  }

  @discardableResult
  open class func create(_ subject: String, _ timestamp: YSDate! = nil) -> MessageSpec {
    return self.builder().withSender(UserSpec("testbotauto@yandex.ru", "Other User")).withSubject(subject).withTextBody("first line").withTimestamp(timestamp != nil ? timestamp : YSDate("2019-07-20T17:03:06.000Z")).build()
  }

}

open class MessageSpecBuilder {
  public var sender: UserSpec! = nil
  public var subject: String! = nil
  public var textBody: String! = nil
  public var timestamp: YSDate! = nil
  public var toReceivers: YSArray<UserSpec> = YSArray()
  public var labels: YSArray<LabelData> = YSArray()
  public var systemLabels: YSArray<LabelType> = YSArray()
  public var attachments: YSArray<AttachmentSpec> = YSArray()
  @discardableResult
  open func withSender(_ sender: UserSpec) -> MessageSpecBuilder {
    self.sender = sender
    return self
  }

  @discardableResult
  open func withSubject(_ subject: String) -> MessageSpecBuilder {
    self.subject = subject
    return self
  }

  @discardableResult
  open func withTextBody(_ textBody: String) -> MessageSpecBuilder {
    self.textBody = textBody
    return self
  }

  @discardableResult
  open func withTimestamp(_ timestamp: YSDate) -> MessageSpecBuilder {
    self.timestamp = timestamp
    return self
  }

  @discardableResult
  open func addReceiver(_ receiver: UserSpec) -> MessageSpecBuilder {
    self.toReceivers.push(receiver)
    return self
  }

  @discardableResult
  open func addLabels(_ labels: YSArray<LabelData>) -> MessageSpecBuilder {
    labels.forEach({
      (label) in
      self.labels.push(label)
    })
    return self
  }

  @discardableResult
  open func withSystemLabel(_ labelType: LabelType) -> MessageSpecBuilder {
    self.systemLabels.push(labelType)
    return self
  }

  @discardableResult
  open func addAttachments(_ attachments: YSArray<AttachmentSpec>) -> MessageSpecBuilder {
    attachments.forEach({
      (attachment) in
      self.attachments.push(attachment)
    })
    return self
  }

  @discardableResult
  open func withDefaults() -> MessageSpecBuilder {
    self.sender = UserSpec("testbotauto@yandex.ru", "Other User")
    self.subject = "subj"
    self.textBody = "first line"
    self.timestamp = YSDate("2019-07-20T17:03:06.000Z")
    return self
  }

  @discardableResult
  open func build() -> MessageSpec {
    return MessageSpec(self)
  }

}

open class FilterRule {
  public var conditions: YSArray<FilterCondition>
  public var logic: FilterLogicType
  public var actions: YSArray<FilterAction>
  public var id: String!
  public var name: String
  public var attachment: FilterAttachmentType
  public var letter: FilterLetterType
  public var stop: Bool
  public var enabled: Bool
  public init(_ builder: FilterRuleBuilder) {
    self.conditions = builder.conditions
    self.logic = builder.logic
    self.actions = builder.actions
    self.id = builder.id
    self.name = builder.name
    self.attachment = builder.attachment
    self.letter = builder.letter
    self.stop = builder.stop
    self.enabled = builder.enabled
  }

  @discardableResult
  open class func builder() -> FilterRuleBuilder {
    return FilterRuleBuilder()
  }

}

open class FilterRuleBuilder {
  public var conditions: YSArray<FilterCondition> = YSArray()
  public var logic: FilterLogicType = FilterLogicType.and
  public var actions: YSArray<FilterAction> = YSArray()
  public var id: String! = nil
  public var name: String = ""
  public var attachment: FilterAttachmentType = FilterAttachmentType.all
  public var letter: FilterLetterType = FilterLetterType.nospam
  public var stop: Bool = false
  public var enabled: Bool = true
  @discardableResult
  open func setCondition(_ condition: FilterCondition) -> FilterRuleBuilder {
    self.conditions.push(condition)
    return self
  }

  @discardableResult
  open func setLogic(_ logicType: FilterLogicType) -> FilterRuleBuilder {
    self.logic = logicType
    return self
  }

  @discardableResult
  open func setAction(_ action: FilterAction) -> FilterRuleBuilder {
    self.actions.push(action)
    return self
  }

  @discardableResult
  open func setId(_ id: String) -> FilterRuleBuilder {
    self.id = id
    return self
  }

  @discardableResult
  open func setName(_ name: String) -> FilterRuleBuilder {
    self.name = name
    return self
  }

  @discardableResult
  open func setAttachmentType(_ attachmentType: FilterAttachmentType) -> FilterRuleBuilder {
    self.attachment = attachmentType
    return self
  }

  @discardableResult
  open func setLetter(_ letterType: FilterLetterType) -> FilterRuleBuilder {
    self.letter = letterType
    return self
  }

  @discardableResult
  open func setStop(_ stop: Bool) -> FilterRuleBuilder {
    self.stop = stop
    return self
  }

  @discardableResult
  open func setEnable(_ enable: Bool) -> FilterRuleBuilder {
    self.enabled = enable
    return self
  }

  @discardableResult
  open func build() -> FilterRule {
    return FilterRule(self)
  }

}

open class MailAccountSpec {
  public let login: String
  public let password: String
  public let host: String
  public init(_ login: String, _ password: String, _ host: String) {
    self.login = login
    self.password = password
    self.host = host
  }

  @discardableResult
  open class func fromUserAccount(_ account: UserAccount, _ host: String) -> MailAccountSpec {
    return MailAccountSpec(account.login, account.password, host)
  }

}

open class PreparingMailbox {
  public var mailAccount: MailAccountSpec
  public var folders: YSArray<FolderSpec> = YSArray()
  public var labelsWithoutMessage: YSArray<LabelData> = YSArray()
  public var zeroSuggests: YSArray<String> = YSArray()
  public var filters: YSArray<FilterRule> = YSArray()
  public var contacts: YSArray<Contact> = YSArray()
  public var isTabEnabled: Bool = false
  public init(_ builder: MailboxBuilder) {
    self.mailAccount = builder.mailAccount
    builder.folders.__forEach({
      (messages, name) in
      self.folders.push(FolderSpec(name, messages))
    })
    self.isTabEnabled = builder.isTabEnabled
    builder.labelsWithoutMessage.forEach({
      (label) in
      self.labelsWithoutMessage.push(label)
    })
    builder.zeroSuggests.forEach({
      (query) in
      self.zeroSuggests.push(query)
    })
    builder.contacts.forEach({
      (contact) in
      self.contacts.push(contact)
    })
    builder.filters.forEach({
      (filter) in
      self.filters.push(filter)
    })
  }

}

open class MailboxPreparerProvider: AccountDataPreparerProvider<MailboxBuilder> {
  public let platform: MBTPlatform
  public let jsonSerializer: JSONSerializer
  public let network: SyncNetwork
  public let logger: Logger
  public let sleep: SyncSleep
  public let imap: ImapProvider
  public init(_ platform: MBTPlatform, _ jsonSerializer: JSONSerializer, _ network: SyncNetwork, _ logger: Logger, _ sleep: SyncSleep, _ imap: ImapProvider) {
    self.platform = platform
    self.jsonSerializer = jsonSerializer
    self.network = network
    self.logger = logger
    self.sleep = sleep
    self.imap = imap
    super.init()
  }

  @discardableResult
  open override func provide(_ lockedAccount: UserAccount, _ type: AccountType2) -> MailboxBuilder {
    let mailAccount = MailAccountSpec.fromUserAccount(lockedAccount, self.getImapHost(type))
    return MailboxBuilder(mailAccount, self)
  }

  @discardableResult
  open override func provideModelDownloader(_ fulfilledPreparers: YSArray<MailboxBuilder>, _ accountsWithTokens: YSArray<OAuthUserAccount>) -> AppModelProvider {
    let clients = accountsWithTokens.map({
      (accWithToken) in
      MailboxClient(self.platform, accWithToken, self.network, self.jsonSerializer, self.logger)
    })
    return MailboxDownloader(clients, self.logger)
  }

  @discardableResult
  open func getOAuthAccount(_ account: UserAccount, _ type: AccountType2) throws -> OAuthUserAccount {
    let token: String! = (try self.createOauthService().getToken(account, type))
    return OAuthUserAccount(account, token, type)
  }

  @discardableResult
  private func createOauthService() -> OauthService {
    return OauthService(PublicBackendConfig.mailApplicationCredentials, self.network, self.jsonSerializer)
  }

  @discardableResult
  private func getImapHost(_ accountType: AccountType2) -> String {
    switch accountType {
      case AccountType2.Yandex:
        return "imap.yandex.ru"
      case AccountType2.YandexTeam:
        return "imap.yandex-team.ru"
      case AccountType2.Yahoo:
        return "imap.mail.yahoo.com"
      case AccountType2.Google:
        return "imap.google.com"
      case AccountType2.Mail:
        return "imap.mail.ru"
      case AccountType2.Rambler:
        return "imap.rambler.ru"
      case AccountType2.Hotmail:
        return "outlook.office365.com"
      case AccountType2.Outlook:
        return "outlook.office365.com"
      case AccountType2.Other:
        fallthrough
      default:
        return "imap.yandex.ru"
    }
    return "imap.yandex.ru"
  }

}

open class MailboxBuilder: AccountDataPreparer {
  public let folders: YSMap<FolderName, YSArray<MessageSpec>> = YSMap<FolderName, YSArray<MessageSpec>>()
  public let labelsWithoutMessage: YSArray<LabelData> = YSArray()
  private let timestampProvider: MessageTimeProvider = MessageTimeProvider()
  public let zeroSuggests: YSArray<String> = YSArray()
  public let contacts: YSArray<Contact> = YSArray()
  public let filters: YSArray<FilterRule> = YSArray()
  private var currentFolder: FolderName = DefaultFolderName.inbox
  public var isTabEnabled: Bool = false
  public var sendMessagesViaApi: Bool = false
  public let mailAccount: MailAccountSpec
  private let delegate: MailboxPreparerProvider
  public init(_ mailAccount: MailAccountSpec, _ delegate: MailboxPreparerProvider) {
    self.mailAccount = mailAccount
    self.delegate = delegate
  }

  @discardableResult
  open func nextMessage(_ subject: String) -> MailboxBuilder {
    let timestamp = self.timestampProvider.nextTime()
    self.addMessageToFolder(self.currentFolder, MessageSpec.create(subject, timestamp))
    return self
  }

  @discardableResult
  open func nextManyMessage(_ size: Int32) -> MailboxBuilder {
    for i in stride(from: 0, to: size, by: 1) {
      self.nextMessage("Message\(i)")
    }
    return self
  }

  @discardableResult
  open func nextCustomMessage(_ msg: MessageSpecBuilder) -> MailboxBuilder {
    let timestamp = self.timestampProvider.nextTime()
    self.addMessageToFolder(self.currentFolder, msg.withTimestamp(timestamp).build())
    return self
  }

  @discardableResult
  open func nextThread(_ subject: String, _ threadSize: Int32) -> MailboxBuilder {
    for `_` in stride(from: 0, to: threadSize, by: 1) {
      self.nextMessage(subject)
    }
    return self
  }

  @discardableResult
  open func switchFolder(_ folderName: FolderName, _ parentFolders: YSArray<FolderName> = YSArray()) -> MailboxBuilder {
    self.currentFolder = formatFolderName(folderName, parentFolders)
    return self
  }

  @discardableResult
  open func turnOnTab() -> MailboxBuilder {
    self.isTabEnabled = true
    self.currentFolder = FolderBackendName.inbox
    return self
  }

  @discardableResult
  open func sendMessageViaMobileApi() -> MailboxBuilder {
    self.sendMessagesViaApi = true
    return self
  }

  @discardableResult
  open func addMessageToFolder(_ folderName: FolderName, _ message: MessageSpec, _ parentFolders: YSArray<FolderName> = YSArray()) -> MailboxBuilder {
    self.createFolder(folderName, parentFolders)
    let folderMessage = self.folders.`get`(formatFolderName(folderName, parentFolders))!
    folderMessage.push(message)
    return self
  }

  @discardableResult
  open func createFolder(_ folderName: FolderName, _ parentFolders: YSArray<FolderName> = YSArray()) -> MailboxBuilder {
    let folder = formatFolderName(folderName, parentFolders)
    if !self.folders.has(folder) {
      self.folders.set(folder, YSArray())
    }
    return self
  }

  @discardableResult
  open func createLabel(_ label: LabelData) -> MailboxBuilder {
    if self.labelsWithoutMessage.filter({
      (labelData) in
      LabelData.matches(labelData, label)
    }).length == 0 {
      self.labelsWithoutMessage.push(label)
    }
    return self
  }

  @discardableResult
  open func createContact(_ contact: Contact) -> MailboxBuilder {
    self.contacts.push(contact)
    return self
  }

  @discardableResult
  open func createFilter(_ filter: FilterRule) -> MailboxBuilder {
    self.filters.push(filter)
    return self
  }

  @discardableResult
  open func saveQueryToZeroSuggest(_ query: String) -> MailboxBuilder {
    if !self.zeroSuggests.includes(query) {
      self.zeroSuggests.push(query)
    }
    return self
  }

  @discardableResult
  open func build() -> PreparingMailbox {
    return PreparingMailbox(self)
  }

  @discardableResult
  open func prepare(_ account: OAuthUserAccount) -> XPromise<Void> {
    do {
      (try WebApiRequest(account.type).enableImap(self.delegate.network, account.oauthToken))
    } catch {
      let e = error
      self.delegate.logger.error("Включение настройки IMAP завершилось с ошибкой \(e)")
    }
    let imap = self.delegate.imap.provide(self.mailAccount)
    let client = MailboxClient(self.delegate.platform, account, self.delegate.network, self.delegate.jsonSerializer, self.delegate.logger)
    var senderClient: MailboxClient! = nil
    var senderAccount: OAuthUserAccount! = nil
    if self.sendMessagesViaApi {
      do {
        senderAccount = (try self.delegate.getOAuthAccount(UserAccount("yndx-message-sender@yandex.ru", "qwerty123asdf"), AccountType2.Yandex))
      } catch {
        let e = error
        return reject(getYSError(e))
      }
      senderClient = MailboxClient(self.delegate.platform, senderAccount, self.delegate.network, self.delegate.jsonSerializer, self.delegate.logger)
    }
    let preparer = MailboxPreparer(imap, client, senderClient, self.delegate.sleep, self.delegate.logger)
    return preparer.prepare(self)
  }

}

open class MailboxPreparer {
  private var imap: Imap
  private var client: MailboxClient
  private var senderClient: MailboxClient!
  private var syncSleep: SyncSleep
  private var logger: Logger
  public init(_ imap: Imap, _ client: MailboxClient, _ senderClient: MailboxClient! = nil, _ syncSleep: SyncSleep, _ logger: Logger) {
    self.imap = imap
    self.client = client
    self.senderClient = senderClient
    self.syncSleep = syncSleep
    self.logger = logger
    client.logger.info("Используй меня полностью")
  }

  @discardableResult
  open func prepare(_ builder: MailboxBuilder) -> XPromise<Void> {
    let mailbox = builder.build()
    self.logger.info("Готовим ящик \(self.client.oauthAccount.account.login) / \(self.client.oauthAccount.account.password)")
    return self.connect().flatThen({
      (_) in
      self.clearMailbox(mailbox.mailAccount)
    }).flatThen({
      (_) in
      self.createMailbox(mailbox)
    }).flatThen({
      (_) in
      self.disconnect()
    }).then({
      (_) in
      self.setTabEnableState(mailbox.isTabEnabled)
    }).then({
      (_) in
      self.waitForSync(mailbox)
    }).then({
      (_) in
      self.adjustMailbox(mailbox)
    })
  }

  private func waitForSync(_ mailbox: PreparingMailbox) -> Void {
    let ttl = int64(5 * 60 * 1000)
    let deadline = currentTimeMs() + ttl
    while currentTimeMs() < deadline {
      if self.isInSync(mailbox) {
        return
      }
      self.syncSleep.sleepMs(5000)
    }
    fail("Не могу дождаться синхронизации ящика в течение \(ttl)мс")
  }

  @discardableResult
  private func isInSync(_ mailbox: PreparingMailbox) -> Bool {
    for folder in mailbox.folders {
      let fid = self.client.getFolderByName(self.getRelevantIfTab(folder.name), mailbox.isTabEnabled).fid
      let backendMessages = self.client.getMessagesInFolder(fid, folder.messages.length + 1, mailbox.isTabEnabled)
      let actualMessagesCount = backendMessages.length
      let expectedMessagesCount = folder.messages.length
      if actualMessagesCount != expectedMessagesCount {
        self.logger.info("Еще не засинкана папка \(folder.name), жду \(expectedMessagesCount) писем, а там пока \(actualMessagesCount)")
        return false
      }
    }
    let foldersCount = mailbox.folders.length
    self.logger.info("Проверил \(foldersCount) папок, вроде ящик засинкан")
    return true
  }

  @discardableResult
  private func clearMailbox(_ account: MailAccountSpec) -> XPromise<Void> {
    self.logger.info("Clearing mailbox for \(account.login)")
    return self.imap.fetchAllFolders().flatThen({
      (folders) in
      self.clearFolders(folders)
    }).then({
      (_) in
      self.deleteAllLabels()
    })
  }

  @discardableResult
  private func clearFolders(_ folders: YSArray<ImapFolderDisplay>) -> XPromise<Void> {
    folders.push(ImapFolderDisplay(DefaultFolderName.trash))
    folders.push(ImapFolderDisplay("Корзина"))
    var result = resolve(getVoid())
    for folder in folders {
      result = result.flatThen({
        (_) in
        return self.hasFolder(folder.name).flatThen({
          (has) in
          return has ? self.isDefaultFolder(folder.name) ? self.clearFolder(folder.name) : self.deleteFolder(folder.name) : resolve(getVoid())
        })
      })
    }
    return result
  }

  @discardableResult
  private func createMailbox(_ mailbox: PreparingMailbox) -> XPromise<Void> {
    self.logger.info("Creating mailbox for \(mailbox.mailAccount.login)")
    return self.senderClient != nil ? self.createMailboxViaApi(mailbox) : self.alll(mailbox.folders.map({
      (f) in
      self.populateFolder(f)
    }))
  }

  @discardableResult
  private func createMailboxViaApi(_ mailbox: PreparingMailbox) -> XPromise<Void> {
    let `self` = self
    let email = formatLogin(`self`.client.oauthAccount.account.login)
    mailbox.folders.filter({
      (folder) in
      folder.name == DefaultFolderName.inbox
    })[0].messages.forEach({
      (message) in
      `self`.senderClient!.sendMessage(email, message.subject, message.textBody)
    })
    return resolve(getVoid())
  }

  @discardableResult
  private func getMessagesMeta(_ mailbox: PreparingMailbox) -> YSArray<MessageMeta> {
    let messagesMeta: YSArray<MessageMeta> = YSArray()
    for folder in mailbox.folders {
      let fid = self.client.getFolderByName(folder.name, mailbox.isTabEnabled).fid
      self.client.getMessagesInFolder(fid, folder.messages.length + 1, mailbox.isTabEnabled).forEach({
        (m) in
        messagesMeta.push(m)
      })
    }
    return messagesMeta
  }

  @discardableResult
  private func getMidsForInboxTab(_ mailbox: PreparingMailbox, _ tabName: FolderName) -> YSArray<ID> {
    let messages = mailbox.folders.filter({
      (folder) in
      folder.name == tabName
    })[0].messages
    let mids: YSArray<ID> = YSArray()
    self.client.getMessagesInFolder(int64(-10), messages.length + 1, mailbox.isTabEnabled).forEach({
      (m) in
      mids.push(m.mid)
    })
    return mids
  }

  private func adjustMailbox(_ mailbox: PreparingMailbox) -> Void {
    self.logger.info("Adjusting mailbox for \(mailbox.mailAccount.login) with backend operations")
    self.populateLabels(mailbox)
    self.prepareZeroSuggest(mailbox)
    self.prepareContacts(mailbox)
    self.prepareFilters(mailbox)
    mailbox.folders.map({
      (folder) in
      self.moveMessageToTabIfNeeded(folder.name, mailbox)
    })
  }

  @discardableResult
  private func populateFolder(_ folder: FolderSpec) -> XPromise<Void> {
    let name = self.getInboxIfTab(folder.name)
    let createFolder: XPromise<Void> = self.isDefaultFolder(name) ? self.imap.openFolder(name).then({
      (_) in
      getVoid()
    }) : self.createFolder(name)
    return createFolder.flatThen({
      (_) in
      self.alll(folder.messages.map({
        (msg) in
        self.createMessage(folder.name, msg)
      }))
    })
  }

  private func populateLabels(_ mailbox: PreparingMailbox) -> Void {
    let labelsToMsgTimestamps: YSMap<LabelName, YSArray<Int64>> = YSMap<LabelName, YSArray<Int64>>()
    let labelToColor: YSMap<LabelName, String> = YSMap<LabelName, String>()
    mailbox.folders.forEach({
      (folder) in
      folder.messages.forEach({
        (msg) in
        msg.labels.forEach({
          (label) in
          if labelsToMsgTimestamps.has(label.name) {
            labelsToMsgTimestamps.`get`(label.name)!.push(int64(msg.timestamp.getTime()))
          } else {
            labelsToMsgTimestamps.set(label.name, YSArray(int64(msg.timestamp.getTime())))
          }
          if !labelToColor.has(label.name) {
            labelToColor.set(label.name, label.color)
          }
        })
        msg.systemLabels.forEach({
          (labelType) in
          let lid = self.client.getLabelList().filter({
            (label) in
            label.type == labelType
          })[0].lid
          let messagesMeta: YSArray<ID> = self.getMessagesMeta(mailbox).filter({
            (message) in
            int64(msg.timestamp.getTime()) == message.timestamp
          }).map({
            (message) in
            message.mid
          })
          self.client.markMessagesWithLabel(messagesMeta, lid)
        })
      })
    })
    labelsToMsgTimestamps.__forEach({
      (timestamps, labelName) in
      mailbox.labelsWithoutMessage = mailbox.labelsWithoutMessage.filter({
        (label) in
        label.name != labelName
      })
      self.createLabel(LabelData(labelName, labelToColor.`get`(labelName)!))
      self.markMessagesWithLabel(LabelData(labelName), timestamps, mailbox)
    })
    mailbox.labelsWithoutMessage.forEach({
      (label) in
      self.createLabel(label)
    })
  }

  private func prepareZeroSuggest(_ mailbox: PreparingMailbox) -> Void {
    let currentZeroSuggest = self.getZeroSuggests()
    currentZeroSuggest.forEach({
      (query) in
      self.deleteQuery(query)
    })
    mailbox.zeroSuggests.forEach({
      (query) in
      self.saveQuery(query)
    })
  }

  private func prepareFilters(_ mailbox: PreparingMailbox) -> Void {
    let currentFilterIds = self.getFilters()
    currentFilterIds.forEach({
      (id) in
      self.deleteFilter(id)
    })
    mailbox.filters.forEach({
      (filterData) in
      filterData.actions.forEach({
        (action) in
        if action.key == FilterActionType.applyLabel && action.value != nil {
          let lid = self.client.getLabelByName(action.value!).lid
          action.value = lid
        }
        if action.key == FilterActionType.moveToFolder && action.value != nil {
          let fid = self.client.getFolderByName(action.value!).fid
          action.value = int64ToString(fid)
        }
      })
      let id = self.createFilter(filterData)
      if !filterData.enabled {
        self.disableFilter(id)
      }
    })
  }

  private func prepareContacts(_ mailbox: PreparingMailbox) -> Void {
    let contactsToDelete = self.getContactsIds()
    if contactsToDelete.length > 0 {
      self.deleteContacts(contactsToDelete)
    }
    if mailbox.contacts.length > 0 {
      self.createContacts(mailbox.contacts)
    }
  }

  @discardableResult
  private func connect() -> XPromise<Void> {
    let `self` = self
    `self`.client.setParameter("enable_imap", "true")
    `self`.client.setParameter("enable_imap_auth_plain", "on")
    `self`.client.setParameter("disable_imap_autoexpunge", "")
    return promise({
      (resolve, reject) in
      `self`.imap.connect({
        (error) in
        `self`.handle(resolve, reject, error, "Connected!")
      })
    })
  }

  @discardableResult
  private func disconnect() -> XPromise<Void> {
    let `self` = self
    return promise({
      (resolve, reject) in
      `self`.imap.disconnect({
        (error) in
        `self`.handle(resolve, reject, error, "Disconnected!")
      })
    })
  }

  @discardableResult
  private func clearFolder(_ folder: String) -> XPromise<Void> {
    self.logger.info("Clearing folder \(folder)")
    return self.imap.openFolder(folder).flatThen({
      (f) in
      self.deleteMessages(folder, f.messageCount)
    }).flatThen({
      (_) in
      self.expungeFolder(folder)
    })
  }

  @discardableResult
  private func hasFolder(_ folder: String) -> XPromise<Bool> {
    return self.imap.fetchAllFolders().then({
      (folders) in
      folders.map({
        (f) in
        f.name
      }).includes(folder)
    })
  }

  @discardableResult
  private func deleteMessages(_ folder: String, _ messageCount: Int32) -> XPromise<Void> {
    if messageCount == 0 {
      return resolve(getVoid())
    }
    let `self` = self
    return promise({
      (resolve, reject) in
      `self`.imap.deleteMessages(folder, messageCount, {
        (error) in
        `self`.handle(resolve, reject, error, "Deleted \(messageCount) messages from \(folder)")
      })
    })
  }

  @discardableResult
  private func createFolder(_ folder: String) -> XPromise<Void> {
    let `self` = self
    return promise({
      (resolve, reject) in
      `self`.imap.createFolder(folder, {
        (error) in
        `self`.handle(resolve, reject, error, "[CREATE] Created folder \(folder)")
      })
    })
  }

  private func setTabEnableState(_ enabled: Bool) -> Void {
    let `self` = self
    `self`.client.setParameter("show_folders_tabs", enabled ? "on" : "")
  }

  private func createLabel(_ label: LabelData) -> Void {
    let `self` = self
    `self`.client.createLabel(label)
  }

  private func deleteAllLabels() -> Void {
    let `self` = self
    `self`.client.getCustomUserLabelsList().forEach({
      (label) in
      `self`.client.deleteLabel(label.lid)
    })
  }

  private func markMessagesWithLabel(_ labelData: LabelData, _ timestamps: YSArray<Int64>, _ mailbox: PreparingMailbox) -> Void {
    let `self` = self
    let labelToMark: Label = requireNonNull(undefinedToNull(self.client.getLabelList().filter({
      (label) in
      label.name! == labelData.name
    }).pop()), "Не смог найти созданную метку с именем \(labelData.name)")
    let messagesMeta: YSArray<ID> = self.getMessagesMeta(mailbox).filter({
      (message) in
      timestamps.includes(message.timestamp)
    }).map({
      (message) in
      message.mid
    })
    `self`.client.markMessagesWithLabel(messagesMeta, labelToMark.lid)
  }

  private func moveMessageToTabIfNeeded(_ tabName: FolderName, _ mailbox: PreparingMailbox) -> Void {
    if !isTab(tabName) {
      return
    }
    let `self` = self
    let mids: YSArray<ID> = self.getMidsForInboxTab(mailbox, tabName)
    for mid in mids {
      `self`.client.moveMessageToFolder(mid, tabNameToFid(tabName))
    }
  }

  @discardableResult
  private func createMessage(_ folder: String, _ message: MessageSpec) -> XPromise<Void> {
    let folderName = self.getInboxIfTab(folder)
    let `self` = self
    return promise({
      (resolve, reject) in
      `self`.imap.appendMessage(folderName, message, {
        (error) in
        `self`.handle(resolve, reject, error, "[APPEND] Created message in folder \(folderName)")
      })
    })
  }

  @discardableResult
  private func deleteFolder(_ folder: String) -> XPromise<Void> {
    let `self` = self
    return promise({
      (resolve, reject) in
      `self`.imap.deleteFolder(folder, {
        (error) in
        `self`.handle(resolve, reject, error, "Deleted folder \(folder)")
      })
    })
  }

  @discardableResult
  private func expungeFolder(_ folder: String) -> XPromise<Void> {
    let `self` = self
    return promise({
      (resolve, reject) in
      `self`.imap.expungeFolder(folder, {
        (error) in
        `self`.handle(resolve, reject, error, "Expunged folder \(folder)")
      })
    })
  }

  @discardableResult
  private func getContactsIds() -> YSArray<String> {
    let `self` = self
    return `self`.client.getContacts(GetAbookContactsRequestData(30, 0, AbookContactsSortType.alpha, nil, nil)).contacts.map({
      (contact) in
      int32ToString(contact.id)
    })
  }

  private func deleteContacts(_ contactIds: YSArray<String>) -> Void {
    let `self` = self
    `self`.client.deleteContacts(contactIds)
  }

  private func createContacts(_ contacts: YSArray<Contact>) -> Void {
    let `self` = self
    `self`.client.createContacts(CreateAbookContactsRequestData(contacts.map({
      (contact) in
      CreateAbookContactData(AbookContactName(contact.name, nil, nil, nil, nil), YSArray(contact.email), nil, nil, nil, nil)
    })))
  }

  @discardableResult
  private func getZeroSuggests() -> YSArray<String> {
    let `self` = self
    return `self`.client.getZeroSuggest().map({
      (suggest) in
      suggest.show_text
    })
  }

  @discardableResult
  private func getFilters() -> YSArray<String> {
    let `self` = self
    return `self`.client.listFilter().rules.map({
      (rule) in
      rule.id
    })
  }

  private func deleteFilter(_ id: String) -> Void {
    let `self` = self
    `self`.client.deleteFilter(id)
  }

  @discardableResult
  private func createFilter(_ data: FilterRule) -> String {
    let `self` = self
    return `self`.client.createFilter(CreateUpdateFilterRuleRequestData(data.conditions, data.logic, data.actions, data.id, data.name, data.attachment, data.letter, data.stop)).id
  }

  private func disableFilter(_ id: String) -> Void {
    let `self` = self
    `self`.client.disableFilter(id)
  }

  private func saveQuery(_ query: String) -> Void {
    let `self` = self
    `self`.client.saveQueryToZeroSuggest(query)
  }

  private func deleteQuery(_ query: String) -> Void {
    let `self` = self
    `self`.client.deleteQueryFromZeroSuggest(query)
  }

  private func handle(_ resolve: @escaping (Void) -> Void, _ reject: @escaping (YSError) -> Void, _ error: YSError!, _ okMessage: String) -> Void {
    if error != nil {
      reject(error!)
    } else {
      self.logger.info(okMessage)
      resolve(getVoid())
    }
  }

  @discardableResult
  private func alll(_ promises: YSArray<XPromise<Void>>) -> XPromise<Void> {
    return all(promises).then({
      (_) in
      getVoid()
    })
  }

  @discardableResult
  private func getInboxIfTab(_ folderName: FolderName) -> FolderName {
    return isTab(folderName) ? DefaultFolderName.inbox : folderName
  }

  @discardableResult
  private func getRelevantIfTab(_ folderName: FolderName) -> FolderName {
    return isTab(folderName) ? FolderBackendName.inbox : folderName
  }

  @discardableResult
  private func isDefaultFolder(_ name: String) -> Bool {
    let defaultNames = YSArray("INBOX", "INBOX/Social", "INBOX/Newsletters", "Отправленные", "Черновики", "Спам", "Корзина", "Yandex", "Drafts|template", DefaultFolderName.inbox, DefaultFolderName.trash, DefaultFolderName.draft, DefaultFolderName.template, DefaultFolderName.outgoing, DefaultFolderName.sent, DefaultFolderName.spam, DefaultFolderName.archive)
    return defaultNames.includes(name)
  }

}

