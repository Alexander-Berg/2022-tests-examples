// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/components/folder-list-component.ts >>>

import Foundation

open class FolderListComponent: MBTComponent {
  public static let type: String = "FolderListComponent"
  @discardableResult
  open func getComponentType() -> String {
    return FolderListComponent.type
  }

  @discardableResult
  open func assertMatches(_ model: App, _ application: App) throws -> Void {
    let multiAccountModel: MultiAccount! = MultiAccountFeature.`get`.castIfSupported(model)
    let multiAccountApplication: MultiAccount! = MultiAccountFeature.`get`.castIfSupported(application)
    if multiAccountModel != nil && multiAccountApplication != nil {
      let currAppAcc = (try multiAccountApplication.getCurrentAccount())
      let currModelAcc = (try multiAccountModel.getCurrentAccount())
      (try assertStringEquals(currModelAcc, currAppAcc, "User Email is incorrect"))
      let accNumApp = (try multiAccountApplication.getNumberOfAccounts())
      let accNumModel = (try multiAccountModel.getNumberOfAccounts())
      (try assertInt32Equals(accNumModel, accNumApp, "The number of accounts is incorrect"))
    }
    let folderNavigatorModel: FolderNavigator! = FolderNavigatorFeature.`get`.castIfSupported(model)
    let folderNavigatorApplication: FolderNavigator! = FolderNavigatorFeature.`get`.castIfSupported(application)
    if folderNavigatorModel != nil && folderNavigatorApplication != nil {
      let folderListModel = self.formatFolderNameToCounterList((try folderNavigatorModel.getFoldersList()))
      let folderNamesModel = keysArray(folderListModel)
      let folderListApplication = self.formatFolderNameToCounterList((try folderNavigatorApplication.getFoldersList()), folderNamesModel)
      let folderNamesApplication = keysArray(folderListApplication)
      (try assertInt32Equals(folderNamesModel.length, folderNamesApplication.length, "Different number of folders"))
      for folderName in folderNamesApplication {
        (try assertTrue(folderNamesModel.includes(folderName), "There is no folder \(folderName) in model"))
      }
      for folderName in folderNamesApplication {
        (try assertInt32Equals(folderListModel.`get`(folderName)!, folderListApplication.`get`(folderName)!, "Folder \(folderName) has incorrect unread counter"))
      }
      let modelCurrentContainer: String! = (try folderNavigatorModel.getCurrentContainer())
      let appCurrentContainer: String! = (try folderNavigatorApplication.getCurrentContainer())
      (try assertTrue(modelCurrentContainer == appCurrentContainer, "Different current folder. Expected: \(modelCurrentContainer). Actual: \(appCurrentContainer)"))
    }
    let labelNavigatorModel: LabelNavigator! = LabelNavigatorFeature.`get`.castIfSupported(model)
    let labelNavigatorApplication: LabelNavigator! = LabelNavigatorFeature.`get`.castIfSupported(application)
    if labelNavigatorModel != nil && labelNavigatorApplication != nil {
      let labelListModel = (try labelNavigatorModel.getLabelList())
      let labelListApplication = (try labelNavigatorApplication.getLabelList())
      (try assertInt32Equals(labelListModel.length, labelListApplication.length, "Different number of labels"))
      for label in labelListApplication {
        let labelName = requireNonNull(self.getNotTrimmedContainerNameIfNeeded(label, labelListModel), "There is no label started with \(label)")
        (try assertTrue(labelListModel.includes(labelName), "There is no label \(label)"))
      }
    }
    let clearFolderModel: ClearFolderInFolderList! = ClearFolderInFolderListFeature.`get`.castIfSupported(model)
    let clearFolderApp: ClearFolderInFolderList! = ClearFolderInFolderListFeature.`get`.castIfSupported(application)
    if clearFolderModel != nil && clearFolderApp != nil {
      (try assertBooleanEquals((try clearFolderModel.doesClearTrashButtonExist()), (try clearFolderApp.doesClearTrashButtonExist()), "Different clear trash button existence state"))
      (try assertBooleanEquals((try clearFolderModel.doesClearSpamButtonExist()), (try clearFolderApp.doesClearSpamButtonExist()), "Different clear spam button existence state"))
    }
    (try TabBarComponent().assertMatches(model, application))
  }

  @discardableResult
  private func getFolderNameFromFullFolderName(_ fullFolderName: FolderName) -> FolderName {
    return fullFolderName.split("|").reverse()[0]
  }

  @discardableResult
  private func formatFolderNameToCounterList(_ folderList: YSMap<FolderName, Int32>, _ notTrimmedFolderNames: YSArray<FolderName>! = nil) -> YSMap<FolderName, Int32> {
    let result: YSMap<FolderName, Int32> = YSMap()
    for fullFolderName in folderList.keys() {
      let folderName = self.getFolderNameFromFullFolderName(fullFolderName)
      let formattedFolderName = notTrimmedFolderNames == nil ? folderName : requireNonNull(self.getNotTrimmedContainerNameIfNeeded(folderName, notTrimmedFolderNames), "There is no folder started with \(folderName)")
      result.set(formattedFolderName, folderList.`get`(fullFolderName)!)
    }
    return result
  }

  @discardableResult
  private func getNotTrimmedContainerNameIfNeeded(_ containerName: String, _ notTrimmedContainerNames: YSArray<String>) -> String! {
    if !containerName.includes("...") {
      return containerName
    }
    let containerNameWithoutDots = containerName.substring(0, containerName.length - 4)
    for notTrimmedContainerName in notTrimmedContainerNames {
      if notTrimmedContainerName.includes(containerNameWithoutDots) {
        return notTrimmedContainerName
      }
    }
    return nil
  }

  @discardableResult
  open func tostring() -> String {
    return self.getComponentType()
  }

}

open class FolderListActions: MBTComponentActions {
  @discardableResult
  open func getActions(_ _model: App) -> YSArray<MBTAction> {
    let actions: YSArray<MBTAction> = YSArray()
    return actions
  }

}

