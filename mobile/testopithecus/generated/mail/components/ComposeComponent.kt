// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/components/compose-component.ts >>>

package com.yandex.xplat.testopithecus

import com.yandex.xplat.common.*
import com.yandex.xplat.eventus.common.*
import com.yandex.xplat.eventus.*
import com.yandex.xplat.mapi.*
import com.yandex.xplat.testopithecus.common.*

public open class ComposeComponent: MBTComponent {
    open override fun assertMatches(model: App, application: App): Unit {
        val composeRecipientFieldsModel = ComposeRecipientFieldsFeature.`get`.castIfSupported(model)
        val composeRecipientFieldsApp = ComposeRecipientFieldsFeature.`get`.castIfSupported(application)
        if (composeRecipientFieldsModel != null && composeRecipientFieldsApp != null) {
            val isCcBccFromFieldsShownModel = composeRecipientFieldsModel.isExtendedRecipientFormShown()
            val isCcBccFromFieldsShownApp = composeRecipientFieldsApp.isExtendedRecipientFormShown()
            assertBooleanEquals(isCcBccFromFieldsShownModel, isCcBccFromFieldsShownApp, "Cc/Bcc/From fields showing status is incorrect")
            if (isCcBccFromFieldsShownModel) {
                for (`field` in mutableListOf(ComposeRecipientFieldType.to, ComposeRecipientFieldType.cc, ComposeRecipientFieldType.bcc)) {
                    val fieldValueModel = composeRecipientFieldsModel.getRecipientFieldValue(`field`)
                    val fieldValueApp = composeRecipientFieldsApp.getRecipientFieldValue(`field`)
                    assertInt32Equals(fieldValueModel.size, fieldValueApp.size, "Different number of yabbles in ${`field`} field")
                    for (i in (0 until fieldValueModel.size step 1)) {
                        val fieldModel = fieldValueModel[i]
                        val fieldApp = fieldValueModel[i]
                        assertTrue(Yabble.matches(fieldModel, fieldApp), "Different yabble in field ${ComposeRecipientFieldType.to.toString()} at index ${i}. Model: ${fieldModel.tostring()}, app: ${fieldApp.tostring()}")
                    }
                }
                val fromFieldValueModel = composeRecipientFieldsModel.getSenderFieldValue()
                val fromFieldValueApp = composeRecipientFieldsApp.getSenderFieldValue()
                assertStringEquals(fromFieldValueModel, fromFieldValueApp, "Incorrect From field value")
            } else {
                val compactRecipientsFieldValueModel = composeRecipientFieldsModel.getCompactRecipientFieldValue()
                val compactRecipientsFieldValueApp = composeRecipientFieldsApp.getCompactRecipientFieldValue()
                assertStringEquals(compactRecipientsFieldValueModel, compactRecipientsFieldValueApp, "Incorrect compact recipients field value")
            }
        }
        val toCcBccSuggestModel = ComposeRecipientSuggestFeature.`get`.castIfSupported(model)
        val toCcBccSuggestApp = ComposeRecipientSuggestFeature.`get`.castIfSupported(application)
        if (toCcBccSuggestModel != null && toCcBccSuggestApp != null) {
            val isToCcBccSuggestShownModel = toCcBccSuggestModel.isRecipientSuggestShown()
            val isToCcBccSuggestShownApp = toCcBccSuggestApp.isRecipientSuggestShown()
            assertBooleanEquals(isToCcBccSuggestShownModel, isToCcBccSuggestShownApp, "To/cc/bcc suggest showing state is incorrect")
            if (isToCcBccSuggestShownModel) {
                val toCcBccSuggestsModel = toCcBccSuggestModel.getRecipientSuggest()
                val toCcBccSuggestsApp = toCcBccSuggestApp.getRecipientSuggest()
                assertInt32Equals(toCcBccSuggestsModel.size, toCcBccSuggestsApp.size, "Incorrect number of to/cc/bcc suggests")
                for (i in (0 until toCcBccSuggestsModel.size step 1)) {
                    val suggestModel = toCcBccSuggestsModel[i]
                    val suggestApp = toCcBccSuggestsApp[i]
                    assertTrue(Contact.matches(suggestModel, suggestApp), "Different From suggest at ${i} index. Model: ${suggestModel.tostring()}, app: ${suggestApp.tostring()}")
                }
            }
        }
        val fromSuggestModel = ComposeSenderSuggestFeature.`get`.castIfSupported(model)
        val fromSuggestApp = ComposeSenderSuggestFeature.`get`.castIfSupported(application)
        if (fromSuggestModel != null && fromSuggestApp != null) {
            val isFromSuggestShownModel = fromSuggestModel.isSenderSuggestShown()
            val isFromSuggestShownApp = fromSuggestApp.isSenderSuggestShown()
            assertBooleanEquals(isFromSuggestShownModel, isFromSuggestShownApp, "From suggest showing state is incorrect")
            if (isFromSuggestShownModel) {
                val fromSuggestsModel = fromSuggestModel.getSenderSuggest()
                val fromSuggestsApp = fromSuggestApp.getSenderSuggest()
                assertInt32Equals(fromSuggestsModel.size, fromSuggestsApp.size, "Incorrect number of From suggests")
                for (fromSuggestModel in fromSuggestsModel) {
                    assertTrue(fromSuggestsApp.contains(fromSuggestModel), "There is no ${fromSuggestModel} suggest in app")
                }
            }
        }
        val subjectModel = ComposeSubjectFeature.`get`.castIfSupported(model)
        val subjectApp = ComposeSubjectFeature.`get`.castIfSupported(application)
        if (subjectModel != null && subjectApp != null) {
            val subjModel = subjectModel.getSubject()
            val subjApp = subjectApp.getSubject()
            assertStringEquals(subjModel, subjApp, "Incorrect subject")
        }
        val bodyModel = ComposeBodyFeature.`get`.castIfSupported(model)
        val bodyApp = ComposeBodyFeature.`get`.castIfSupported(application)
        if (bodyModel != null && bodyApp != null) {
            val bModel = bodyModel.getBody()
            val bApp = bodyApp.getBody()
            assertStringEquals(bModel, bApp, "Incorrect body")
        }
        TabBarComponent().assertMatches(model, application)
    }

    open override fun tostring(): String {
        return this.getComponentType()
    }

    open override fun getComponentType(): MBTComponentType {
        return ComposeComponent.type
    }

    companion object {
        @JvmStatic val type: MBTComponentType = "ComposeComponent"
    }
}

