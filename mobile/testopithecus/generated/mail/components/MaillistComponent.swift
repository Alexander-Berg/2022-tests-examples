// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/components/maillist-component.ts >>>

import Foundation

open class MaillistComponent: MBTComponent {
  public static let type: MBTComponentType = "MaillistComponent"
  public init() {
  }

  @discardableResult
  open func assertMatches(_ model: App, _ application: App) throws -> Void {
    Log.info("Model and application comparison started")
    let undoModel: Undo! = UndoFeature.`get`.castIfSupported(model)
    let undoApplication: Undo! = UndoFeature.`get`.castIfSupported(application)
    if undoModel != nil && undoApplication != nil {
      let isUndoArchiveToastShownApplication = (try undoApplication.isUndoArchiveToastShown()) == UndoState.shown
      if isUndoArchiveToastShownApplication {
        (try assertBooleanEquals((try undoModel.isUndoArchiveToastShown()) != UndoState.notShown, isUndoArchiveToastShownApplication, "Undo archive toast state is unexpected"))
      } else {
        (try assertBooleanEquals((try undoModel.isUndoArchiveToastShown()) == UndoState.shown, isUndoArchiveToastShownApplication, "Undo archive toast state is unexpected"))
      }
      let isUndoDeleteToastShownApplication = (try undoApplication.isUndoDeleteToastShown()) == UndoState.shown
      if isUndoDeleteToastShownApplication {
        (try assertBooleanEquals((try undoModel.isUndoDeleteToastShown()) != UndoState.notShown, isUndoDeleteToastShownApplication, "Undo delete toast state is unexpected"))
      } else {
        (try assertBooleanEquals((try undoModel.isUndoDeleteToastShown()) == UndoState.shown, isUndoDeleteToastShownApplication, "Undo delete toast state is unexpected"))
      }
      let isUndoSpamToastShownApplication = (try undoApplication.isUndoSpamToastShown()) == UndoState.shown
      if isUndoSpamToastShownApplication {
        (try assertBooleanEquals((try undoModel.isUndoSpamToastShown()) != UndoState.notShown, isUndoSpamToastShownApplication, "Undo spam toast state is unexpected"))
      } else {
        (try assertBooleanEquals((try undoModel.isUndoSpamToastShown()) == UndoState.shown, isUndoSpamToastShownApplication, "Undo spam toast state is unexpected"))
      }
    }
    let messageListModel: MessageListDisplay! = MessageListDisplayFeature.`get`.castIfSupported(model)
    let messageListApplication: MessageListDisplay! = MessageListDisplayFeature.`get`.castIfSupported(application)
    if messageListModel != nil && messageListApplication != nil {
      var comparedMessages = 0
      let actualMessages = (try messageListApplication.getMessageList(10))
      let expectedMessages = (try messageListModel.getMessageList(10))
      let isCompactModeModel = (try GeneralSettingsFeature.`get`.forceCast(model).isCompactModeEnabled())
      for i in stride(from: 0, to: minInt32(maxInt32(actualMessages.length, 1), expectedMessages.length), by: 1) {
        (try assertTrue(i < actualMessages.length, "There is expected to be message at position \(i) but there was not"))
        let actual = actualMessages[i]
        let expected = expectedMessages[i]
        Log.info("â„–\(i): expected=\(expected.tostring()) actual=\(actual.tostring())")
        (try assertTrue(Message.matches(expected, actual, isCompactModeModel), "Messages are different at position \(i)"))
        comparedMessages += 1
      }
      Log.info("Message view is ok, compared: \(comparedMessages)")
      var comparedThreads = 0
      let expandableThreadsModel: ReadOnlyExpandableThreads! = ExpandableThreadsModelFeature.`get`.castIfSupported(model)
      let expandableThreadsApplication: ReadOnlyExpandableThreads! = ExpandableThreadsModelFeature.`get`.castIfSupported(application)
      if expandableThreadsModel != nil && expandableThreadsApplication != nil {
        let expectedMessagesCount = (try messageListModel.getMessageList(10)).length
        for threadOrder in stride(from: 0, to: expectedMessagesCount, by: 1) {
          if (try expandableThreadsModel.isExpanded(threadOrder)) {
            comparedThreads += 1
            let modelMessagesInThread = (try expandableThreadsModel.getMessagesInThread(threadOrder))
            let appMessagesInThread = (try expandableThreadsApplication.getMessagesInThread(threadOrder))
            for messageInThreadOrder in stride(from: 0, to: modelMessagesInThread.length, by: 1) {
              let expected = modelMessagesInThread[messageInThreadOrder]
              let actual = appMessagesInThread[messageInThreadOrder]
              (try assertBooleanEquals(expected.read, actual.read, "Messages are different at thread position \(threadOrder), message position \(messageInThreadOrder)"))
            }
          }
        }
      }
      let folderNavigatorModel: FolderNavigator! = FolderNavigatorFeature.`get`.castIfSupported(model)
      let folderNavigatorApplication: FolderNavigator! = FolderNavigatorFeature.`get`.castIfSupported(application)
      let tabsModel: Tabs! = TabsFeature.`get`.castIfSupported(model)
      let tabsApplication: Tabs! = TabsFeature.`get`.castIfSupported(application)
      if folderNavigatorModel != nil && folderNavigatorApplication != nil && tabsModel != nil && tabsApplication != nil {
        if (try folderNavigatorModel.isInTabsMode()) {
          let isDisplayNotificationMailingListsTabsModel = (try tabsModel.isDisplayNotificationTabs(DefaultFolderName.mailingLists))
          let isDisplayNotificationSocialNetworksTabsModel = (try tabsModel.isDisplayNotificationTabs(DefaultFolderName.socialNetworks))
          (try assertBooleanEquals(isDisplayNotificationMailingListsTabsModel, (try tabsApplication.isDisplayNotificationTabs(DefaultFolderName.mailingLists)), "Different status notification of \(DefaultFolderName.mailingLists) tab"))
          (try assertBooleanEquals(isDisplayNotificationSocialNetworksTabsModel, (try tabsApplication.isDisplayNotificationTabs(DefaultFolderName.socialNetworks)), "Different status notification of \(DefaultFolderName.socialNetworks) tab"))
          if isDisplayNotificationMailingListsTabsModel {
            (try assertInt32Equals((try tabsModel.getPositionTabsNotification(DefaultFolderName.mailingLists)), (try tabsApplication.getPositionTabsNotification(DefaultFolderName.mailingLists)), "Different position notification of \(DefaultFolderName.mailingLists) tab in Message list"))
            (try assertBooleanEquals((try tabsModel.isUnreadNotificationTabs(DefaultFolderName.mailingLists)), (try tabsApplication.isUnreadNotificationTabs(DefaultFolderName.mailingLists)), "Different notification's status read/unread of \(DefaultFolderName.mailingLists) tab in Message list"))
          }
          if isDisplayNotificationSocialNetworksTabsModel {
            (try assertInt32Equals((try tabsModel.getPositionTabsNotification(DefaultFolderName.socialNetworks)), (try tabsApplication.getPositionTabsNotification(DefaultFolderName.socialNetworks)), "Different position notification of \(DefaultFolderName.socialNetworks) tab in Message list"))
            (try assertBooleanEquals((try tabsModel.isUnreadNotificationTabs(DefaultFolderName.socialNetworks)), (try tabsApplication.isUnreadNotificationTabs(DefaultFolderName.socialNetworks)), "Different notification's status read/unread of \(DefaultFolderName.socialNetworks) tab in Message list"))
          }
        }
      }
      Log.info("Model and app are equal, compared \(comparedMessages) messages and \(comparedThreads) expanded threads")
    }
    let groupModeModel: GroupMode! = GroupModeFeature.`get`.castIfSupported(model)
    let groupModeApplication: GroupMode! = GroupModeFeature.`get`.castIfSupported(application)
    if groupModeModel != nil && groupModeApplication != nil {
      let modelGroupMode = (try groupModeModel.isInGroupMode())
      let applicationGroupMode = (try groupModeApplication.isInGroupMode())
      (try assertBooleanEquals(modelGroupMode, applicationGroupMode, "Group mode state is incorrect"))
      Log.info("Group mode state is correct, state: \(modelGroupMode)")
    }
    (try TabBarComponent().assertMatches(model, application))
  }

  @discardableResult
  open func getComponentType() -> String {
    return MaillistComponent.type
  }

  @discardableResult
  open func tostring() -> String {
    return "MailListComponent"
  }

}

open class AllMaillistActions: MBTComponentActions {
  @discardableResult
  open func getActions(_ model: App) -> YSArray<MBTAction> {
    let actions: YSArray<MBTAction> = YSArray()
    MessageListDisplayFeature.`get`.performIfSupported(model, {
      (mailboxModel) in
      let messages: YSArray<MessageView> = resolveThrow({
        () in
        (try mailboxModel.getMessageList(3))
      }
, YSArray())
      for i in stride(from: 0, to: messages.length, by: 1) {
        actions.push(MarkAsRead(i))
        actions.push(MarkAsUnread(i))
        actions.push(OpenMessageAction(i))
        actions.push(ExpandThreadAction(i))
        actions.push(CollapseThreadAction(i))
        actions.push(MarkAsReadExpandedAction(i, 0))
        actions.push(MarkAsUnreadExpandedAction(i, 0))
        actions.push(MarkAsImportant(i))
        actions.push(MarkAsUnimportant(i))
        actions.push(MoveToSpamAction(i))
        actions.push(GroupModeSelectAction(i))
        actions.push(ArchiveMessageAction(i))
        actions.push(DeleteMessageByShortSwipeAction(i))
        actions.push(ArchiveMessageByShortSwipeAction(i))
        actions.push(ShortSwipeContextMenuMarkAsReadAction(i))
        actions.push(ShortSwipeContextMenuMarkAsUnreadAction(i))
        actions.push(ShortSwipeContextMenuMarkAsImportantAction(i))
        actions.push(ShortSwipeContextMenuMarkAsUnimportantAction(i))
        actions.push(DeleteMessageAction(i))
      }
    })
    StoriesBlockFeature.`get`.performIfSupported(model, {
      (t: StoriesBlock) in
      actions.push(HideStoriesBlockAction())
      let six: Int32 = 6
      for i in stride(from: 0, to: six, by: 1) {
        actions.push(OpenStoryFromBlockAction(i))
      }
    })
    FolderNavigatorFeature.`get`.performIfSupported(model, {
      (_mailboxModel) in
      let folders = YSArray(DefaultFolderName.inbox, DefaultFolderName.sent, DefaultFolderName.trash, DefaultFolderName.spam)
      for folder in folders {
        actions.push(GoToFolderAction(folder))
      }
    })
    actions.push(ClearCacheAction())
    RotatableAction.addActions(actions)
    return actions
  }

}

