// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/actions/messages-list/context-menu-actions.ts >>>

import Foundation

open class BaseShortSwipeContextMenuAction: MBTAction {
  public var order: Int32
  private var type: MBTActionType
  public init(_ order: Int32, _ type: MBTActionType) {
    self.order = order
    self.type = type
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    let messageListModel = MessageListDisplayFeature.`get`.forceCast(model)
    let messages = (try messageListModel.getMessageList(10))
    let canPerform = (try self.canBePerformedImpl(messages[self.order]))
    return self.order < messages.length && canPerform
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    (try self.performImpl(ContextMenuFeature.`get`.forceCast(model)))
    (try self.performImpl(ContextMenuFeature.`get`.forceCast(application)))
    return history.currentComponent
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return self.type
  }

  @discardableResult
  open func tostring() -> String {
    return "\(self.type)(\(self.order))"
  }

  @discardableResult
  open func canBePerformedImpl(_ message: MessageView) throws -> Bool {
    fatalError("Must be overridden in subclasses")
  }

  @discardableResult
  open func performImpl(_ modelOrApplication: ContextMenu) throws -> Void {
    fatalError("Must be overridden in subclasses")
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    fatalError("Must be overridden in subclasses")
  }

}

open class BaseMailViewContextMenuAction: MBTAction {
  private var type: MBTActionType
  public init(_ type: MBTActionType) {
    self.type = type
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    let openedMessage = (try MessageViewerFeature.`get`.forceCast(model).getOpenedMessage()).head
    return (try self.canBePerformedImpl(openedMessage))
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    (try self.performImpl(ContextMenuFeature.`get`.forceCast(model)))
    (try self.performImpl(ContextMenuFeature.`get`.forceCast(application)))
    return history.currentComponent
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return self.type
  }

  @discardableResult
  open func tostring() -> String {
    return "\(self.type)"
  }

  @discardableResult
  open func canBePerformedImpl(_ message: MessageView) throws -> Bool {
    fatalError("Must be overridden in subclasses")
  }

  @discardableResult
  open func performImpl(_ modelOrApplication: ContextMenu) throws -> Void {
    fatalError("Must be overridden in subclasses")
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    fatalError("Must be overridden in subclasses")
  }

}

open class ShortSwipeOpenContextMenuAction: MBTAction {
  public static let type: MBTActionType = "ShortSwipeOpenContextMenuAction"
  private let order: Int32
  public init(_ order: Int32) {
    self.order = order
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    let isInGroupMode = (try GroupModeFeature.`get`.forceCast(model).isInGroupMode())
    let isOutgoingFolderOpened = (try ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer()).name == DefaultFolderName.outgoing
    let messages = (try MessageListDisplayFeature.`get`.forceCast(model).getMessageList(10))
    return !isInGroupMode && !isOutgoingFolderOpened && self.order < messages.length
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray()
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    (try ContextMenuFeature.`get`.forceCast(model).openFromShortSwipe(self.order))
    (try ContextMenuFeature.`get`.forceCast(application).openFromShortSwipe(self.order))
    return ContextMenuComponent()
  }

  @discardableResult
  open func tostring() -> String {
    return "\(ShortSwipeOpenContextMenuAction.type)(\(self.order))"
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return ShortSwipeOpenContextMenuAction.type
  }

}

open class ShortSwipeContextMenuDeleteAction: MBTAction {
  public static let type: MBTActionType = "ShortSwipeContextMenuDeleteAction"
  private let order: Int32
  public init(_ order: Int32) {
    self.order = order
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return true
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageListEvents.openMessageActions(self.order, fakeMid()), Eventus.messageListEvents.deleteMessage(self.order, fakeMid()))
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromShortSwipe(self.order))
    (try appContextMenu.openFromShortSwipe(self.order))
    (try modelContextMenu.deleteMessage())
    (try appContextMenu.deleteMessage())
    return MaillistComponent()
  }

  @discardableResult
  open func tostring() -> String {
    return "\(ShortSwipeContextMenuDeleteAction.type)(\(self.order))"
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return ShortSwipeContextMenuDeleteAction.type
  }

}

open class ShortSwipeContextMenuMarkAsSpamAction: MBTAction {
  public static let type: MBTActionType = "ShortSwipeContextMenuMarkAsSpamAction"
  private let order: Int32
  public init(_ order: Int32) {
    self.order = order
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return (try ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer()).name != DefaultFolderName.spam
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageListEvents.openMessageActions(self.order, fakeMid()), Eventus.messageListEvents.markMessageAsSpam(self.order, fakeMid()))
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromShortSwipe(self.order))
    (try appContextMenu.openFromShortSwipe(self.order))
    (try modelContextMenu.markAsSpam())
    (try appContextMenu.markAsSpam())
    return MaillistComponent()
  }

  @discardableResult
  open func tostring() -> String {
    return "\(ShortSwipeContextMenuMarkAsSpamAction.type)(\(self.order))"
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return ShortSwipeContextMenuMarkAsSpamAction.type
  }

}

open class ShortSwipeContextMenuMarkAsNotSpamAction: MBTAction {
  public static let type: MBTActionType = "ShortSwipeContextMenuMarkAsNotSpamAction"
  private let order: Int32
  public init(_ order: Int32) {
    self.order = order
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return (try ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer()).name == DefaultFolderName.spam
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageListEvents.openMessageActions(self.order, fakeMid()), Eventus.messageListEvents.markMessageAsNotSpam(self.order, fakeMid()))
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromShortSwipe(self.order))
    (try appContextMenu.openFromShortSwipe(self.order))
    (try modelContextMenu.markAsNotSpam())
    (try appContextMenu.markAsNotSpam())
    return MaillistComponent()
  }

  @discardableResult
  open func tostring() -> String {
    return "\(ShortSwipeContextMenuMarkAsNotSpamAction.type)(\(self.order))"
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return ShortSwipeContextMenuMarkAsNotSpamAction.type
  }

}

open class ShortSwipeContextMenuOpenApplyLabelsAction: MBTAction {
  public static let type: MBTActionType = "ShortSwipeContextMenuOpenApplyLabelsAction"
  private let order: Int32
  public init(_ order: Int32) {
    self.order = order
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return !YSArray(DefaultFolderName.spam, DefaultFolderName.trash).includes((try ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer()).name)
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageListEvents.openMessageActions(self.order, fakeMid()))
  }

  @discardableResult
  open func getActionType() -> String {
    return ShortSwipeContextMenuOpenApplyLabelsAction.type
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromShortSwipe(self.order))
    (try appContextMenu.openFromShortSwipe(self.order))
    (try modelContextMenu.openApplyLabelsScreen())
    (try appContextMenu.openApplyLabelsScreen())
    return ApplyLabelComponent()
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (MessageListDisplayFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func tostring() -> String {
    return "\(ShortSwipeContextMenuOpenApplyLabelsAction.type)(\(self.order))"
  }

}

open class ShortSwipeContextMenuApplyLabelsAction: MBTAction {
  public static let type: MBTActionType = "ShortSwipeContextMenuApplyLabelsAction"
  private let order: Int32
  private let labels: YSArray<LabelName>
  public init(_ order: Int32, _ labels: YSArray<LabelName>) {
    self.order = order
    self.labels = labels
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return !YSArray(DefaultFolderName.spam, DefaultFolderName.trash).includes((try ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer()).name)
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageListEvents.openMessageActions(self.order, fakeMid()), Eventus.messageListEvents.markMessageAs(self.order, fakeMid()))
  }

  @discardableResult
  open func getActionType() -> String {
    return ShortSwipeContextMenuApplyLabelsAction.type
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromShortSwipe(self.order))
    (try appContextMenu.openFromShortSwipe(self.order))
    (try modelContextMenu.openApplyLabelsScreen())
    (try appContextMenu.openApplyLabelsScreen())
    let modelApplyLabel = ApplyLabelFeature.`get`.forceCast(model)
    let appApplyLabel = ApplyLabelFeature.`get`.forceCast(application)
    (try modelApplyLabel.selectLabelsToAdd(self.labels))
    (try appApplyLabel.selectLabelsToAdd(self.labels))
    (try modelApplyLabel.tapOnDoneButton())
    (try appApplyLabel.tapOnDoneButton())
    return history.currentComponent
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures) && MessageViewerFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func tostring() -> String {
    return "\(ShortSwipeContextMenuApplyLabelsAction.type)(\(self.order))"
  }

}

open class ShortSwipeContextMenuRemoveLabelsAction: MBTAction {
  public static let type: MBTActionType = "ShortSwipeContextMenuRemoveLabelsAction"
  private let order: Int32
  private let labels: YSArray<LabelName>
  public init(_ order: Int32, _ labels: YSArray<LabelName>) {
    self.order = order
    self.labels = labels
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return !YSArray(DefaultFolderName.spam, DefaultFolderName.trash).includes((try ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer()).name)
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageListEvents.openMessageActions(self.order, fakeMid()), Eventus.messageListEvents.markMessageAs(self.order, fakeMid()))
  }

  @discardableResult
  open func getActionType() -> String {
    return ShortSwipeContextMenuRemoveLabelsAction.type
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromShortSwipe(self.order))
    (try appContextMenu.openFromShortSwipe(self.order))
    (try modelContextMenu.openApplyLabelsScreen())
    (try appContextMenu.openApplyLabelsScreen())
    let modelApplyLabel = ApplyLabelFeature.`get`.forceCast(model)
    let appApplyLabel = ApplyLabelFeature.`get`.forceCast(application)
    (try modelApplyLabel.deselectLabelsToRemove(self.labels))
    (try appApplyLabel.deselectLabelsToRemove(self.labels))
    (try modelApplyLabel.tapOnDoneButton())
    (try appApplyLabel.tapOnDoneButton())
    return history.currentComponent
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (MessageListDisplayFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func tostring() -> String {
    return "\(ShortSwipeContextMenuRemoveLabelsAction.type)"
  }

}

open class ShortSwipeContextMenuOpenReplyComposeAction: MBTAction {
  public static let type: MBTActionType = "ShortSwipeContextMenuOpenReplyComposeAction"
  private let order: Int32
  public init(_ order: Int32) {
    self.order = order
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return !YSArray(DefaultFolderName.draft, DefaultFolderName.template).includes((try ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer()).name)
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageListEvents.openMessageActions(self.order, fakeMid()), Eventus.messageListEvents.replyMessage(self.order, fakeMid()))
  }

  @discardableResult
  open func getActionType() -> String {
    return ShortSwipeContextMenuOpenReplyComposeAction.type
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromShortSwipe(self.order))
    (try appContextMenu.openFromShortSwipe(self.order))
    (try modelContextMenu.openReplyCompose())
    (try appContextMenu.openReplyCompose())
    return ComposeComponent()
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (MessageListDisplayFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures) && ComposeFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func tostring() -> String {
    return "\(ShortSwipeContextMenuOpenReplyComposeAction.type)"
  }

}

open class ShortSwipeContextMenuOpenForwardComposeAction: MBTAction {
  public static let type: MBTActionType = "ShortSwipeContextMenuOpenForwardComposeAction"
  private let order: Int32
  public init(_ order: Int32) {
    self.order = order
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return !YSArray(DefaultFolderName.draft, DefaultFolderName.template).includes((try ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer()).name)
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageListEvents.openMessageActions(self.order, fakeMid()), Eventus.messageListEvents.forwardMessage(self.order, fakeMid()))
  }

  @discardableResult
  open func getActionType() -> String {
    return ShortSwipeContextMenuOpenReplyComposeAction.type
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromShortSwipe(self.order))
    (try appContextMenu.openFromShortSwipe(self.order))
    (try modelContextMenu.openForwardCompose())
    (try appContextMenu.openForwardCompose())
    return ComposeComponent()
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (MessageListDisplayFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures) && ComposeFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func tostring() -> String {
    return "\(ShortSwipeContextMenuOpenForwardComposeAction.type)"
  }

}

open class ShortSwipeContextMenuMarkAsReadAction: BaseShortSwipeContextMenuAction {
  public static let type: MBTActionType = "ShortSwipeContextMenuMarkAsReadAction"
  public init(_ order: Int32) {
    super.init(order, ShortSwipeContextMenuMarkAsReadAction.type)
  }

  @discardableResult
  open override func performImpl(_ modelOrApplication: ContextMenu) throws -> Void {
    (try modelOrApplication.openFromShortSwipe(self.order))
    (try modelOrApplication.markAsRead())
  }

  @discardableResult
  open override func canBePerformedImpl(_ message: MessageView) throws -> Bool {
    return MarkAsRead.canMarkRead(message)
  }

  @discardableResult
  open override func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageListEvents.openMessageActions(self.order, fakeMid()), Eventus.messageListEvents.markMessageAsRead(self.order, fakeMid()))
  }

}

open class ShortSwipeContextMenuMarkAsUnreadAction: BaseShortSwipeContextMenuAction {
  public static let type: MBTActionType = "ShortSwipeContextMenuMarkAsUnreadAction"
  public init(_ order: Int32) {
    super.init(order, ShortSwipeContextMenuMarkAsUnreadAction.type)
  }

  @discardableResult
  open override func performImpl(_ modelOrApplication: ContextMenu) throws -> Void {
    (try modelOrApplication.openFromShortSwipe(self.order))
    (try modelOrApplication.markAsUnread())
  }

  @discardableResult
  open override func canBePerformedImpl(_ message: MessageView) throws -> Bool {
    return MarkAsUnread.canMarkUnread(message)
  }

  @discardableResult
  open override func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageListEvents.openMessageActions(self.order, fakeMid()), Eventus.messageListEvents.markMessageAsUnread(self.order, fakeMid()))
  }

}

open class ShortSwipeContextMenuMarkAsImportantAction: BaseShortSwipeContextMenuAction {
  public static let type: MBTActionType = "ShortSwipeContextMenuMarkAsImportantAction"
  public init(_ order: Int32) {
    super.init(order, ShortSwipeContextMenuMarkAsImportantAction.type)
  }

  @discardableResult
  open override func performImpl(_ modelOrApplication: ContextMenu) throws -> Void {
    (try modelOrApplication.openFromShortSwipe(self.order))
    (try modelOrApplication.markAsImportant())
  }

  @discardableResult
  open override func canBePerformedImpl(_ message: MessageView) throws -> Bool {
    return MarkAsImportant.canMarkImportant(message)
  }

  @discardableResult
  open override func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageListEvents.openMessageActions(self.order, fakeMid()), Eventus.messageListEvents.markMessageAsImportant(self.order, fakeMid()))
  }

}

open class ShortSwipeContextMenuMarkAsUnimportantAction: BaseShortSwipeContextMenuAction {
  public static let type: MBTActionType = "ShortSwipeContextMenuMarkAsUnimportantAction"
  public init(_ order: Int32) {
    super.init(order, ShortSwipeContextMenuMarkAsUnimportantAction.type)
  }

  @discardableResult
  open override func performImpl(_ modelOrApplication: ContextMenu) throws -> Void {
    (try modelOrApplication.openFromShortSwipe(self.order))
    (try modelOrApplication.markAsUnimportant())
  }

  @discardableResult
  open override func canBePerformedImpl(_ message: MessageView) throws -> Bool {
    return MarkAsUnimportant.canMarkUnimportant(message)
  }

  @discardableResult
  open override func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageListEvents.openMessageActions(1, fakeMid()), Eventus.messageListEvents.markMessageAsNotImportant(1, fakeMid()))
  }

}

open class ShortSwipeContextMenuOpenMoveToFolderAction: MBTAction {
  public static let type: MBTActionType = "ShortSwipeContextMenuOpenMoveToFolderAction"
  private let order: Int32
  public init(_ order: Int32) {
    self.order = order
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (FolderNavigatorFeature.`get`.included(modelFeatures) && MoveToFolderFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return true
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageListEvents.openMessageActions(self.order, fakeMid()))
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromShortSwipe(self.order))
    (try appContextMenu.openFromShortSwipe(self.order))
    (try modelContextMenu.openMoveToFolderScreen())
    (try appContextMenu.openMoveToFolderScreen())
    return MoveToFolderComponent()
  }

  @discardableResult
  open func tostring() -> String {
    return "\(ShortSwipeContextMenuOpenMoveToFolderAction.type)\(self.order)"
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return ShortSwipeContextMenuOpenMoveToFolderAction.type
  }

}

open class ShortSwipeContextMenuMoveToFolderAction: MBTAction {
  public static let type: MBTActionType = "ShortSwipeContextMenuOpenMoveToFolderAction"
  private let order: Int32
  private let folderName: FolderName
  public init(_ order: Int32, _ folderName: FolderName) {
    self.order = order
    self.folderName = folderName
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (FolderNavigatorFeature.`get`.included(modelFeatures) && MoveToFolderFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    let folderList = (try FolderNavigatorFeature.`get`.forceCast(model).getFoldersList())
    return folderList.has(self.folderName)
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageListEvents.openMessageActions(self.order, fakeMid()), Eventus.messageListEvents.moveMessageToFolder(self.order, fakeMid()))
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromShortSwipe(self.order))
    (try appContextMenu.openFromShortSwipe(self.order))
    (try modelContextMenu.openMoveToFolderScreen())
    (try appContextMenu.openMoveToFolderScreen())
    (try MoveToFolderFeature.`get`.forceCast(model).tapOnFolder(self.folderName))
    (try MoveToFolderFeature.`get`.forceCast(application).tapOnFolder(self.folderName))
    return history.currentComponent
  }

  @discardableResult
  open func tostring() -> String {
    return "\(ShortSwipeContextMenuOpenMoveToFolderAction.type)\(self.order)"
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return ShortSwipeContextMenuOpenMoveToFolderAction.type
  }

}

open class ShortSwipeContextMenuArchiveAction: MBTAction {
  public static let type: MBTActionType = "ShortSwipeContextMenuArchiveAction"
  private let order: Int32
  public init(_ order: Int32) {
    self.order = order
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (ContainerGetterFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    let isInArchiveFolder = (try ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer()).name == DefaultFolderName.archive
    return !isInArchiveFolder
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageListEvents.openMessageActions(self.order, fakeMid()), Eventus.messageListEvents.archiveMessage(self.order, fakeMid()))
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromShortSwipe(self.order))
    (try appContextMenu.openFromShortSwipe(self.order))
    (try modelContextMenu.archive())
    (try appContextMenu.archive())
    return history.currentComponent
  }

  @discardableResult
  open func tostring() -> String {
    return "\(ShortSwipeContextMenuArchiveAction.type)\(self.order)"
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return ShortSwipeContextMenuArchiveAction.type
  }

}

open class MessageViewOpenContextMenuAction: MBTAction {
  public static let type: MBTActionType = "MessageViewOpenContextMenuAction"
  public init() {
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return MessageViewerFeature.`get`.forceCast(model).isMessageOpened()
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray()
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    (try ContextMenuFeature.`get`.forceCast(model).openFromMessageView())
    (try ContextMenuFeature.`get`.forceCast(application).openFromMessageView())
    return ContextMenuComponent()
  }

  @discardableResult
  open func tostring() -> String {
    return "\(MessageViewOpenContextMenuAction.type)"
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return MessageViewOpenContextMenuAction.type
  }

}

open class MessageViewContextMenuOpenApplyLabelsAction: MBTAction {
  public static let type: MBTActionType = "MessageViewContextMenuOpenApplyLabelsAction"
  public init() {
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return !YSArray(DefaultFolderName.spam, DefaultFolderName.trash).includes((try ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer()).name)
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageViewEvents.openMessageActions(0))
  }

  @discardableResult
  open func getActionType() -> String {
    return MessageViewContextMenuOpenApplyLabelsAction.type
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromMessageView())
    (try appContextMenu.openFromMessageView())
    (try modelContextMenu.openApplyLabelsScreen())
    (try appContextMenu.openApplyLabelsScreen())
    return ApplyLabelComponent()
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (MessageListDisplayFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func tostring() -> String {
    return "\(MessageViewContextMenuOpenApplyLabelsAction.type)"
  }

}

open class MessageViewContextMenuApplyLabelsAction: MBTAction {
  public static let type: MBTActionType = "MessageViewContextMenuApplyLabelsAction"
  private let labels: YSArray<LabelName>
  public init(_ labels: YSArray<LabelName>) {
    self.labels = labels
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return !YSArray(DefaultFolderName.spam, DefaultFolderName.trash).includes((try ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer()).name)
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.markAs())
  }

  @discardableResult
  open func getActionType() -> String {
    return MessageViewContextMenuApplyLabelsAction.type
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromMessageView())
    (try appContextMenu.openFromMessageView())
    (try modelContextMenu.openApplyLabelsScreen())
    (try appContextMenu.openApplyLabelsScreen())
    let modelApplyLabel = ApplyLabelFeature.`get`.forceCast(model)
    let appApplyLabel = ApplyLabelFeature.`get`.forceCast(application)
    (try modelApplyLabel.selectLabelsToAdd(self.labels))
    (try appApplyLabel.selectLabelsToAdd(self.labels))
    (try modelApplyLabel.tapOnDoneButton())
    (try appApplyLabel.tapOnDoneButton())
    return history.currentComponent
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (MessageListDisplayFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures) && MessageViewerFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func tostring() -> String {
    return "\(MessageViewContextMenuApplyLabelsAction.type)"
  }

}

open class MessageViewContextMenuRemoveLabelsAction: MBTAction {
  public static let type: MBTActionType = "MessageViewContextMenuRemoveLabelsAction"
  private let labels: YSArray<LabelName>
  public init(_ labels: YSArray<LabelName>) {
    self.labels = labels
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    let modelApplyLabel = ApplyLabelFeature.`get`.forceCast(model)
    let selectedLabels = (try modelApplyLabel.getSelectedLabels())
    for label in self.labels {
      if !selectedLabels.includes(label) {
        return false
      }
    }
    return !YSArray(DefaultFolderName.spam, DefaultFolderName.trash).includes((try ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer()).name)
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.markAs())
  }

  @discardableResult
  open func getActionType() -> String {
    return MessageViewContextMenuRemoveLabelsAction.type
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromMessageView())
    (try appContextMenu.openFromMessageView())
    (try modelContextMenu.openApplyLabelsScreen())
    (try appContextMenu.openApplyLabelsScreen())
    let modelApplyLabel = ApplyLabelFeature.`get`.forceCast(model)
    let appApplyLabel = ApplyLabelFeature.`get`.forceCast(application)
    (try modelApplyLabel.deselectLabelsToRemove(self.labels))
    (try appApplyLabel.deselectLabelsToRemove(self.labels))
    (try modelApplyLabel.tapOnDoneButton())
    (try appApplyLabel.tapOnDoneButton())
    return history.currentComponent
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (MessageListDisplayFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures) && MessageViewerFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func tostring() -> String {
    return "\(MessageViewContextMenuRemoveLabelsAction.type)"
  }

}

open class MessageViewContextMenuOpenMoveToFolderAction: MBTAction {
  public static let type: MBTActionType = "MessageViewContextMenuOpenMoveToFolderAction"
  public init() {
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (FolderNavigatorFeature.`get`.included(modelFeatures) && MoveToFolderFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return true
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageViewEvents.openMessageActions(0))
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromMessageView())
    (try appContextMenu.openFromMessageView())
    (try modelContextMenu.openMoveToFolderScreen())
    (try appContextMenu.openMoveToFolderScreen())
    return MoveToFolderComponent()
  }

  @discardableResult
  open func tostring() -> String {
    return "\(MessageViewContextMenuOpenMoveToFolderAction.type)"
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return MessageViewContextMenuOpenMoveToFolderAction.type
  }

}

open class MessageViewContextMenuMoveToFolderAction: MBTAction {
  public static let type: MBTActionType = "MessageViewContextMenuMoveToFolderAction"
  private let folderName: FolderName
  public init(_ folderName: FolderName) {
    self.folderName = folderName
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (FolderNavigatorFeature.`get`.included(modelFeatures) && MoveToFolderFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    let folderList = (try FolderNavigatorFeature.`get`.forceCast(model).getFoldersList())
    return folderList.has(self.folderName)
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.moveToFolder())
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromMessageView())
    (try appContextMenu.openFromMessageView())
    (try modelContextMenu.openMoveToFolderScreen())
    (try appContextMenu.openMoveToFolderScreen())
    (try MoveToFolderFeature.`get`.forceCast(model).tapOnFolder(self.folderName))
    (try MoveToFolderFeature.`get`.forceCast(application).tapOnFolder(self.folderName))
    return history.currentComponent
  }

  @discardableResult
  open func tostring() -> String {
    return "\(MessageViewContextMenuMoveToFolderAction.type)"
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return MessageViewContextMenuMoveToFolderAction.type
  }

}

open class MessageViewContextMenuDeleteAction: MBTAction {
  public static let type: MBTActionType = "MessageViewContextMenuDeleteAction"
  public init() {
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return true
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.delete())
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromMessageView())
    (try appContextMenu.openFromMessageView())
    (try modelContextMenu.deleteMessage())
    (try appContextMenu.deleteMessage())
    return MaillistComponent()
  }

  @discardableResult
  open func tostring() -> String {
    return "\(MessageViewContextMenuDeleteAction.type)"
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return MessageViewContextMenuDeleteAction.type
  }

}

open class MessageViewContextMenuMarkAsSpamAction: MBTAction {
  public static let type: MBTActionType = "MessageViewContextMenuMarkAsSpamAction"
  public init() {
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return !YSArray(DefaultFolderName.sent, DefaultFolderName.spam, DefaultFolderName.draft, DefaultFolderName.template).includes((try ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer()).name)
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.markAsSpam())
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromMessageView())
    (try appContextMenu.openFromMessageView())
    (try modelContextMenu.markAsSpam())
    (try appContextMenu.markAsSpam())
    return MaillistComponent()
  }

  @discardableResult
  open func tostring() -> String {
    return "\(MessageViewContextMenuMarkAsSpamAction.type)"
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return MessageViewContextMenuMarkAsSpamAction.type
  }

}

open class MessageViewContextMenuMarkAsNotSpamAction: MBTAction {
  public static let type: MBTActionType = "MessageViewContextMenuMarkAsNotSpamAction"
  public init() {
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return (try ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer()).name == DefaultFolderName.spam
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.markAsNotSpam())
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromMessageView())
    (try appContextMenu.openFromMessageView())
    (try modelContextMenu.markAsNotSpam())
    (try appContextMenu.markAsNotSpam())
    return MaillistComponent()
  }

  @discardableResult
  open func tostring() -> String {
    return "\(MessageViewContextMenuMarkAsNotSpamAction.type)"
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return MessageViewContextMenuMarkAsNotSpamAction.type
  }

}

open class MessageViewContextMenuMarkAsReadAction: BaseMailViewContextMenuAction {
  public static let type: MBTActionType = "MessageViewContextMenuMarkAsReadAction"
  public init() {
    super.init(MessageViewContextMenuMarkAsReadAction.type)
  }

  @discardableResult
  open func requiredFeature() -> Feature<ContextMenu> {
    return ContextMenuFeature.`get`
  }

  @discardableResult
  open override func canBePerformedImpl(_ message: MessageView) throws -> Bool {
    return MarkAsRead.canMarkRead(message)
  }

  @discardableResult
  open override func performImpl(_ modelOrApplication: ContextMenu) throws -> Void {
    (try modelOrApplication.openFromMessageView())
    (try modelOrApplication.markAsRead())
  }

  @discardableResult
  open override func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.markAsRead())
  }

}

open class MessageViewContextMenuMarkAsUnreadAction: BaseMailViewContextMenuAction {
  public static let type: MBTActionType = "MessageViewContextMenuMarkAsUnreadAction"
  public init() {
    super.init(MessageViewContextMenuMarkAsUnreadAction.type)
  }

  @discardableResult
  open func requiredFeature() -> Feature<ContextMenu> {
    return ContextMenuFeature.`get`
  }

  @discardableResult
  open override func canBePerformedImpl(_ message: MessageView) throws -> Bool {
    return MarkAsUnread.canMarkUnread(message)
  }

  @discardableResult
  open override func performImpl(_ modelOrApplication: ContextMenu) throws -> Void {
    (try modelOrApplication.openFromMessageView())
    (try modelOrApplication.markAsUnread())
  }

  @discardableResult
  open override func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.markAsUnread())
  }

}

open class MessageViewContextMenuMarkAsImportantAction: BaseMailViewContextMenuAction {
  public static let type: MBTActionType = "MessageViewContextMenuMarkAsImportantAction"
  public init() {
    super.init(MessageViewContextMenuMarkAsImportantAction.type)
  }

  @discardableResult
  open func requiredFeature() -> Feature<ContextMenu> {
    return ContextMenuFeature.`get`
  }

  @discardableResult
  open override func canBePerformedImpl(_ message: MessageView) throws -> Bool {
    return MarkAsImportant.canMarkImportant(message)
  }

  @discardableResult
  open override func performImpl(_ modelOrApplication: ContextMenu) throws -> Void {
    (try modelOrApplication.openFromMessageView())
    (try modelOrApplication.markAsImportant())
  }

  @discardableResult
  open override func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.markAsImportant())
  }

}

open class MessageViewContextMenuMarkAsUnimportantAction: BaseMailViewContextMenuAction {
  public static let type: MBTActionType = "MessageViewContextMenuMarkAsUnimportantAction"
  public init() {
    super.init(MessageViewContextMenuMarkAsUnimportantAction.type)
  }

  @discardableResult
  open func requiredFeature() -> Feature<ContextMenu> {
    return ContextMenuFeature.`get`
  }

  @discardableResult
  open override func canBePerformedImpl(_ message: MessageView) throws -> Bool {
    return MarkAsUnimportant.canMarkUnimportant(message)
  }

  @discardableResult
  open override func performImpl(_ modelOrApplication: ContextMenu) throws -> Void {
    (try modelOrApplication.openFromMessageView())
    (try modelOrApplication.markAsUnimportant())
  }

  @discardableResult
  open override func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.markAsNotImportant())
  }

}

open class MessageViewContextMenuArchiveAction: MBTAction {
  public static let type: MBTActionType = "MessageViewContextMenuArchiveAction"
  public init() {
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (ContainerGetterFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    let isInArchiveFolder = (try ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer()).name == DefaultFolderName.archive
    return !isInArchiveFolder
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.archive())
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromMessageView())
    (try appContextMenu.openFromMessageView())
    (try modelContextMenu.archive())
    (try appContextMenu.archive())
    return MaillistComponent()
  }

  @discardableResult
  open func tostring() -> String {
    return "\(MessageViewContextMenuArchiveAction.type)"
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return MessageViewContextMenuArchiveAction.type
  }

}

open class MessageViewContextMenuShowTranslatorAction: MBTAction {
  public static let type: MBTActionType = "MessageViewContextMenuShowTranslatorAction"
  public init() {
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (TranslatorBarFeature.`get`.includedAll(modelFeatures, applicationFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return true
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageViewEvents.openMessageActions(0))
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromMessageView())
    (try appContextMenu.openFromMessageView())
    (try modelContextMenu.showTranslator())
    (try appContextMenu.showTranslator())
    return history.currentComponent
  }

  @discardableResult
  open func tostring() -> String {
    return "\(MessageViewContextMenuShowTranslatorAction.type)"
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return MessageViewContextMenuShowTranslatorAction.type
  }

}

open class MessageViewContextMenuOpenReplyComposeAction: MBTAction {
  public static let type: MBTActionType = "MessageViewContextMenuOpenReplyComposeAction"
  public init() {
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return !YSArray(DefaultFolderName.draft, DefaultFolderName.template).includes((try ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer()).name)
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageViewEvents.reply(0))
  }

  @discardableResult
  open func getActionType() -> String {
    return MessageViewContextMenuOpenReplyComposeAction.type
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromMessageView())
    (try appContextMenu.openFromMessageView())
    (try modelContextMenu.openReplyCompose())
    (try appContextMenu.openReplyCompose())
    return ComposeComponent()
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures) && ComposeFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func tostring() -> String {
    return "\(MessageViewContextMenuOpenReplyComposeAction.type)"
  }

}

open class MessageViewContextMenuOpenForwardComposeAction: MBTAction {
  public static let type: MBTActionType = "MessageViewContextMenuOpenForwardComposeAction"
  public init() {
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return !YSArray(DefaultFolderName.draft, DefaultFolderName.template).includes((try ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer()).name)
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageViewEvents.reply(0))
  }

  @discardableResult
  open func getActionType() -> String {
    return MessageViewContextMenuOpenForwardComposeAction.type
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
    let appContextMenu = ContextMenuFeature.`get`.forceCast(application)
    (try modelContextMenu.openFromMessageView())
    (try appContextMenu.openFromMessageView())
    (try modelContextMenu.openForwardCompose())
    (try appContextMenu.openForwardCompose())
    return ComposeComponent()
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures) && ComposeFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func tostring() -> String {
    return "\(MessageViewContextMenuOpenForwardComposeAction.type)"
  }

}

