// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/actions/messages-list/thread-markable-actions.ts >>>

import Foundation

open class AbstractExpandableThreadsAction: MBTAction {
  public var threadOrder: Int32
  private var type: MBTActionType
  public init(_ threadOrder: Int32, _ type: MBTActionType) {
    self.threadOrder = threadOrder
    self.type = type
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (ExpandableThreadsModelFeature.`get`.included(modelFeatures) && ExpandableThreadsFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return (try self.canBePerformedImpl(ExpandableThreadsModelFeature.`get`.forceCast(model)))
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    (try self.performImpl(ExpandableThreadsFeature.`get`.forceCast(model)))
    (try self.performImpl(ExpandableThreadsFeature.`get`.forceCast(application)))
    return history.currentComponent
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray()
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return self.type
  }

  @discardableResult
  open func canBePerformedImpl(_ model: ReadOnlyExpandableThreads) throws -> Bool {
    fatalError("Must be overridden in subclasses")
  }

  @discardableResult
  open func performImpl(_ modelOrApplication: ExpandableThreads) throws -> Void {
    fatalError("Must be overridden in subclasses")
  }

  @discardableResult
  open func tostring() -> String {
    fatalError("Must be overridden in subclasses")
  }

}

open class ExpandThreadAction: AbstractExpandableThreadsAction {
  public static let type: MBTActionType = "ExpandThread"
  public init(_ threadOrder: Int32) {
    super.init(threadOrder, ExpandThreadAction.type)
  }

  @discardableResult
  open override func canBePerformedImpl(_ model: ReadOnlyExpandableThreads) throws -> Bool {
    let isExpanded = (try model.isExpanded(self.threadOrder))
    let threadLength = (try model.getMessagesInThread(self.threadOrder)).length
    return !isExpanded && threadLength > 1
  }

  @discardableResult
  open override func performImpl(_ modelOrApplication: ExpandableThreads) throws -> Void {
    (try modelOrApplication.expandThread(self.threadOrder))
  }

  @discardableResult
  open override func tostring() -> String {
    return "ExpandThreadAction(\(self.threadOrder))"
  }

}

open class CollapseThreadAction: AbstractExpandableThreadsAction {
  public static let type: MBTActionType = "CollapseThread"
  public init(_ threadOrder: Int32) {
    super.init(threadOrder, CollapseThreadAction.type)
  }

  @discardableResult
  open override func canBePerformedImpl(_ model: ReadOnlyExpandableThreads) throws -> Bool {
    return (try model.isExpanded(self.threadOrder))
  }

  @discardableResult
  open override func performImpl(_ modelOrApplication: ExpandableThreads) throws -> Void {
    (try modelOrApplication.collapseThread(self.threadOrder))
  }

  @discardableResult
  open override func tostring() -> String {
    return "CollapseThreadAction(\(self.threadOrder))"
  }

}

open class MarkAsReadExpandedAction: AbstractExpandableThreadsAction {
  public static let type: MBTActionType = "MarkAsReadExpanded"
  private var messageOrder: Int32
  public init(_ threadOrder: Int32, _ messageOrder: Int32) {
    self.messageOrder = messageOrder
    super.init(threadOrder, MarkAsReadExpandedAction.type)
  }

  @discardableResult
  open override func canBePerformedImpl(_ model: ReadOnlyExpandableThreads) throws -> Bool {
    let isRead = (try model.isRead(self.threadOrder, self.messageOrder))
    return (try model.isExpanded(self.threadOrder)) && !isRead
  }

  @discardableResult
  open override func performImpl(_ modelOrApplication: ExpandableThreads) throws -> Void {
    (try modelOrApplication.markThreadMessageAsRead(self.threadOrder, self.messageOrder))
  }

  @discardableResult
  open override func tostring() -> String {
    return "MarkAsReadExpandedAction(\(self.threadOrder), \(self.messageOrder))"
  }

}

open class MarkAsUnreadExpandedAction: AbstractExpandableThreadsAction {
  public static let type: MBTActionType = "MarkAsUnreadExpanded"
  private var messageOrder: Int32
  public init(_ threadOrder: Int32, _ messageOrder: Int32) {
    self.messageOrder = messageOrder
    super.init(threadOrder, MarkAsUnreadExpandedAction.type)
  }

  @discardableResult
  open override func canBePerformedImpl(_ model: ReadOnlyExpandableThreads) throws -> Bool {
    let isRead = (try model.isRead(self.threadOrder, self.messageOrder))
    return (try model.isExpanded(self.threadOrder)) && isRead
  }

  @discardableResult
  open override func performImpl(_ modelOrApplication: ExpandableThreads) throws -> Void {
    (try modelOrApplication.markThreadMessageAsUnRead(self.threadOrder, self.messageOrder))
  }

  @discardableResult
  open override func tostring() -> String {
    return "MarkAsUnreadExpandedAction(\(self.threadOrder), \(self.messageOrder))"
  }

}

