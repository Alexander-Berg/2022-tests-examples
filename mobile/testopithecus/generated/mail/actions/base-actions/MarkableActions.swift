// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/actions/base-actions/markable-actions.ts >>>

import Foundation

open class BaseMarkAction: MBTAction {
  public var order: Int32
  public init(_ order: Int32) {
    self.order = order
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (MessageListDisplayFeature.`get`.included(modelFeatures) && MarkableReadFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    let messageListModel = MessageListDisplayFeature.`get`.forceCast(model)
    let messages = (try messageListModel.getMessageList(10))
    let canPerform = (try self.canBePerformedImpl(messages[self.order]))
    return self.order < messages.length && canPerform
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    (try self.performImpl(MarkableReadFeature.`get`.forceCast(model)))
    (try self.performImpl(MarkableReadFeature.`get`.forceCast(application)))
    return history.currentComponent
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    fatalError("Must be overridden in subclasses")
  }

  @discardableResult
  open func canBePerformedImpl(_ message: MessageView) throws -> Bool {
    fatalError("Must be overridden in subclasses")
  }

  @discardableResult
  open func performImpl(_ modelOrApplication: MarkableRead) throws -> Void {
    fatalError("Must be overridden in subclasses")
  }

  @discardableResult
  open func tostring() -> String {
    fatalError("Must be overridden in subclasses")
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    fatalError("Must be overridden in subclasses")
  }

}

open class MarkAsRead: BaseMarkAction {
  public static let type: MBTActionType = "MarkAsRead"
  public override init(_ order: Int32) {
    super.init(order)
  }

  @discardableResult
  open class func canMarkRead(_ message: MessageView) -> Bool {
    return !message.read
  }

  @discardableResult
  open override func canBePerformedImpl(_ message: MessageView) throws -> Bool {
    return MarkAsRead.canMarkRead(message)
  }

  @discardableResult
  open override func performImpl(_ modelOrApplication: MarkableRead) throws -> Void {
    return (try modelOrApplication.markAsRead(self.order))
  }

  @discardableResult
  open override func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageListEvents.markMessageAsRead(self.order, int64(-1)))
  }

  @discardableResult
  open override func tostring() -> String {
    return "MarkAsRead(#\(self.order))"
  }

  @discardableResult
  open override func getActionType() -> MBTActionType {
    return MarkAsRead.type
  }

}

open class MarkAsUnread: BaseMarkAction {
  public static let type: MBTActionType = "MarkAsUnread"
  public override init(_ order: Int32) {
    super.init(order)
  }

  @discardableResult
  open class func canMarkUnread(_ message: MessageView) -> Bool {
    return message.read
  }

  @discardableResult
  open override func canBePerformedImpl(_ message: MessageView) throws -> Bool {
    return MarkAsUnread.canMarkUnread(message)
  }

  @discardableResult
  open override func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageListEvents.markMessageAsUnread(self.order, int64(-1)))
  }

  @discardableResult
  open override func performImpl(_ modelOrApplication: MarkableRead) throws -> Void {
    return (try modelOrApplication.markAsUnread(self.order))
  }

  @discardableResult
  open override func tostring() -> String {
    return "MarkAsUnread(#\(self.order))"
  }

  @discardableResult
  open override func getActionType() -> MBTActionType {
    return MarkAsUnread.type
  }

}

