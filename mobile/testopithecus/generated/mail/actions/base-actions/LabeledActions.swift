// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/actions/base-actions/labeled-actions.ts >>>

import Foundation

open class BaseLabelAction: MBTAction {
  public var order: Int32
  private var type: MBTActionType
  public init(_ order: Int32, _ type: MBTActionType) {
    self.order = order
    self.type = type
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return MarkableImportantFeature.`get`.includedAll(modelFeatures, applicationFeatures)
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    let messageListModel = MessageListDisplayFeature.`get`.forceCast(model)
    let messages = (try messageListModel.getMessageList(10))
    let canPerform = (try self.canBePerformedImpl(messages[self.order]))
    return self.order < messages.length && canPerform
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    (try self.performImpl(MarkableImportantFeature.`get`.forceCast(model)))
    (try self.performImpl(MarkableImportantFeature.`get`.forceCast(application)))
    return history.currentComponent
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return self.type
  }

  @discardableResult
  open func canBePerformedImpl(_ message: MessageView) throws -> Bool {
    fatalError("Must be overridden in subclasses")
  }

  @discardableResult
  open func performImpl(_ modelOrApplication: MarkableImportant) throws -> Void {
    fatalError("Must be overridden in subclasses")
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    fatalError("Must be overridden in subclasses")
  }

  @discardableResult
  open func tostring() -> String {
    fatalError("Must be overridden in subclasses")
  }

}

open class MarkAsImportant: BaseLabelAction {
  public static let type: MBTActionType = "MarkAsImportant"
  public init(_ order: Int32) {
    super.init(order, MarkAsImportant.type)
  }

  @discardableResult
  open class func canMarkImportant(_ message: MessageView) -> Bool {
    return !message.important
  }

  @discardableResult
  open override func canBePerformedImpl(_ message: MessageView) throws -> Bool {
    return MarkAsImportant.canMarkImportant(message)
  }

  @discardableResult
  open override func performImpl(_ modelOrApplication: MarkableImportant) throws -> Void {
    return (try modelOrApplication.markAsImportant(self.order))
  }

  @discardableResult
  open override func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageListEvents.openMessageActions(self.order, int64(-1)), Eventus.messageListEvents.markMessageAsImportant(self.order, int64(-1)))
  }

  @discardableResult
  open override func tostring() -> String {
    return "MarkAsImportant(#\(self.order))"
  }

}

open class MarkAsUnimportant: BaseLabelAction {
  public static let type: MBTActionType = "MarkAsImportant"
  public init(_ order: Int32) {
    super.init(order, MarkAsUnimportant.type)
  }

  @discardableResult
  open class func canMarkUnimportant(_ message: MessageView) -> Bool {
    return message.important
  }

  @discardableResult
  open override func canBePerformedImpl(_ message: MessageView) throws -> Bool {
    return MarkAsUnimportant.canMarkUnimportant(message)
  }

  @discardableResult
  open override func performImpl(_ modelOrApplication: MarkableImportant) throws -> Void {
    return (try modelOrApplication.markAsUnimportant(self.order))
  }

  @discardableResult
  open override func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.messageListEvents.openMessageActions(self.order, int64(-1)), Eventus.messageListEvents.markMessageAsNotImportant(self.order, int64(-1)))
  }

  @discardableResult
  open override func tostring() -> String {
    return "MarkAsUnimportant(#\(self.order))"
  }

}

open class ApplyLabelTapOnCreateLabelAction: MBTAction {
  public static let type: MBTActionType = "ApplyLabelTapOnCreateLabelAction"
  public init() {
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (ApplyLabelFeature.`get`.includedAll(modelFeatures, applicationFeatures) && ManageableLabelFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    return true
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray()
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    (try ApplyLabelFeature.`get`.forceCast(model).tapOnCreateLabel())
    (try ApplyLabelFeature.`get`.forceCast(application).tapOnCreateLabel())
    return CreateLabelComponent()
  }

  @discardableResult
  open func tostring() -> String {
    return "\(ApplyLabelTapOnCreateLabelAction.type)"
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return ApplyLabelTapOnCreateLabelAction.type
  }

}

open class ApplyLabelAddLabelAction: MBTAction {
  public static let type: MBTActionType = "ApplyLabelAddLabelAction"
  private let labelNames: YSArray<LabelName>
  public init(_ labelNames: YSArray<LabelName>) {
    self.labelNames = labelNames
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return (FolderNavigatorFeature.`get`.included(modelFeatures) && MoveToFolderFeature.`get`.includedAll(modelFeatures, applicationFeatures))
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    let labelList = (try LabelNavigatorFeature.`get`.forceCast(model).getLabelList())
    return labelList.filter({
      (label) in
      self.labelNames.includes(label)
    }).length > 0
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    return YSArray()
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    let modelApplyLabel = ApplyLabelFeature.`get`.forceCast(model)
    let appApplyLabel = ApplyLabelFeature.`get`.forceCast(application)
    (try modelApplyLabel.selectLabelsToAdd(self.labelNames))
    (try appApplyLabel.selectLabelsToAdd(self.labelNames))
    (try modelApplyLabel.tapOnDoneButton())
    (try appApplyLabel.tapOnDoneButton())
    return self.previousComponents(history)
  }

  @discardableResult
  private func previousComponents(_ history: MBTHistory) -> MBTComponent {
    var previousComponent: MBTComponent! = nil
    for component in history.allPreviousComponents.reverse() {
      if YSArray(MessageComponent.type, MaillistComponent.type).includes(component.tostring()) {
        previousComponent = component
        break
      }
    }
    return requireNonNull(previousComponent, "No previous component")
  }

  @discardableResult
  open func tostring() -> String {
    return "\(ApplyLabelAddLabelAction.type)(\(self.labelNames))"
  }

  @discardableResult
  open func getActionType() -> MBTActionType {
    return ApplyLabelAddLabelAction.type
  }

}

