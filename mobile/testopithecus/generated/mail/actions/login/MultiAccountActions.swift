// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/actions/login/multi-account-actions.ts >>>

import Foundation

open class MultiAccountAction: MBTAction {
  public init() {
  }

  @discardableResult
  open func events() -> YSArray<EventusEvent> {
    fatalError("Must be overridden in subclasses")
  }

  @discardableResult
  open func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return MultiAccountFeature.`get`.includedAll(modelFeatures, applicationFeatures)
  }

  @discardableResult
  open func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent {
    fatalError("Must be overridden in subclasses")
  }

  @discardableResult
  open func canBePerformed(_ model: App) throws -> Bool {
    fatalError("Must be overridden in subclasses")
  }

  @discardableResult
  open func tostring() -> String {
    fatalError("Must be overridden in subclasses")
  }

  @discardableResult
  open func getActionType() -> String {
    fatalError("Must be overridden in subclasses")
  }

}

open class SwitchAccountAction: MultiAccountAction {
  public static let type: MBTActionType = "SwitchAccount"
  private var account: UserAccount
  public init(_ account: UserAccount) {
    self.account = account
    super.init()
  }

  @discardableResult
  open override func canBePerformed(_ model: App) throws -> Bool {
    return (try MultiAccountFeature.`get`.forceCast(model).getLoggedInAccountsList()).includes(self.account.login)
  }

  @discardableResult
  open override func perform(_ model: App, _ application: App, _ _history: MBTHistory) throws -> MBTComponent {
    (try self.performImpl(model))
    (try self.performImpl(application))
    return FolderListComponent()
  }

  @discardableResult
  open override func tostring() -> String {
    return "SwitchAccountAction(login=\(self.account.login))"
  }

  @discardableResult
  open override func getActionType() -> String {
    return SwitchAccountAction.type
  }

  @discardableResult
  private func performImpl(_ modelOrApplication: App) throws -> Void {
    (try MultiAccountFeature.`get`.forceCast(modelOrApplication).switchToAccount(self.account.login))
  }

  @discardableResult
  open override func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.multiAccountEvents.switchToAccount(int64(-1)))
  }

}

open class AddNewAccountAction: MultiAccountAction {
  public static let type: MBTActionType = "AddNewAccount"
  public override init() {
    super.init()
  }

  @discardableResult
  open override func canBePerformed(_ _model: App) -> Bool {
    return true
  }

  @discardableResult
  open override func perform(_ model: App, _ application: App, _ _history: MBTHistory) throws -> MBTComponent {
    (try self.performImpl(model))
    (try self.performImpl(application))
    return LoginComponent()
  }

  @discardableResult
  open override func tostring() -> String {
    return "AddNewAccountAction"
  }

  @discardableResult
  open override func getActionType() -> String {
    return AddNewAccountAction.type
  }

  @discardableResult
  private func performImpl(_ modelOrApplication: App) throws -> Void {
    (try MultiAccountFeature.`get`.forceCast(modelOrApplication).addNewAccount())
  }

  @discardableResult
  open override func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.multiAccountEvents.addNewAccount())
  }

}

open class LogoutFromAccountAction: MultiAccountAction {
  public static let type: MBTActionType = "LogoutFromAccount"
  private var account: UserAccount
  public init(_ account: UserAccount) {
    self.account = account
    super.init()
  }

  @discardableResult
  open override func canBePerformed(_ _model: App) -> Bool {
    return true
  }

  @discardableResult
  open override func perform(_ model: App, _ application: App, _ _history: MBTHistory) throws -> MBTComponent {
    (try self.performImpl(model))
    (try self.performImpl(application))
    return MaillistComponent()
  }

  @discardableResult
  open override func tostring() -> String {
    return "LogoutFromAccountAction(login=\(self.account.login))"
  }

  @discardableResult
  open override func getActionType() -> String {
    return LogoutFromAccountAction.type
  }

  @discardableResult
  private func performImpl(_ modelOrApplication: App) throws -> Void {
    (try MultiAccountFeature.`get`.forceCast(modelOrApplication).logoutFromAccount(self.account.login))
  }

  @discardableResult
  open override func events() -> YSArray<EventusEvent> {
    return YSArray(Eventus.multiAccountEvents.logoutFromAccount())
  }

}

open class LogoutFromLastAccountAction: MultiAccountAction {
  public static let type: MBTActionType = "LogoutFromLastAccount"
  private var account: UserAccount
  public init(_ account: UserAccount) {
    self.account = account
    super.init()
  }

  @discardableResult
  open override func canBePerformed(_ _model: App) -> Bool {
    return true
  }

  @discardableResult
  open override func perform(_ model: App, _ application: App, _ _history: MBTHistory) throws -> MBTComponent {
    (try self.performImpl(model))
    (try self.performImpl(application))
    return LoginComponent()
  }

  @discardableResult
  open override func tostring() -> String {
    return "LogoutFromAccountAction(login=\(self.account.login))"
  }

  @discardableResult
  open override func getActionType() -> String {
    return LogoutFromAccountAction.type
  }

  @discardableResult
  private func performImpl(_ modelOrApplication: App) throws -> Void {
    (try MultiAccountFeature.`get`.forceCast(modelOrApplication).logoutFromAccount(self.account.login))
  }

  @discardableResult
  open override func events() -> YSArray<EventusEvent> {
    return YSArray()
  }

}

