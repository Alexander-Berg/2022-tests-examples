// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/model/supplementary/message-list-database.ts >>>

import Foundation

open class MessageListDatabase {
  private let messages: YSMap<MessageId, FullMessage>
  private let folderToMessages: YSMap<FolderName, YSSet<MessageId>>
  private let labelToMessages: YSMap<LabelName, YSSet<MessageId>>
  private var tabsToMessages: YSMap<FolderName, YSSet<MessageId>>
  private var threads: YSArray<YSSet<MessageId>>
  public init(_ messages: YSMap<MessageId, FullMessage>, _ folderToMessages: YSMap<FolderName, YSSet<MessageId>>, _ labelToMessages: YSMap<LabelName, YSSet<MessageId>>, _ tabsToMessages: YSMap<FolderName, YSSet<MessageId>>, _ threads: YSArray<YSSet<MessageId>>) {
    self.messages = messages
    self.folderToMessages = folderToMessages
    self.labelToMessages = labelToMessages
    self.tabsToMessages = tabsToMessages
    self.threads = threads
    self.tabsToMessages.set(DefaultFolderName.inbox, YSSet<MessageId>())
    self.tabsToMessages.set(DefaultFolderName.socialNetworks, YSSet<MessageId>())
    self.tabsToMessages.set(DefaultFolderName.mailingLists, YSSet<MessageId>())
  }

  open func setMailDBHash(_ builder: HashBuilder) -> Void {
    for thread in self.threads {
      builder.addInt(19)
      for message in thread.values() {
        builder.addInt64(message)
      }
    }
    builder.addInt(17)
    self.messages.__forEach({
      (message, id) in
      builder.addInt64(id).addInt64(self.getMessageHash(message))
    })
    builder.addInt(13)
    self.folderToMessages.__forEach({
      (ids, folder) in
      for id in ids.values() {
        builder.addInt64(id).addString(folder)
      }
    })
  }

  @discardableResult
  open func copy() -> MessageListDatabase {
    let messagesCopy = YSMap<MessageId, FullMessage>()
    for mid in self.messages.keys() {
      messagesCopy.set(mid, self.messages.`get`(mid)!.copy())
    }
    let threadsCopy: YSArray<YSSet<MessageId>> = YSArray()
    self.threads.forEach({
      (thread) in
      let threadCopy = YSSet(thread)
      threadsCopy.push(threadCopy)
    })
    let folderToMessagesCopy: YSMap<FolderName, YSSet<MessageId>> = YSMap<FolderName, YSSet<MessageId>>()
    self.folderToMessages.__forEach({
      (mids, folderName) in
      folderToMessagesCopy.set(folderName, YSSet(mids))
    })
    let labelToMessagesCopy: YSMap<LabelName, YSSet<MessageId>> = YSMap<LabelName, YSSet<MessageId>>()
    self.labelToMessages.__forEach({
      (lids, labelName) in
      labelToMessagesCopy.set(labelName, YSSet(lids))
    })
    let tabsToMessagesCopy: YSMap<FolderName, YSSet<MessageId>> = YSMap<FolderName, YSSet<MessageId>>()
    self.tabsToMessages.__forEach({
      (mids, folderName) in
      tabsToMessagesCopy.set(folderName, YSSet(mids))
    })
    return MessageListDatabase(messagesCopy, folderToMessagesCopy, labelToMessagesCopy, tabsToMessagesCopy, threadsCopy)
  }

  @discardableResult
  open func getTabsToMessage(_ folderName: FolderName) -> YSSet<MessageId> {
    if !self.tabsToMessages.has(folderName) {
      fail("Это папка не таб!")
    }
    let messages = undefinedToNull(self.tabsToMessages.get(folderName))
    return messages!
  }

  @discardableResult
  open func getLabelList() -> YSArray<LabelName> {
    let labels: YSArray<LabelName> = YSArray()
    self.labelToMessages.__forEach({
      (mids, label) in
      labels.push(label)
    })
    return labels
  }

  @discardableResult
  open func getFolderList() -> YSArray<FolderName> {
    let folders: YSArray<FolderName> = YSArray()
    self.folderToMessages.__forEach({
      (mids, folder) in
      folders.push(folder)
    })
    return folders
  }

  @discardableResult
  open func getUserFolders() -> YSArray<FolderName> {
    let excludedFolders = YSArray(DefaultFolderName.inbox, DefaultFolderName.socialNetworks, DefaultFolderName.mailingLists, DefaultFolderName.trash, DefaultFolderName.sent, DefaultFolderName.archive, DefaultFolderName.spam, DefaultFolderName.outgoing, DefaultFolderName.draft, DefaultFolderName.template)
    return self.getFolderList().filter({
      (folderName) in
      !excludedFolders.includes(folderName)
    })
  }

  @discardableResult
  open func getMessages() -> YSArray<MessageId> {
    let messages: YSArray<MessageId> = YSArray()
    self.messages.__forEach({
      (msg, mid) in
      messages.push(mid)
    })
    return messages
  }

  @discardableResult
  open func getMessageIdList(_ filter: MessageListDatabaseFilter) -> YSArray<MessageId> {
    let filteredMessages: YSArray<MessageId> = YSArray()
    self.messages.__forEach({
      (_, mid) in
      if self.isMessageInFilter(mid, filter) {
        filteredMessages.push(mid)
      }
    })
    return self.buildMessageIdList(filteredMessages, filter.getLimit(), filter.getIsInThreadMode())
  }

  @discardableResult
  open func getMessageList(_ filter: MessageListDatabaseFilter) -> YSArray<MessageView> {
    return self.getMessageListFromIds(self.getMessageIdList(filter), filter.getIsInThreadMode())
  }

  @discardableResult
  open func isMessageInFilter(_ mid: MessageId, _ filter: MessageListDatabaseFilter) -> Bool {
    if filter.getContainer() != nil {
      if !self.isMessageInContainer(mid, filter) {
        return false
      }
    }
    if filter.getFolder() != nil {
      if !self.isMessageInFolder(mid, filter.getFolder()!) {
        return false
      }
    }
    if filter.getLabel() != nil {
      if !self.isMessageInLabel(mid, filter.getLabel()!) {
        return false
      }
    }
    if filter.getIsImportantOnly() {
      if !self.isMessageImportant(mid) {
        return false
      }
    }
    if filter.getIsUnreadOnly() {
      if !self.isMessageUnread(mid) {
        return false
      }
    }
    for folderName in filter.getExcludedFolders() {
      if self.isMessageInFolder(mid, folderName) {
        return false
      }
    }
    return true
  }

  @discardableResult
  open func getMessagesInThreadByMid(_ mid: MessageId) -> YSArray<MessageId> {
    let orderInThreads: Int32! = self.findThread(mid)
    if orderInThreads == nil {
      return YSArray(mid)
    }
    let threadMids = self.threads[orderInThreads]
    let sortedMids = setToArray(threadMids)
    sortedMids.sort({
      (m1, m2) in
      return int64ToInt32(self.storedMessage(m2).mutableHead.timestamp - self.storedMessage(m1).mutableHead.timestamp)
    })
    return sortedMids
  }

  @discardableResult
  open func makeMessageThreadView(_ threadMid: MessageId) -> FullMessage {
    let threadView = self.storedMessage(threadMid).copy()
    if !self.isMessageInFolder(threadMid, DefaultFolderName.trash) {
      threadView.mutableHead.threadCounter = self.getMessagesInThreadByMid(threadMid).filter({
        (mid) in
        !self.isMessageInFolder(mid, DefaultFolderName.trash)
      }).length
    }
    if threadView.mutableHead.threadCounter == 1 {
      threadView.mutableHead.threadCounter = nil
    }
    threadView.mutableHead.read = self.getMessagesInThreadByMid(threadMid).filter({
      (mid) in
      !self.storedMessage(mid).head.read
    }).length == 0
    return threadView
  }

  open func createFolder(_ folderName: FolderName) -> Void {
    if self.folderToMessages.has(folderName) {
      fail("Такая папка уже существует!")
    }
    self.folderToMessages.set(folderName, YSSet<MessageId>())
  }

  open func removeFolder(_ folderName: FolderName) -> Void {
    if !self.folderToMessages.has(folderName) {
      fail("Невозможно удалить папку. Такой папки нет!")
    }
    self.folderToMessages.delete(folderName)
  }

  open func renameFolder(_ folderName: FolderName, _ newFolderName: FolderName) -> Void {
    if self.folderToMessages.has(newFolderName) || !self.folderToMessages.has(folderName) {
      fail("Невозможно переименовать. Папки нет, либо папка с таким именем уже существует!")
    }
    self.folderToMessages.set(newFolderName, self.folderToMessages.`get`(folderName)!)
    self.folderToMessages.delete(folderName)
  }

  private func updateTabsToMessages(_ mid: MessageId, _ folderName: FolderName) -> Void {
    self.tabsToMessages.__forEach({
      (msgIds, _folder) in
      msgIds.delete(mid)
    })
    if folderName == DefaultFolderName.mailingLists || folderName == DefaultFolderName.socialNetworks || folderName == DefaultFolderName.inbox {
      self.tabsToMessages.get(folderName)?.add(mid)
    }
  }

  open func moveMessageToFolder(_ mid: MessageId, _ folderName: FolderName, _ needUpdateTabsToMessages: Bool = true) -> Void {
    self.folderToMessages.__forEach({
      (msgIds, _folder) in
      msgIds.delete(mid)
    })
    self.demandFolderMessages(folderName).add(mid)
    if needUpdateTabsToMessages {
      self.updateTabsToMessages(mid, folderName)
    }
  }

  open func createLabel(_ labelName: LabelName) -> Void {
    if self.labelToMessages.has(labelName) {
      fail("Такая метка уже существует!")
    }
    self.labelToMessages.set(labelName, YSSet<MessageId>())
  }

  open func removeLabel(_ labelName: LabelName) -> Void {
    if !self.labelToMessages.has(labelName) {
      fail("Такой метки нет!")
    }
    self.labelToMessages.delete(labelName)
  }

  open func renameLabel(_ labelName: LabelName, _ newLabelName: LabelName) -> Void {
    if self.labelToMessages.has(newLabelName) || !self.labelToMessages.has(labelName) {
      fail("Невозможно переименовать. Метки нет, либо метка с таким именем уже существует!")
    }
    self.labelToMessages.set(newLabelName, self.labelToMessages.`get`(labelName)!)
    self.labelToMessages.delete(labelName)
  }

  open func applyLabelToMessages(_ labelName: LabelName, _ mids: YSSet<MessageId>) -> Void {
    mids.forEach({
      (mid) in
      self.labelToMessages.get(labelName)?.add(mid)
    })
  }

  open func removeLabelFromMessages(_ labelName: LabelName, _ mids: YSSet<MessageId>) -> Void {
    mids.forEach({
      (mid) in
      self.labelToMessages.get(labelName)?.delete(mid)
    })
  }

  @discardableResult
  open func getMessageLabels(_ mid: MessageId) -> YSSet<String> {
    let messageLabels = YSSet<LabelName>()
    self.labelToMessages.__forEach({
      (mids, labelName) in
      if mids.has(mid) {
        messageLabels.add(labelName)
      }
    })
    return messageLabels
  }

  open func addMessage(_ mid: MessageId, _ msg: FullMessage, _ folderName: FolderName) -> Void {
    if !self.folderToMessages.has(folderName) {
      fail("Папки \(folderName) нет!")
    }
    self.messages.set(mid, msg)
    self.folderToMessages.get(folderName)?.add(mid)
  }

  open func addThreadMessagesToThreadWithMid(_ midsToAdd: YSArray<MessageId>, _ midInThread: MessageId) -> Void {
    var threadAdded = false
    self.threads.forEach({
      (thread) in
      if thread.has(midInThread) {
        midsToAdd.forEach({
          (midToAdd) in
          thread.add(midToAdd)
        })
        threadAdded = true
      }
    })
    if !threadAdded {
      midsToAdd.push(midInThread)
      self.addThread(midsToAdd)
    }
  }

  open func addThread(_ mids: YSArray<MessageId>) -> Void {
    self.threads.push(arrayToSet(mids))
  }

  @discardableResult
  open func storedMessage(_ mid: MessageId, _ messageLanguage: LanguageName! = nil) -> FullMessage {
    let message = undefinedToNull(self.messages.get(mid))
    if message == nil {
      fail("No message with mid \(mid) in model!")
    }
    if messageLanguage != nil {
      let translation = message!.translations.`get`(messageLanguage)!
      return FullMessage(message!.mutableHead.copy(), message!.to, translation, messageLanguage, message!.translations, message!.quickReply, message!.smartReplies)
    }
    return message!
  }

  @discardableResult
  open func storedFolder(_ mid: MessageId) -> FolderName {
    var folderName: FolderName! = nil
    self.folderToMessages.__forEach({
      (msgIds, folder) in
      for msgId in msgIds.values() {
        if msgId == mid {
          folderName = folder
        }
      }
    })
    if folderName == nil {
      fail("No folder for message with mid \(mid) in model!")
    }
    return folderName!
  }

  open func removeMessage(_ id: MessageId) -> Void {
    if !self.messages.has(id) {
      fail("No messages with target id")
    }
    let isInTrash = self.demandFolderMessages(DefaultFolderName.trash).has(id)
    if isInTrash {
      self.removeMessagePermanently(id)
    } else {
      self.moveMessageToFolder(id, DefaultFolderName.trash)
    }
  }

  open func removeMessagePermanently(_ id: MessageId) -> Void {
    self.folderToMessages.__forEach({
      (msgIds, _folderName) in
      msgIds.delete(id)
    })
    self.messages.delete(id)
    for index in stride(from: 0, to: self.threads.length, by: 1) {
      self.threads[index].delete(id)
    }
    self.threads = self.threads.filter({
      (thread) in
      thread.size != 0
    })
  }

  @discardableResult
  open func isContainerEmpty(_ container: MessageContainer) -> Bool {
    return (self.getMessageIdList(MessageListDatabaseFilter().withContainer(container).withIsInThreadMode(false)).length == 0)
  }

  @discardableResult
  private func isMessageInContainer(_ mid: MessageId, _ filter: MessageListDatabaseFilter) -> Bool {
    var isInContainer = false
    let container = filter.getContainer()!
    if container != nil {
      if container.type == MessageContainerType.folder {
        return self.isMessageInFolder(mid, container.name)
      }
      if container.type == MessageContainerType.label {
        isInContainer = self.isMessageInLabel(mid, container.name)
      }
      if container.type == MessageContainerType.importantFilter {
        isInContainer = self.isMessageImportant(mid)
      }
      if container.type == MessageContainerType.unreadFilter {
        isInContainer = self.isMessageUnread(mid)
      }
      if container.type == MessageContainerType.search {
        isInContainer = self.isMessageInSearchRequest(mid, container.name)
        if (self.isMessageInFolder(mid, DefaultFolderName.spam) && filter.getFolder() == DefaultFolderName.spam) || (self.isMessageInFolder(mid, DefaultFolderName.trash) && filter.getFolder() == DefaultFolderName.trash) {
          return isInContainer
        }
      }
      if container.type == MessageContainerType.withAttachmentsFilter {
        isInContainer = self.isMessageWithAttachment(mid)
      }
    }
    return (isInContainer && !self.isMessageInFolder(mid, DefaultFolderName.trash) && !self.isMessageInFolder(mid, DefaultFolderName.spam))
  }

  @discardableResult
  private func isMessageInFolder(_ mid: MessageId, _ folderName: FolderName) -> Bool {
    return requireNonNull(self.folderToMessages.`get`(folderName)?.has(mid), "Нет такой папки")!
  }

  @discardableResult
  private func isMessageInLabel(_ mid: MessageId, _ labelName: LabelName) -> Bool {
    return requireNonNull(self.labelToMessages.`get`(labelName)?.has(mid), "Нет такой метки")!
  }

  @discardableResult
  private func isMessageInSearchRequest(_ mid: MessageId, _ request: String) -> Bool {
    let msg = undefinedToNull(self.messages.get(mid))
    return (msg!.body.search(request) != -1 || self.isOneOfItemRelevantToRequest(msg!.to, request) || msg!.head.subject.search(request) != -1 || msg!.head.from.search(request) != -1)
  }

  @discardableResult
  private func isMessageImportant(_ mid: MessageId) -> Bool {
    return self.messages.`get`(mid)!.head.important
  }

  @discardableResult
  private func isMessageUnread(_ mid: MessageId) -> Bool {
    return !self.messages.`get`(mid)!.head.read
  }

  @discardableResult
  private func isMessageWithAttachment(_ mid: MessageId) -> Bool {
    return self.messages.`get`(mid)!.head.attachments.length > 0
  }

  @discardableResult
  private func buildMessageIdList(_ msgs: YSArray<MessageId>, _ limit: Int32, _ isInThreadMode: Bool) -> YSArray<MessageId> {
    let sortedMsgs = self.sortMessagesByTimestamp(msgs)
    if !isInThreadMode {
      return sortedMsgs.slice(0, limit)
    }
    let threadedMessages: YSArray<MessageId> = YSArray()
    let currentAddedThreads = YSSet<Int32>()
    for mid in sortedMsgs {
      let threadOrder: Int32! = self.findThread(mid)
      if threadOrder == nil {
        threadedMessages.push(mid)
      } else if !currentAddedThreads.has(threadOrder) {
        threadedMessages.push(mid)
        currentAddedThreads.add(threadOrder)
      }
    }
    return threadedMessages.slice(0, limit)
  }

  @discardableResult
  private func demandFolderMessages(_ folderName: FolderName) -> YSSet<MessageId> {
    let messages = undefinedToNull(self.folderToMessages.get(folderName))
    if messages == nil {
      fail("Модель не знает про папку '\(folderName)'! Сначала ее надо создать.")
    }
    return messages!
  }

  @discardableResult
  private func isOneOfItemRelevantToRequest(_ items: YSSet<String>, _ request: String) -> Bool {
    var isRelevant = false
    let requestToFind = requireNonNull(request, "Необходимо задать запрос для поиска!")
    items.forEach({
      (item) in
      if item.search(requestToFind) != -1 {
        isRelevant = true
      }
    })
    return isRelevant
  }

  @discardableResult
  private func sortMessagesByTimestamp(_ unorderedMsgs: YSArray<MessageId>) -> YSArray<MessageId> {
    unorderedMsgs.sort({
      (mid1, mid2) in
      let diff = int64ToInt32(self.makeMessageThreadView(mid2).mutableHead.timestamp - self.makeMessageThreadView(mid1).mutableHead.timestamp)
      if diff != 0 {
        return diff
      }
      return int64ToInt32(mid1 - mid2)
    })
    return unorderedMsgs
  }

  @discardableResult
  private func findThread(_ mid: MessageId) -> Int32! {
    for i in stride(from: 0, to: self.threads.length, by: 1) {
      if self.threads[i].has(mid) {
        return i
      }
    }
    return nil
  }

  @discardableResult
  private func getMessageListFromIds(_ mids: YSArray<MessageId>, _ isInThreadMode: Bool) -> YSArray<MessageView> {
    return mids.map({
      (mid) in
      isInThreadMode ? self.makeMessageThreadView(mid).copy().head : self.storedMessage(mid).copy().head
    })
  }

  @discardableResult
  private func getMessageHash(_ message: FullMessage) -> Int64 {
    let hashBuilder: HashBuilder = HashBuilder().addString(message.head.from).addBoolean(message.head.read).addString(message.head.subject).addBoolean(message.head.important).addInt64(message.mutableHead.timestamp)
    if message.head.threadCounter != nil {
      hashBuilder.addInt64(int64(message.head.threadCounter!))
    } else {
      hashBuilder.addBoolean(true)
    }
    return hashBuilder.build()
  }

}

open class MessageListDatabaseFilter {
  private var folder: FolderName!
  private var label: LabelName!
  private var excludedFolders: YSArray<FolderName>
  private var container: MessageContainer!
  private var isInThreadMode: Bool
  private var isImportantOnly: Bool
  private var isUnreadOnly: Bool
  private var limit: Int32
  public init() {
    self.folder = nil
    self.label = nil
    self.container = nil
    self.excludedFolders = YSArray()
    self.isInThreadMode = true
    self.limit = 20
    self.isImportantOnly = false
    self.isUnreadOnly = false
  }

  @discardableResult
  open func getIsInThreadMode() -> Bool {
    return self.isInThreadMode
  }

  @discardableResult
  open func withIsInThreadMode(_ value: Bool) -> MessageListDatabaseFilter {
    self.isInThreadMode = value
    return self
  }

  @discardableResult
  open func getIsUnreadOnly() -> Bool {
    return self.isUnreadOnly
  }

  @discardableResult
  open func withIsUnreadOnly() -> MessageListDatabaseFilter {
    self.isUnreadOnly = true
    return self
  }

  @discardableResult
  open func getIsImportantOnly() -> Bool {
    return self.isImportantOnly
  }

  @discardableResult
  open func withIsImportantOnly() -> MessageListDatabaseFilter {
    self.isImportantOnly = true
    return self
  }

  @discardableResult
  open func getContainer() -> MessageContainer! {
    return self.container
  }

  @discardableResult
  open func withContainer(_ value: MessageContainer) -> MessageListDatabaseFilter {
    self.container = value
    return self
  }

  @discardableResult
  open func getExcludedFolders() -> YSArray<FolderName> {
    return self.excludedFolders
  }

  @discardableResult
  open func withExcludedFolders(_ value: YSArray<FolderName>) -> MessageListDatabaseFilter {
    self.excludedFolders = value
    return self
  }

  @discardableResult
  open func getLabel() -> String! {
    return self.label
  }

  @discardableResult
  open func withLabel(_ value: String) -> MessageListDatabaseFilter {
    self.label = value
    return self
  }

  @discardableResult
  open func getFolder() -> FolderName! {
    return self.folder
  }

  @discardableResult
  open func withFolder(_ value: FolderName) -> MessageListDatabaseFilter {
    self.folder = value
    return self
  }

  @discardableResult
  open func withLimit(_ value: Int32) -> MessageListDatabaseFilter {
    self.limit = value
    return self
  }

  @discardableResult
  open func getLimit() -> Int32 {
    return self.limit
  }

}

