// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/model/mail-model.ts >>>

import Foundation

open class ScreenTitle {
  public static let rootSettings: String = "Settings"
  public static let helpAndFeedback: String = "Help and feedback"
  @discardableResult
  open class func folder(_ folder: FolderName, _ unreadCounter: Int32) -> String {
    return "\(folder) \(unreadCounter)"
  }

}

open class Message: MessageView {
  public var from: String
  public var subject: String
  public var timestamp: Int64
  public var firstLine: String
  public var threadCounter: Int32!
  public var read: Bool
  public var important: Bool
  public var attachments: YSArray<AttachmentView>
  public var to: String
  public init(_ from: String, _ subject: String, _ timestamp: Int64, _ firstLine: String, _ threadCounter: Int32! = nil, _ read: Bool = false, _ important: Bool = false, _ attachments: YSArray<AttachmentView> = YSArray(), _ to: String = "(No recipients)") {
    self.from = from
    self.subject = subject
    self.timestamp = timestamp
    self.firstLine = firstLine
    self.threadCounter = threadCounter
    self.read = read
    self.important = important
    self.attachments = attachments
    self.to = to
  }

  @discardableResult
  open class func fromMeta(_ meta: MessageMeta) -> Message {
    return Message(meta.sender, meta.subjectText, meta.timestamp, meta.firstLine, meta.threadCount == nil ? nil : stringToInt32(meta.threadCount!), !meta.unread, meta.lid.includes("7"), meta.attachments == nil ? YSArray() : meta.attachments!.attachments.map({
      (item) in
      MessageAttach.fromMetaAttach(item)
    }))
  }

  @discardableResult
  open class func matches(_ first: MessageView, _ second: MessageView, _ isCompactMode: Bool = false, _ isFull: Bool = false) -> Bool {
    var matchFrom: Bool
    let matchImportant: Bool = isCompactMode ? true : first.important == second.important
    let firstAttachmentsLength: Int32 = first.attachments.length
    let secondAttachmentsLength: Int32 = second.attachments.length
    if first.from.length > second.from.length {
      matchFrom = first.from.includes(second.from)
    } else {
      matchFrom = second.from.includes(first.from)
    }
    if first.subject != second.subject {
      Log.error("Different subjects: \(first.subject), \(second.subject)")
      return false
    }
    if first.read != second.read {
      Log.error("Different read status: \(first.read), \(second.read)")
      return false
    }
    if firstAttachmentsLength != secondAttachmentsLength {
      Log.error("Different attachments length: \(firstAttachmentsLength), \(secondAttachmentsLength)")
      return false
    }
    if first.threadCounter != second.threadCounter {
      Log.error("Different thread counter: \(first.threadCounter), \(second.threadCounter)")
      return false
    }
    if first.firstLine.substr(0, 10) != second.firstLine.substr(0, 10) && !isFull {
      Log.error("Different first line: \(first.firstLine.substr(0, 10)), \(second.firstLine.substr(0, 10))")
      return false
    }
    if !matchImportant {
      Log.error("Different importance status: \(first.important), \(second.important)")
      return false
    }
    if !matchFrom {
      Log.error("Different froms (one must be included into other): \(first.from), \(second.from)")
      return false
    }
    return true
  }

  @discardableResult
  open func threadSize() -> Int32 {
    let counter: Int32! = self.threadCounter
    return counter != nil ? counter : 1
  }

  @discardableResult
  open func tostring() -> String {
    let attachNames: YSArray<String> = self.attachments.map({
      (attach) in
      attach.displayName
    })
    return "MessageView(from=\(self.from), subject=\(self.subject), timestamp=\(self.timestamp), read=\(self.read), important=\(self.important), threadCounter=\(self.threadCounter), firstLine=\(self.firstLine), attachments=\(attachNames))"
  }

  @discardableResult
  open func copy() -> Message {
    return Message(self.from, self.subject, self.timestamp, self.firstLine, self.threadCounter, self.read, self.important, self.attachments, self.to)
  }

}

open class MessageAttach: AttachmentView {
  public let displayName: String
  public init(_ displayName: String) {
    self.displayName = displayName
  }

  @discardableResult
  open class func fromMetaAttach(_ item: Attachment) -> AttachmentView {
    return MessageAttach(item.displayName)
  }

}

open class FullMessage: FullMessageView {
  public let head: MessageView
  public var mutableHead: Message
  public var to: YSSet<String>
  public var body: String
  public var lang: LanguageName
  public let translations: YSMap<LanguageName, String>
  public let quickReply: Bool
  public let smartReplies: YSArray<String>
  public init(_ head: Message, _ to: YSSet<String> = YSSet<String>(), _ body: String = "", _ lang: LanguageName = TranslatorLanguageName.english, _ translations: YSMap<LanguageName, String> = YSMap<LanguageName, String>(), _ quickReply: Bool = false, _ smartReplies: YSArray<String> = YSArray()) {
    self.to = to
    self.body = body
    self.lang = lang
    self.translations = translations
    self.quickReply = quickReply
    self.smartReplies = smartReplies
    self.head = head
    self.mutableHead = head
  }

  @discardableResult
  open class func fromMeta(_ meta: MessageMeta, _ body: String = "", _ lang: LanguageName = TranslatorLanguageName.english, _ translations: YSMap<LanguageName, String> = YSMap<LanguageName, String>(), _ quickReply: Bool = false, _ smartReplies: YSArray<String> = YSArray()) -> FullMessage {
    return FullMessage(Message.fromMeta(meta), YSSet<String>(), body, lang, translations, quickReply, smartReplies)
  }

  @discardableResult
  open class func matches(_ first: FullMessageView, _ second: FullMessageView) -> Bool {
    for to in first.to.values() {
      if !second.to.has(to) {
        Log.error("Different to: \(first.to.values()), \(second.to.values())")
        return false
      }
    }
    if first.body != second.body {
      Log.error("Different body: \(first.body), \(second.body)")
      return false
    }
    return Message.matches(first.head, second.head, false, true)
  }

  @discardableResult
  open func tostring() -> String {
    return "(\(self.head.tostring()), to=\(self.to.values()), body=\(self.body), quickReply=\(self.quickReply), smartReplies=\(self.smartReplies))"
  }

  @discardableResult
  open func copy() -> FullMessage {
    let translationsCopy = YSMap<LanguageName, String>()
    self.translations.__forEach({
      (translation, language) in
      translationsCopy.set(language, translation)
    })
    return FullMessage(self.mutableHead.copy(), self.to, self.body, self.lang, translationsCopy, self.quickReply, self.smartReplies)
  }

}

public typealias MessageId = ID

public typealias FolderId = ID

open class MailAppModelHandler {
  public var accountsManager: AccountsManager
  public var accountsData: YSArray<AccountMailboxData>
  public init(_ accountsData: YSArray<AccountMailboxData>) {
    self.accountsData = accountsData
    self.accountsManager = AccountsManager(accountsData.map({
      (data) in
      data.client.oauthAccount.account
    }))
  }

  open func choseAccountFromAccountsManager(_ account: UserAccount) -> Void {
    self.accountsManager.logInToAccount(account)
  }

  open func logInToAccount(_ account: UserAccount) -> Void {
    self.accountsManager.logInToAccount(account)
  }

  open func revokeToken(_ account: UserAccount) -> Void {
    self.accountsManager.revokeToken(account)
  }

  open func exitFromReloginWindow() -> Void {
    self.accountsManager.exitFromReloginWindow()
  }

  open func switchToAccountByOrder(_ loginOrder: Int32) -> Void {
    self.accountsManager.switchToAccountByOrder(loginOrder)
  }

  open func switchToAccountByLogin(_ login: Login) -> Void {
    self.accountsManager.switchToAccount(login)
  }

  @discardableResult
  open func isLoggedIn() -> Bool {
    return self.accountsManager.isLoggedIn()
  }

  @discardableResult
  open func getCurrentAccount() -> AccountMailboxData {
    if !self.hasCurrentAccount() {
      fail("Account was requested, but is not set")
    }
    return self.accountsData[self.accountsManager.currentAccount!]
  }

  @discardableResult
  open func getCurrentAccountType() -> AccountType2 {
    if !self.hasCurrentAccount() {
      fail("Account was requested, but is not set")
    }
    return self.accountsData[self.accountsManager.currentAccount!].client.oauthAccount.type
  }

  @discardableResult
  open func getLoggedInAccounts() -> YSArray<UserAccount> {
    return self.accountsManager.getLoggedInAccounts()
  }

  @discardableResult
  open func hasCurrentAccount() -> Bool {
    return (self.accountsManager.currentAccount != nil && self.accountsManager.currentAccount! < self.accountsData.length)
  }

  open func logoutAccount(_ login: Login) -> Void {
    self.accountsManager.logoutAccount(login)
  }

  @discardableResult
  open func copy() -> MailAppModelHandler {
    let accountsDataCopy = self.accountsData.map({
      (acc) in
      acc.copy()
    })
    let result = MailAppModelHandler(accountsDataCopy)
    result.accountsManager = self.accountsManager.copy()
    return result
  }

}

open class AccountSettingsModel {
  public var folderToNotificationOption: YSMap<FolderName, NotificationOption>
  public var notificationSound: NotificationSound = NotificationSound.yandexMail
  public var phoneNumber: String = ""
  public var accountUsingEnabled: Bool = true
  public var pushNotificationForAllEnabled: Bool = true
  public var themeEnabled: Bool = true
  private var ignoredFolders: YSArray<FolderName> = YSArray(DefaultFolderName.sent, DefaultFolderName.trash, DefaultFolderName.spam, DefaultFolderName.draft, DefaultFolderName.template, DefaultFolderName.archive, DefaultFolderName.outgoing)
  public var groupBySubjectEnabled: Bool
  public var sortingEmailsByCategoryEnabled: Bool
  public var signature: String
  public var placeForSignature: SignaturePlace
  public var folderList: YSArray<FolderName>
  public init(_ groupBySubjectEnabled: Bool, _ sortingEmailsByCategoryEnabled: Bool, _ signature: String, _ placeForSignature: SignaturePlace, _ folderList: YSArray<FolderName>) {
    self.groupBySubjectEnabled = groupBySubjectEnabled
    self.sortingEmailsByCategoryEnabled = sortingEmailsByCategoryEnabled
    self.signature = signature
    self.placeForSignature = placeForSignature
    self.folderList = folderList
    self.folderToNotificationOption = YSMap<FolderName, NotificationOption>()
    folderList.filter({
      (folderName) in
      !self.ignoredFolders.includes(folderName)
    }).forEach({
      (folderName) in
      self.folderToNotificationOption.set(folderName as! FolderName, NotificationOption.syncAndNotifyMe)
    })
  }

}

open class AccountMailboxData {
  public let client: MailboxClient
  public var messagesDB: MessageListDatabase
  public var defaultEmail: String
  public var aliases: YSArray<String>
  public var contacts: YSArray<Contact>
  public var filters: YSArray<FilterResponseData>
  public var accountSettings: AccountSettingsModel
  public var zeroSuggest: YSArray<String>
  public var translationLangs: YSArray<LanguageName>
  public var promoteMail360: Bool
  public init(_ client: MailboxClient, _ messagesDB: MessageListDatabase, _ defaultEmail: String, _ aliases: YSArray<String>, _ contacts: YSArray<Contact>, _ filters: YSArray<FilterResponseData>, _ accountSettings: AccountSettingsModel, _ zeroSuggest: YSArray<String>, _ translationLangs: YSArray<LanguageName>, _ promoteMail360: Bool) {
    self.client = client
    self.messagesDB = messagesDB
    self.defaultEmail = defaultEmail
    self.aliases = aliases
    self.contacts = contacts
    self.filters = filters
    self.accountSettings = accountSettings
    self.zeroSuggest = zeroSuggest
    self.translationLangs = translationLangs
    self.promoteMail360 = promoteMail360
  }

  @discardableResult
  open func copy() -> AccountMailboxData {
    let accountSettingsCopy = AccountSettingsModel(self.accountSettings.groupBySubjectEnabled, self.accountSettings.sortingEmailsByCategoryEnabled, self.accountSettings.signature, self.accountSettings.placeForSignature, self.accountSettings.folderList)
    let aliasesCopy = copyArray(self.aliases)
    let contactsCopy = copyArray(self.contacts)
    let filtersCopy = copyArray(self.filters)
    let messagesDBCopy = self.messagesDB.copy()
    let zeroSuggestCopy = copyArray(self.zeroSuggest)
    let translationLangsCopy = copyArray(self.translationLangs)
    return AccountMailboxData(self.client, messagesDBCopy, self.defaultEmail, aliasesCopy, contactsCopy, filtersCopy, accountSettingsCopy, zeroSuggestCopy, translationLangsCopy, self.promoteMail360)
  }

}

open class DeviceTypeModel {
  public static let instance: DeviceTypeModel = DeviceTypeModel()
  private var deviceType: DeviceType = DeviceType.Phone
  @discardableResult
  open func getDeviceType() -> DeviceType {
    return self.deviceType
  }

  open func setDeviceType(_ deviceType: DeviceType) -> Void {
    self.deviceType = deviceType
  }

}

open class MailboxModel: AppModel {
  public static var allSupportedFeatures: YSArray<FeatureID> = YSArray(MessageListDisplayFeature.`get`.name, FolderNavigatorFeature.`get`.name, MessageViewerFeature.`get`.name, MessageViewerAndroidFeature.`get`.name, ThreadViewNavigatorFeature.`get`.name, MarkableReadFeature.`get`.name, MarkableImportantFeature.`get`.name, GroupModeFeature.`get`.name, RotatableFeature.`get`.name, ExpandableThreadsModelFeature.`get`.name, ExpandableThreadsFeature.`get`.name, DeleteMessageFeature.`get`.name, SpamableFeature.`get`.name, CreatableFolderFeature.`get`.name, WysiwygFeature.`get`.name, ArchiveMessageFeature.`get`.name, YandexLoginFeature.`get`.name, YandexTeamLoginFeature.`get`.name, MultiAccountFeature.`get`.name, ContextMenuFeature.`get`.name, ShortSwipeFeature.`get`.name, LongSwipeFeature.`get`.name, SearchFeature.`get`.name, AdvancedSearchFeature.`get`.name, ZeroSuggestFeature.`get`.name, CreatableLabelFeature.`get`.name, LabelNavigatorFeature.`get`.name, FilterNavigatorFeature.`get`.name, ContainerGetterFeature.`get`.name, StoriesBlockFeature.`get`.name, AccountSettingsFeature.`get`.name, IosAccountSettingsFeature.`get`.name, AndroidAccountSettingsFeature.`get`.name, AboutSettingsFeature.`get`.name, GeneralSettingsFeature.`get`.name, IosGeneralSettingsFeature.`get`.name, AndroidGeneralSettingsFeature.`get`.name, RootSettingsFeature.`get`.name, IOSRootSettingsFeature.`get`.name, AndroidRootSettingsFeature.`get`.name, UndoFeature.`get`.name, MailRuLoginFeature.`get`.name, GoogleLoginFeature.`get`.name, OutlookLoginFeature.`get`.name, HotmailLoginFeature.`get`.name, RamblerLoginFeature.`get`.name, YahooLoginFeature.`get`.name, CustomMailServiceLoginFeature.`get`.name, PinFeature.`get`.name, ApplicationRunningStateFeature.`get`.name, AccountsListFeature.`get`.name, ExpiringTokenFeature.`get`.name, ManageableFolderFeature.`get`.name, ManageableLabelFeature.`get`.name, TabsFeature.`get`.name, SwitchContext2PaneFeature.`get`.name, TranslatorBarFeature.`get`.name, ValidatorFeature.`get`.name, TranslatorLanguageListFeature.`get`.name, TranslatorLanguageListSearchFeature.`get`.name, TranslatorSettingsFeature.`get`.name, QuickReplyFeature.`get`.name, SmartReplyFeature.`get`.name, ApplyLabelFeature.`get`.name, MoveToFolderFeature.`get`.name, ClearFolderInFolderListFeature.`get`.name, BackendActionsFeature.`get`.name, ShtorkaFeature.`get`.name, ShtorkaIOSFeature.`get`.name, ShtorkaAndroidFeature.`get`.name, TabBarFeature.`get`.name, TabBarIOSFeature.`get`.name, TabBarAndroidFeature.`get`.name, SnapshotValidatingFeature.`get`.name, ComposeRecipientFieldsFeature.`get`.name, ComposeRecipientSuggestFeature.`get`.name, ComposeSenderSuggestFeature.`get`.name, ComposeSubjectFeature.`get`.name, ComposeBodyFeature.`get`.name, ComposeFeature.`get`.name, FiltersListFeature.`get`.name, FilterCreateOrUpdateRuleFeature.`get`.name, FilterConditionLogicFeature.`get`.name, FilterUpdateRuleMoreFeature.`get`.name)
  public var supportedFeatures: YSArray<FeatureID> = copyArray(MailboxModel.allSupportedFeatures)
  public let containerGetter: ContainerGetterModel
  public let messageListDisplay: MessageListDisplayModel
  public let markableRead: MarkableReadModel
  public let markableImportant: MarkableImportantModel
  public let messageNavigator: OpenMessageModel
  public let deletableMessages: DeleteMessageModel
  public let groupMode: GroupModeModel
  public let rotatable: RotatableModel
  public let readOnlyExpandableThreads: ReadOnlyExpandableThreadsModel
  public let expandableThreads: ExpandableThreadsModel
  public let folderNavigator: FolderNavigatorModel
  public let creatableFolder: CreatableFolderModel
  public let wysiwyg: WysiwygModel
  public let login: LoginModel
  public let multiAccount: MultiAccountModel
  public let contextMenu: ContextMenuModel
  public let shortSwipe: ShortSwipeModel
  public let longSwipe: LongSwipeModel
  public let archiveMessage: ArchiveMessageModel
  public let accountSettingsModel: AccountSettingModel
  public let generalSettingsModel: GeneralSettingsModel
  public let rootSettingsModel: RootSettingsModel
  public let aboutSettingsModel: AboutSettingsModel
  public let spammable: SpamableModel
  public let search: SearchModel
  public let advancedSearch: AdvancedSearchModel
  public let zeroSuggest: ZeroSuggestModel
  public let createLabel: LabelModel
  public let manageLabels: ManageLabelsModel
  public let manageFolders: ManageFoldersModel
  public let storiesBlockModel: StoriesBlockModel
  public let undo: UndoModel
  public let pin: PinModel
  public let applicationState: ApplicationRunningStateModel
  public let tabs: TabsModel
  public let accountManager: AccountManagerModel
  public let expiredToken: ExpiringTokenModel
  public let switchContext2Pane: SwitchContextIn2paneModel
  public let translatorBarModel: TranslatorBarModel
  public let translatorLanguageListModel: TranslatorLanguageListModel
  public let translatorLanguageListSearchModel: TranslatorLanguageListSearchModel
  public let translatorSettingsModel: TranslatorSettingsModel
  public let validatorModel: ValidatorModel
  public let quickReplyModel: QuickReplyModel
  public let smartReplyModel: SmartReplyModel
  public let applyLabelModel: ApplyLabelModel
  public let moveToFolderModel: MoveToFolderModel
  public let clearFolderModel: ClearFolderModel
  public let backendActionsModel: BackendActionsModel
  public let shtorkaModel: ShtorkaModel
  public let shtorkaIOSModel: ShtorkaIOSModel
  public let shtorkaAndroidModel: ShtorkaAndroidModel
  public let tabBarModel: TabBarModel
  public let tabBarIOSModel: TabBarIOSModel
  public let tabBarAndroidModel: TabBarAndroidModel
  public let snapshotValidatingModel: SnapshotValidatingModel
  public let composeModel: ComposeModel
  public let filtersListModel: FiltersListModel
  public let filterConditionLogicModel: FilterConditionLogicModel
  public let filterUpdateRuleMoreModel: FilterUpdateRuleMoreModel
  public let filterCreateOrUpdateRuleModel: FilterCreateOrUpdateRuleModel
  public let mailAppModelHandler: MailAppModelHandler
  public init(_ mailAppModelHandler: MailAppModelHandler) {
    self.mailAppModelHandler = mailAppModelHandler
    let accountsSettings: YSArray<AccountSettingsModel> = mailAppModelHandler.accountsData.map({
      (account) in
      return account.accountSettings
    })
    self.messageListDisplay = MessageListDisplayModel(self.mailAppModelHandler)
    self.pin = PinModel()
    self.accountSettingsModel = AccountSettingModel(accountsSettings, self.mailAppModelHandler.accountsManager, self.mailAppModelHandler)
    self.generalSettingsModel = GeneralSettingsModel(self.pin)
    self.aboutSettingsModel = AboutSettingsModel()
    self.rootSettingsModel = RootSettingsModel(self.messageListDisplay, self.mailAppModelHandler.accountsManager)
    self.advancedSearch = AdvancedSearchModel(self.messageListDisplay)
    self.markableRead = MarkableReadModel(self.messageListDisplay, self.mailAppModelHandler)
    self.spammable = SpamableModel(self.messageListDisplay, self.mailAppModelHandler)
    self.storiesBlockModel = StoriesBlockModel()
    self.containerGetter = ContainerGetterModel(self.messageListDisplay)
    self.createLabel = LabelModel(self.mailAppModelHandler)
    self.manageLabels = ManageLabelsModel(self.mailAppModelHandler)
    self.manageFolders = ManageFoldersModel(self.mailAppModelHandler)
    self.archiveMessage = ArchiveMessageModel(self.messageListDisplay, self.mailAppModelHandler)
    self.deletableMessages = DeleteMessageModel(self.messageListDisplay, self.mailAppModelHandler)
    self.undo = UndoModel(self.deletableMessages, self.archiveMessage, self.spammable, self.mailAppModelHandler, self.messageListDisplay)
    self.filtersListModel = FiltersListModel(self.accountSettingsModel)
    self.filterUpdateRuleMoreModel = FilterUpdateRuleMoreModel()
    self.filterConditionLogicModel = FilterConditionLogicModel()
    self.filterCreateOrUpdateRuleModel = FilterCreateOrUpdateRuleModel(self.filterConditionLogicModel)
    self.folderNavigator = FolderNavigatorModel(self.messageListDisplay, self.mailAppModelHandler, self.undo)
    self.markableImportant = MarkableImportantModel(self.messageListDisplay, self.mailAppModelHandler)
    self.rotatable = RotatableModel()
    self.applicationState = ApplicationRunningStateModel()
    self.readOnlyExpandableThreads = ReadOnlyExpandableThreadsModel(self.messageListDisplay, self.mailAppModelHandler)
    self.expandableThreads = ExpandableThreadsModel(self.readOnlyExpandableThreads, self.messageListDisplay)
    self.translatorSettingsModel = TranslatorSettingsModel()
    self.validatorModel = ValidatorModel()
    self.translatorBarModel = TranslatorBarModel(self.translatorSettingsModel)
    self.translatorLanguageListModel = TranslatorLanguageListModel(self.translatorSettingsModel, self.mailAppModelHandler, self.translatorBarModel)
    self.wysiwyg = WysiwygModel()
    self.composeModel = ComposeModel(self.mailAppModelHandler)
    self.quickReplyModel = QuickReplyModel(self.composeModel)
    self.smartReplyModel = SmartReplyModel(self.quickReplyModel, self.generalSettingsModel)
    self.messageNavigator = OpenMessageModel(self.markableImportant, self.expandableThreads, self.messageListDisplay, self.createLabel, self.deletableMessages, self.mailAppModelHandler, self.archiveMessage, self.translatorBarModel, self.translatorLanguageListModel, self.translatorSettingsModel, self.smartReplyModel, self.quickReplyModel)
    self.search = SearchModel(self.messageListDisplay, self.messageNavigator)
    self.zeroSuggest = ZeroSuggestModel(self.mailAppModelHandler, self.search, self.messageListDisplay)
    self.creatableFolder = CreatableFolderModel(self.mailAppModelHandler)
    self.contextMenu = ContextMenuModel(self.deletableMessages, self.markableImportant, self.markableRead, self.mailAppModelHandler, self.messageListDisplay, self.spammable, self.composeModel, self.archiveMessage, self.messageNavigator, self.translatorBarModel)
    self.shortSwipe = ShortSwipeModel(self.deletableMessages, self.archiveMessage, self.markableRead)
    self.longSwipe = LongSwipeModel(self.deletableMessages, self.archiveMessage)
    self.login = LoginModel(mailAppModelHandler, self.messageListDisplay)
    self.multiAccount = MultiAccountModel(mailAppModelHandler)
    self.accountManager = AccountManagerModel(mailAppModelHandler)
    self.expiredToken = ExpiringTokenModel(mailAppModelHandler)
    self.groupMode = GroupModeModel(self.markableRead, self.deletableMessages, self.archiveMessage, self.markableImportant, self.spammable, self.messageListDisplay)
    self.applyLabelModel = ApplyLabelModel(self.mailAppModelHandler, self.messageNavigator, self.contextMenu, self.messageListDisplay, self.groupMode, self.createLabel)
    self.moveToFolderModel = MoveToFolderModel(self.mailAppModelHandler, self.messageNavigator, self.contextMenu, self.messageListDisplay, self.groupMode)
    self.tabs = TabsModel(self.messageListDisplay, self.mailAppModelHandler, self.undo)
    let storiesBlockViewCounter = StoriesBlockViewCounter(self.storiesBlockModel, self.messageListDisplay)
    self.messageListDisplay.attach(storiesBlockViewCounter)
    self.rotatable.attach(storiesBlockViewCounter)
    self.switchContext2Pane = SwitchContextIn2paneModel()
    self.translatorLanguageListSearchModel = TranslatorLanguageListSearchModel(self.translatorLanguageListModel)
    self.clearFolderModel = ClearFolderModel(mailAppModelHandler)
    self.backendActionsModel = BackendActionsModel(mailAppModelHandler, self.creatableFolder, self.createLabel)
    self.tabBarModel = TabBarModel(self.messageListDisplay, self.messageNavigator, self.groupMode, self.zeroSuggest, self.rootSettingsModel, self.composeModel, self.folderNavigator, DeviceTypeModel.instance)
    self.tabBarIOSModel = TabBarIOSModel(mailAppModelHandler)
    self.tabBarAndroidModel = TabBarAndroidModel(mailAppModelHandler)
    self.shtorkaModel = ShtorkaModel(mailAppModelHandler, self.tabBarModel)
    self.shtorkaIOSModel = ShtorkaIOSModel()
    self.shtorkaAndroidModel = ShtorkaAndroidModel()
    self.snapshotValidatingModel = SnapshotValidatingModel()
  }

  @discardableResult
  open func getFeature(_ feature: FeatureID) -> Any {
    return FeatureRegistry().register(MessageListDisplayFeature.`get`, self.messageListDisplay).register(FolderNavigatorFeature.`get`, self.folderNavigator).register(MessageViewerFeature.`get`, self.messageNavigator).register(MessageViewerAndroidFeature.`get`, self.messageNavigator).register(ThreadViewNavigatorFeature.`get`, self.messageNavigator).register(MarkableReadFeature.`get`, self.markableRead).register(MarkableImportantFeature.`get`, self.markableImportant).register(GroupModeFeature.`get`, self.groupMode).register(RotatableFeature.`get`, self.rotatable).register(ExpandableThreadsModelFeature.`get`, self.readOnlyExpandableThreads).register(ExpandableThreadsFeature.`get`, self.expandableThreads).register(DeleteMessageFeature.`get`, self.deletableMessages).register(SpamableFeature.`get`, self.spammable).register(CreatableFolderFeature.`get`, self.creatableFolder).register(WysiwygFeature.`get`, self.wysiwyg).register(YandexLoginFeature.`get`, self.login).register(YandexTeamLoginFeature.`get`, self.login).register(ContextMenuFeature.`get`, self.contextMenu).register(ShortSwipeFeature.`get`, self.shortSwipe).register(LongSwipeFeature.`get`, self.longSwipe).register(ArchiveMessageFeature.`get`, self.archiveMessage).register(UndoFeature.`get`, self.undo).register(MultiAccountFeature.`get`, self.multiAccount).register(SearchFeature.`get`, self.search).register(AdvancedSearchFeature.`get`, self.advancedSearch).register(ZeroSuggestFeature.`get`, self.zeroSuggest).register(CreatableLabelFeature.`get`, self.createLabel).register(LabelNavigatorFeature.`get`, self.folderNavigator).register(FilterNavigatorFeature.`get`, self.folderNavigator).register(ContainerGetterFeature.`get`, self.containerGetter).register(AccountSettingsFeature.`get`, self.accountSettingsModel).register(IosAccountSettingsFeature.`get`, self.accountSettingsModel).register(AndroidAccountSettingsFeature.`get`, self.accountSettingsModel).register(AboutSettingsFeature.`get`, self.aboutSettingsModel).register(GeneralSettingsFeature.`get`, self.generalSettingsModel).register(IosGeneralSettingsFeature.`get`, self.generalSettingsModel).register(AndroidGeneralSettingsFeature.`get`, self.generalSettingsModel).register(RootSettingsFeature.`get`, self.rootSettingsModel).register(IOSRootSettingsFeature.`get`, self.rootSettingsModel).register(AndroidRootSettingsFeature.`get`, self.rootSettingsModel).register(StoriesBlockFeature.`get`, self.storiesBlockModel).register(MailRuLoginFeature.`get`, self.login).register(GoogleLoginFeature.`get`, self.login).register(OutlookLoginFeature.`get`, self.login).register(HotmailLoginFeature.`get`, self.login).register(RamblerLoginFeature.`get`, self.login).register(YahooLoginFeature.`get`, self.login).register(CustomMailServiceLoginFeature.`get`, self.login).register(PinFeature.`get`, self.pin).register(ApplicationRunningStateFeature.`get`, self.applicationState).register(ManageableFolderFeature.`get`, self.manageFolders).register(ManageableLabelFeature.`get`, self.manageLabels).register(TabsFeature.`get`, self.tabs).register(AccountsListFeature.`get`, self.accountManager).register(ExpiringTokenFeature.`get`, self.expiredToken).register(SwitchContext2PaneFeature.`get`, self.switchContext2Pane).register(TranslatorBarFeature.`get`, self.translatorBarModel).register(ValidatorFeature.`get`, self.validatorModel).register(TranslatorLanguageListFeature.`get`, self.translatorLanguageListModel).register(TranslatorLanguageListSearchFeature.`get`, self.translatorLanguageListSearchModel).register(TranslatorSettingsFeature.`get`, self.translatorSettingsModel).register(QuickReplyFeature.`get`, self.quickReplyModel).register(SmartReplyFeature.`get`, self.smartReplyModel).register(ApplyLabelFeature.`get`, self.applyLabelModel).register(MoveToFolderFeature.`get`, self.moveToFolderModel).register(ClearFolderInFolderListFeature.`get`, self.clearFolderModel).register(BackendActionsFeature.`get`, self.backendActionsModel).register(TabBarFeature.`get`, self.tabBarModel).register(TabBarIOSFeature.`get`, self.tabBarIOSModel).register(TabBarAndroidFeature.`get`, self.tabBarAndroidModel).register(ShtorkaFeature.`get`, self.shtorkaModel).register(ShtorkaIOSFeature.`get`, self.shtorkaIOSModel).register(ShtorkaAndroidFeature.`get`, self.shtorkaAndroidModel).register(SnapshotValidatingFeature.`get`, self.snapshotValidatingModel).register(ComposeRecipientFieldsFeature.`get`, self.composeModel).register(ComposeRecipientSuggestFeature.`get`, self.composeModel).register(ComposeSenderSuggestFeature.`get`, self.composeModel).register(ComposeSubjectFeature.`get`, self.composeModel).register(ComposeBodyFeature.`get`, self.composeModel).register(ComposeFeature.`get`, self.composeModel).register(FilterCreateOrUpdateRuleFeature.`get`, self.filterCreateOrUpdateRuleModel).register(FiltersListFeature.`get`, self.filtersListModel).`get`(feature)
  }

  @discardableResult
  open func copy() -> AppModel {
    let accountDataHandlerCopy = self.mailAppModelHandler.copy()
    let model: MailboxModel = MailboxModel(accountDataHandlerCopy)
    model.supportedFeatures = self.supportedFeatures
    model.messageNavigator.openedMessage = self.messageNavigator.openedMessage
    model.rotatable.landscape = self.rotatable.landscape
    if self.groupMode.selectedOrders != nil {
      model.groupMode.selectedOrders = copySet(self.groupMode.selectedOrders)
    }
    for id in self.readOnlyExpandableThreads.expanded.values() {
      model.readOnlyExpandableThreads.expanded.add(id)
    }
    return model
  }

  @discardableResult
  open func getCurrentStateHash() -> Int64 {
    return MailboxModelHasher().getMailboxModelHash(self)
  }

  @discardableResult
  open func dump(_ model: App) -> String {
    var s = ""
    if !self.messageListDisplay.accountDataHandler.hasCurrentAccount() {
      return "There is no logged in account"
    }
    let threadMids = self.messageListDisplay.getMessageIdList(10)
    s += "\(self.messageListDisplay.getCurrentContainer().name)\n"
    for i in stride(from: 0, to: threadMids.length, by: 1) {
      let threadMid = threadMids[i]
      if self.messageListDisplay.isInThreadMode() {
        let thread = self.mailAppModelHandler.getCurrentAccount().messagesDB.makeMessageThreadView(threadMid)
        let msgHead = thread.mutableHead
        let threadSelector = msgHead.threadCounter != nil ? "\(msgHead.threadCounter!)v" : ""
        s += "\(reduced(threadMid)) \(msgHead.from)\t\(msgHead.read ? "o" : "*")" + "\t\(msgHead.subject)\t\(threadSelector)\t\(msgHead.timestamp)\n"
        if msgHead.threadCounter != nil {
          for mid in self.mailAppModelHandler.getCurrentAccount().messagesDB.getMessagesInThreadByMid(threadMid) {
            s += self.dumpMessage(mid)
          }
        }
      } else {
        s += self.dumpMessage(threadMid)
      }
    }
    return s
  }

  @discardableResult
  private func dumpMessage(_ mid: MessageId) -> String {
    let messagesDB = self.mailAppModelHandler.getCurrentAccount().messagesDB
    let message = messagesDB.storedMessage(mid)
    return ("\t\t\(reduced(mid)) \(message.head.from)\t\(message.head.read ? "o" : "*")\t\(message.head.subject)" + "\t\(messagesDB.storedFolder(mid))\t\(message.mutableHead.timestamp)" + "\t\(setToArray(messagesDB.getMessageLabels(mid)).join(","))\n")
  }

}

