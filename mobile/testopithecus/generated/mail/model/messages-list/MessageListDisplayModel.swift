// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/model/messages-list/message-list-display-model.ts >>>

import Foundation

open class MessageListDisplayModel: MessageListDisplay {
  private var currentContainer: MessageContainer = MessageContainer(DefaultFolderName.inbox, MessageContainerType.folder)
  private var listeners: YSArray<ContainerListener> = YSArray()
  public var messageListFilter: MessageListDatabaseFilter
  public var accountDataHandler: MailAppModelHandler
  public init(_ accountDataHandler: MailAppModelHandler) {
    self.accountDataHandler = accountDataHandler
    self.messageListFilter = MessageListDatabaseFilter()
  }

  @discardableResult
  open func getCurrentContainer() -> MessageContainer {
    return self.currentContainer
  }

  open func setCurrentContainer(_ container: MessageContainer) -> Void {
    self.currentContainer = container
    self.messageListFilter = MessageListDatabaseFilter()
    self.notifyContainerChanged()
  }

  open func attach(_ listener: ContainerListener) -> Void {
    self.listeners.push(listener)
  }

  open func notifyContainerChanged() -> Void {
    for listener in self.listeners {
      listener.containerChanged(self.currentContainer)
    }
  }

  @discardableResult
  open func getMessageList(_ limit: Int32) throws -> YSArray<MessageView> {
    let messageList = self.accountDataHandler.getCurrentAccount().messagesDB.getMessageList(self.messageListFilter.withContainer(self.currentContainer).withIsInThreadMode(self.isInThreadMode()).withLimit(limit))
    if self.currentContainer.name == DefaultFolderName.sent || self.currentContainer.name == DefaultFolderName.draft {
      for i in stride(from: 0, to: messageList.length, by: 1) {
        messageList[i].from = messageList[i].to
      }
    }
    if self.isInThreadMode() {
      return messageList
    }
    for i in stride(from: 0, to: messageList.length, by: 1) {
      messageList[i].threadCounter = nil
    }
    return messageList
  }

  @discardableResult
  open func getMessageIdList(_ limit: Int32) -> YSArray<MessageId> {
    return self.accountDataHandler.getCurrentAccount().messagesDB.getMessageIdList(self.messageListFilter.withContainer(self.currentContainer).withIsInThreadMode(self.isInThreadMode()).withLimit(limit))
  }

  @discardableResult
  open func refreshMessageList() throws -> Void {
    return
  }

  @discardableResult
  open func swipeDownMessageList() throws -> Void {
    return
  }

  @discardableResult
  open func unreadCounter() throws -> Int32 {
    fatalError("Not implemented")
  }

  @discardableResult
  open func getMessageId(_ order: Int32) -> MessageId {
    let messageIds = self.getMessageIdList(order + 1)
    if order >= messageIds.length {
      fail("No message with order \(order)")
    }
    return messageIds[order]
  }

  @discardableResult
  open func isInThreadMode() -> Bool {
    let notThreadableFolders: YSArray<String> = YSArray(DefaultFolderName.outgoing, DefaultFolderName.draft, DefaultFolderName.trash, DefaultFolderName.spam, DefaultFolderName.archive)
    if self.currentContainer.type == MessageContainerType.folder && notThreadableFolders.includes(self.getCurrentContainer().name) {
      return false
    }
    if YSArray(MessageContainerType.search, MessageContainerType.unreadFilter, MessageContainerType.importantFilter, MessageContainerType.label).includes(self.currentContainer.type) {
      return false
    }
    return self.accountDataHandler.getCurrentAccount().accountSettings.groupBySubjectEnabled
  }

  @discardableResult
  open func isInTabsMode() -> Bool {
    return self.accountDataHandler.getCurrentAccount().accountSettings.sortingEmailsByCategoryEnabled
  }

  @discardableResult
  open func getMidsByOrders(_ orders: YSSet<Int32>) -> YSArray<MessageId> {
    let mids: YSArray<MessageId> = YSArray()
    let messageListMids: YSArray<MessageId> = YSArray()
    orders.forEach({
      (order) in
      messageListMids.push(self.getMessageId(order))
    })
    for messageListMid in messageListMids {
      for mid in self.accountDataHandler.getCurrentAccount().messagesDB.getMessagesInThreadByMid(messageListMid) {
        mids.push(mid)
      }
    }
    return mids
  }

  @discardableResult
  open func getThreadByOrder(_ order: Int32) -> YSArray<MessageId> {
    if !self.isInThreadMode() {
      return YSArray(self.getMessageId(order))
    }
    return self.accountDataHandler.getCurrentAccount().messagesDB.getMessagesInThreadByMid(self.getMessageId(order))
  }

}

public protocol ContainerListener {
  func containerChanged(_ container: MessageContainer) -> Void
}

