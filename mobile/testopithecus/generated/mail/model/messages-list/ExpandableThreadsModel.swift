// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/model/messages-list/expandable-threads-model.ts >>>

import Foundation

open class ReadOnlyExpandableThreadsModel: ReadOnlyExpandableThreads {
  public var expanded: YSSet<MessageId> = YSSet<MessageId>()
  private var messageListDisplay: MessageListDisplayModel
  private var accHandler: MailAppModelHandler
  public init(_ messageListDisplay: MessageListDisplayModel, _ accHandler: MailAppModelHandler) {
    self.messageListDisplay = messageListDisplay
    self.accHandler = accHandler
  }

  @discardableResult
  open func isExpanded(_ threadOrder: Int32) throws -> Bool {
    let mid = self.messageListDisplay.getMessageId(threadOrder)
    return self.expanded.has(mid)
  }

  @discardableResult
  open func isRead(_ threadOrder: Int32, _ messageOrder: Int32) throws -> Bool {
    return self.getThreadMessage(threadOrder, messageOrder).head.read
  }

  @discardableResult
  open func getMessagesInThread(_ threadOrder: Int32) throws -> YSArray<MessageView> {
    return self.accHandler.getCurrentAccount().messagesDB.getMessagesInThreadByMid(self.messageListDisplay.getMessageId(threadOrder)).map({
      (mid) in
      self.accHandler.getCurrentAccount().messagesDB.storedMessage(mid).head
    })
  }

  @discardableResult
  open func getThreadMessage(_ threadOrder: Int32, _ messageOrder: Int32) -> FullMessage {
    let mid = self.getMessagesInThreadByOrder(threadOrder)[messageOrder]
    return self.accHandler.getCurrentAccount().messagesDB.storedMessage(mid)
  }

  @discardableResult
  private func getMessagesInThreadByOrder(_ threadOrder: Int32) -> YSArray<MessageId> {
    let mid = self.messageListDisplay.getMessageId(threadOrder)
    return self.accHandler.getCurrentAccount().messagesDB.getMessagesInThreadByMid(mid)
  }

}

open class ExpandableThreadsModel: ExpandableThreads {
  private var readonlyExpandableThreads: ReadOnlyExpandableThreadsModel
  private var messageListDisplay: MessageListDisplayModel
  public init(_ readonlyExpandableThreads: ReadOnlyExpandableThreadsModel, _ messageListDisplay: MessageListDisplayModel) {
    self.readonlyExpandableThreads = readonlyExpandableThreads
    self.messageListDisplay = messageListDisplay
  }

  @discardableResult
  open func markThreadMessageAsRead(_ threadOrder: Int32, _ messageOrder: Int32) throws -> Void {
    self.readonlyExpandableThreads.getThreadMessage(threadOrder, messageOrder).mutableHead.read = true
  }

  @discardableResult
  open func markThreadMessageAsUnRead(_ threadOrder: Int32, _ messageOrder: Int32) throws -> Void {
    self.readonlyExpandableThreads.getThreadMessage(threadOrder, messageOrder).mutableHead.read = false
  }

  open func markThreadMessageAsImportant(_ threadOrder: Int32, _ messageOrder: Int32) -> Void {
    self.readonlyExpandableThreads.getThreadMessage(threadOrder, messageOrder).mutableHead.important = true
  }

  open func markThreadMessageAsUnimportant(_ threadOrder: Int32, _ messageOrder: Int32) -> Void {
    self.readonlyExpandableThreads.getThreadMessage(threadOrder, messageOrder).mutableHead.important = false
  }

  @discardableResult
  open func expandThread(_ order: Int32) throws -> Void {
    let mid = self.messageListDisplay.getMessageId(order)
    self.readonlyExpandableThreads.expanded.add(mid)
  }

  @discardableResult
  open func collapseThread(_ order: Int32) throws -> Void {
    let mid = self.messageListDisplay.getMessageId(order)
    self.readonlyExpandableThreads.expanded.delete(mid)
  }

}

