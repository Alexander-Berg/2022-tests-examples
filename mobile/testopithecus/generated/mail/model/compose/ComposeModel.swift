// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/model/compose/compose-model.ts >>>

import Foundation

open class ComposeConstants {
  public static let forwardWrapperStartMessage: String = "-------- Beginning of forwarded message -------- "
  public static let forwardWrapperEndMessage: String = "-------- End of forwarded message --------"
}

open class ComposeModel: Compose, ComposeRecipientFields, ComposeRecipientSuggest, ComposeSenderSuggest, ComposeSubject, ComposeBody {
  private var to: YSArray<Yabble> = YSArray()
  private var cc: YSArray<Yabble> = YSArray()
  private var bcc: YSArray<Yabble> = YSArray()
  private var subject: String = ""
  private var body: String = ""
  private var from: String = ""
  private var contacts: YSArray<Contact> = YSArray()
  private var aliases: YSArray<String> = YSArray()
  private var attachments: YSArray<ComposeAttachment> = YSArray()
  private var reOrFwdContent: String = ""
  private var composeType: ComposeType = ComposeType.clean
  private var extendedRecipientFormShown: Bool = false
  private var recipientSuggestShown: Bool = false
  private var senderSuggestShown: Bool = false
  private var composeOpened: Bool = false
  private var composeEmailProvider: ComposeEmailProvider = ComposeEmailProvider.instance
  private var focusedField: ComposeFieldType! = ComposeFieldType.to
  private var midOfRepliedOrForwarderMessage: MessageId! = nil
  private var isBodyCleared: Bool = false
  private var domains: YSArray<String> = YSArray("yandex.ru", "yahoo.com", "gmail.com", "mail.ru", "rambler.ru", "icloud.com", "qip.ru", "bk.ru", "inbox.ru")
  private let mailAppModelHandler: MailAppModelHandler
  public init(_ mailAppModelHandler: MailAppModelHandler) {
    self.mailAppModelHandler = mailAppModelHandler
  }

  @discardableResult
  open func openCompose() throws -> Void {
    self.body = "\n\n\(self.getSignature())"
    self.contacts = self.mailAppModelHandler.getCurrentAccount().contacts
    self.aliases = self.mailAppModelHandler.getCurrentAccount().aliases
    self.from = self.mailAppModelHandler.getCurrentAccount().defaultEmail
    self.composeOpened = true
  }

  @discardableResult
  open func isSendButtonEnabled() throws -> Bool {
    let allRecipients = self.allRecipients()
    let validYabbles = allRecipients.filter({
      (yabble) in
      YSArray(YabbleType.manual, YabbleType.suggested).includes(yabble.type)
    })
    let invalidYabbles = allRecipients.filter({
      (yabble) in
      yabble.type == YabbleType.invalid
    })
    return validYabbles.length > 0 && invalidYabbles.length == 0
  }

  @discardableResult
  private func createYabbleFromEmail(_ fullEmail: String) -> Yabble {
    if fullEmail.includes("<") {
      let email = fullEmail.slice(fullEmail.indexOf("<") + 1, fullEmail.indexOf(">"))
      let name = fullEmail.slice(fullEmail.indexOf("\"") + 1, fullEmail.lastIndexOf("\""))
      return Yabble(email, name, YabbleType.suggested)
    }
    return Yabble(fullEmail, fullEmail, YabbleType.suggested)
  }

  @discardableResult
  private func parseNumberToDateAndFormat(_ ts: Int64) -> String {
    let date = YSDate(int64ToDouble(ts))
    let year = date.getFullYear()
    let month = self.formatDatePartIfNeeded(date.getMonth() + 1)
    let day = self.formatDatePartIfNeeded(date.getDate())
    let hours = self.formatDatePartIfNeeded(date.getHours())
    let minutes = self.formatDatePartIfNeeded(date.getMinutes())
    return "\(day).\(month).\(year), \(hours):\(minutes)"
  }

  @discardableResult
  private func formatDatePartIfNeeded(_ datePart: Int32) -> String {
    return datePart < 10 ? "0\(datePart)" : "\(datePart)"
  }

  private func setFieldsForReply(_ mid: MessageId) -> Void {
    let message = self.getMessageByMid(mid)
    let date = self.parseNumberToDateAndFormat(message.head.timestamp)
    let from = message.head.from
    self.reOrFwdContent = "\n\n\(date), \(from):\n\(message.body)"
    self.body = "\n\n\(self.getSignature())\(self.reOrFwdContent)"
    self.subject = "Re: \(message.head.subject)"
    self.midOfRepliedOrForwarderMessage = mid
    self.to = YSArray(self.createYabbleFromEmail(message.head.from))
  }

  @discardableResult
  private func getMessageByMid(_ mid: MessageId) -> FullMessageView {
    return self.mailAppModelHandler.getCurrentAccount().messagesDB.storedMessage(mid, nil)
  }

  @discardableResult
  open func openReplyCompose(_ mid: MessageId) throws -> Void {
    (try self.openCompose())
    self.setFieldsForReply(mid)
    self.composeType = ComposeType.reply
  }

  @discardableResult
  open func openReplyAllCompose(_ mid: MessageId) throws -> Void {
    (try self.openCompose())
    self.setFieldsForReply(mid)
    self.composeType = ComposeType.replyAll
  }

  @discardableResult
  open func openForwardCompose(_ mid: MessageId) throws -> Void {
    (try self.openCompose())
    let message = self.getMessageByMid(mid)
    let date = self.parseNumberToDateAndFormat(message.head.timestamp)
    self.subject = "Fwd: \(message.head.subject)"
    self.reOrFwdContent = "\n\n\(ComposeConstants.forwardWrapperStartMessage)\n\(date), \(message.head.from):\n" + "\(message.body)\n\n\n\(ComposeConstants.forwardWrapperEndMessage)"
    self.body = "\n\n\(self.getSignature())\(self.reOrFwdContent)"
    self.composeType = ComposeType.forward
    self.midOfRepliedOrForwarderMessage = mid
  }

  @discardableResult
  open func closeCompose(_ saveDraft: Bool) throws -> Void {
    if saveDraft {
      (try self.saveMessage())
    }
    self.dropFields()
    self.composeOpened = false
  }

  @discardableResult
  open func isComposeOpened() throws -> Bool {
    return self.composeOpened
  }

  @discardableResult
  open func sendMessage() throws -> Void {
    let isReOrFwd = self.composeType != ComposeType.clean
    if isReOrFwd {
      let mid = requireNonNull(self.midOfRepliedOrForwarderMessage, "Mid should be no null")
      let message = self.getMessageByMid(mid)
      let threadCounter = message.head.threadCounter == nil ? 1 : message.head.threadCounter
      let sentMsgMid: MessageId = self.createSentMessage(threadCounter!)
      self.mailAppModelHandler.getCurrentAccount().messagesDB.addThreadMessagesToThreadWithMid(YSArray(sentMsgMid), mid)
    } else {
      self.createSentMessage(0)
    }
    (try self.closeCompose(false))
  }

  @discardableResult
  private func saveMessage() throws -> Void {
    let isReOrFwd = self.composeType != ComposeType.clean
    if isReOrFwd {
      let mid = requireNonNull(self.midOfRepliedOrForwarderMessage, "Mid should be non null")
      let message = self.getMessageByMid(mid)
      let threadSize = message.head.threadCounter == nil ? 1 : message.head.threadCounter
      let draftMsgMid: MessageId = self.createDraftMessage(threadSize!)
      self.mailAppModelHandler.getCurrentAccount().messagesDB.addThreadMessagesToThreadWithMid(YSArray(draftMsgMid), mid)
    } else {
      self.createDraftMessage(0)
    }
  }

  @discardableResult
  private func createDraftMessage(_ threadSize: Int32) -> MessageId {
    let draftMessage = self.getDraft().toFullMessage(threadSize + 1, true)
    let messagesDB = self.mailAppModelHandler.getCurrentAccount().messagesDB
    let draftMsgMid = int64(messagesDB.getMessages().length + 1)
    messagesDB.addMessage(draftMsgMid, draftMessage, DefaultFolderName.draft)
    return draftMsgMid
  }

  @discardableResult
  private func isMessageToYourself() -> Bool {
    let allRecipientEmails = self.allRecipients().map({
      (to) in
      formatLogin(to.email)
    })
    return (self.aliases.filter({
      (alias) in
      allRecipientEmails.includes(alias)
    }).length > 0 || allRecipientEmails.includes(self.from))
  }

  @discardableResult
  private func createSentMessage(_ threadSize: Int32) -> MessageId {
    let sentMessage = self.getDraft().toFullMessage(threadSize + 1, true)
    let messagesDB = self.mailAppModelHandler.getCurrentAccount().messagesDB
    let sentMsgMid = int64(messagesDB.getMessages().length + 1)
    messagesDB.addMessage(sentMsgMid, sentMessage, DefaultFolderName.sent)
    if self.isMessageToYourself() {
      let receivedMsgMid = int64(messagesDB.getMessages().length + 1)
      let receivedMessage = self.getDraft().toFullMessage(threadSize + 2, false)
      messagesDB.addMessage(receivedMsgMid, receivedMessage, DefaultFolderName.inbox)
      messagesDB.addThread(YSArray(sentMsgMid, receivedMsgMid))
    }
    return sentMsgMid
  }

  private func dropFields() -> Void {
    self.to = YSArray()
    self.cc = YSArray()
    self.bcc = YSArray()
    self.subject = ""
    self.body = ""
    self.from = ""
    self.extendedRecipientFormShown = false
    self.recipientSuggestShown = false
    self.senderSuggestShown = false
    self.focusedField = ComposeFieldType.to
    self.reOrFwdContent = ""
    self.midOfRepliedOrForwarderMessage = nil
  }

  @discardableResult
  open func getDraft() -> Draft {
    return Draft(self.to, self.cc, self.bcc, self.from, self.subject, self.body, self.attachments)
  }

  @discardableResult
  open func deleteRecipientByTapOnCross(_ field: ComposeRecipientFieldType, _ index: Int32) throws -> Void {
    self.deleteRecipientByIndex(field, index)
  }

  @discardableResult
  open func deleteLastRecipientByTapOnBackspace(_ field: ComposeRecipientFieldType) throws -> Void {
    let recipients = (try self.getRecipientFieldValue(field))
    self.deleteRecipientByIndex(field, recipients.length - 1)
  }

  private func deleteRecipientByIndex(_ field: ComposeRecipientFieldType, _ index: Int32) -> Void {
    switch field {
      case ComposeRecipientFieldType.to:
        self.to.splice(index, 1)
      case ComposeRecipientFieldType.cc:
        self.cc.splice(index, 1)
      case ComposeRecipientFieldType.bcc:
        self.bcc.splice(index, 1)
    }
    self.recipientSuggestShown = false
  }

  @discardableResult
  open func expandExtendedRecipientForm() throws -> Void {
    self.extendedRecipientFormShown = true
    self.recipientSuggestShown = false
  }

  @discardableResult
  open func getRecipientFieldValue(_ field: ComposeRecipientFieldType) throws -> YSArray<Yabble> {
    switch field {
      case ComposeRecipientFieldType.to:
        return self.to
      case ComposeRecipientFieldType.cc:
        return self.cc
      case ComposeRecipientFieldType.bcc:
        return self.bcc
    }
  }

  @discardableResult
  open func getCompactRecipientFieldValue() throws -> String {
    let allEnteredEmails = self.allRecipients()
    let allEnteredEmailsLength = allEnteredEmails.length
    return allEnteredEmailsLength == 0 ? "" : allEnteredEmailsLength == 1 ? "\(allEnteredEmails[0].emailOrName())" : "\(allEnteredEmails[0].emailOrName()) and \(allEnteredEmailsLength - 1) more"
  }

  @discardableResult
  open func getFocusedField() -> ComposeFieldType! {
    return self.focusedField
  }

  @discardableResult
  open func tapOnRecipient(_ field: ComposeRecipientFieldType, _ index: Int32) throws -> Void {
    var recipientsList: YSArray<Yabble> = YSArray()
    switch field {
      case ComposeRecipientFieldType.to:
        recipientsList = self.to
      case ComposeRecipientFieldType.cc:
        recipientsList = self.cc
      case ComposeRecipientFieldType.bcc:
        recipientsList = self.bcc
    }
    if recipientsList.length <= index {
      fail("There is no recipient in field \(field.toString()) with index \(index)")
      return
    }
    recipientsList[index].isActive = true
  }

  @discardableResult
  open func getSenderFieldValue() throws -> String {
    return self.from
  }

  @discardableResult
  open func isExtendedRecipientFormShown() throws -> Bool {
    return self.extendedRecipientFormShown
  }

  @discardableResult
  open func minimizeExtendedRecipientForm() throws -> Void {
    self.extendedRecipientFormShown = false
    self.recipientSuggestShown = false
  }

  @discardableResult
  open func getNotGeneratedYabble() throws -> Yabble! {
    let newYabbles = self.allRecipients().filter({
      (yabble) in
      yabble.type == YabbleType.new
    })
    let newYabblesLength = newYabbles.length
    if newYabblesLength > 1 {
      throw YSError("There are \(newYabblesLength) new yabbles. Max = 1")
    }
    return newYabblesLength == 0 ? nil : newYabbles[0]
  }

  @discardableResult
  open func pasteToRecipientField(_ field: ComposeRecipientFieldType, _ value: String, _ generateYabble: Bool) throws -> Void {
    (try self.setRecipientField(field, value, generateYabble))
  }

  @discardableResult
  open func setRecipientField(_ field: ComposeRecipientFieldType, _ value: String, _ generateYabble: Bool) throws -> Void {
    self.addYabble(field, Yabble(value, "", self.getYabbleType(value, generateYabble)))
  }

  @discardableResult
  private func isEmailValid(_ value: String) -> Bool {
    return (self.composeEmailProvider.validEmails.includes(value) || self.from == formatLogin(value) || self.aliases.includes(formatLogin(value)))
  }

  @discardableResult
  private func getYabbleType(_ value: String, _ generateYabble: Bool) -> YabbleType {
    return !generateYabble ? YabbleType.new : self.isEmailValid(value) ? YabbleType.manual : YabbleType.invalid
  }

  @discardableResult
  private func allRecipients() -> YSArray<Yabble> {
    return self.to.concat(self.cc).concat(self.bcc)
  }

  @discardableResult
  private func allEmailsEnteredToRecipientsFields() -> YSArray<String> {
    return self.allRecipients().map({
      (yabble) in
      yabble.email
    })
  }

  private func generateYabbleIfNeeded() -> Void {
    let notGeneratedYabbles = self.allRecipients().filter({
      (yabble) in
      yabble.type == YabbleType.new
    })
    let notGeneratedYabblesLength = notGeneratedYabbles.length
    if notGeneratedYabblesLength > 1 {
      fail("There are \(notGeneratedYabblesLength) new yabbles. Max = 1")
    }
    notGeneratedYabbles.forEach({
      (yabble) in
      yabble.type = self.isEmailValid(yabble.email) ? YabbleType.manual : YabbleType.invalid
      yabble.email = self.isEmailValid(yabble.email) ? self.formatValidEmail(yabble.email) : yabble.email
    })
  }

  @discardableResult
  open func generateYabbleByTapOnEnter() throws -> Void {
    self.generateYabbleIfNeeded()
    self.recipientSuggestShown = false
  }

  @discardableResult
  open func tapOnRecipientField(_ field: ComposeRecipientFieldType) throws -> Void {
    self.recipientSuggestShown = !self.recipientSuggestShown
    if YSArray(ComposeFieldType.subject, ComposeFieldType.body, nil).includes(self.focusedField) && self.allRecipients().length > 0 && !self.extendedRecipientFormShown && field == ComposeRecipientFieldType.to {
      self.extendedRecipientFormShown = true
    }
    if self.focusedField != self.recipientFieldTypeToComposeFieldType(field) {
      self.focusedField = self.recipientFieldTypeToComposeFieldType(field)
      self.generateYabbleIfNeeded()
    }
  }

  @discardableResult
  private func recipientFieldTypeToComposeFieldType(_ field: ComposeRecipientFieldType) -> ComposeFieldType {
    switch field {
      case ComposeRecipientFieldType.to:
        return ComposeFieldType.to
      case ComposeRecipientFieldType.cc:
        return ComposeFieldType.cc
      case ComposeRecipientFieldType.bcc:
        return ComposeFieldType.bcc
    }
  }

  @discardableResult
  private func composeFieldTypeToRecipientFieldType(_ field: ComposeFieldType) throws -> ComposeRecipientFieldType {
    switch field {
      case ComposeFieldType.to:
        return ComposeRecipientFieldType.to
      case ComposeFieldType.cc:
        return ComposeRecipientFieldType.cc
      case ComposeFieldType.bcc:
        return ComposeRecipientFieldType.bcc
      default:
        throw YSError("There is no equivalent for ComposeFieldType.\(field.toString()) in ComposeRecipientFieldType enum")
    }
  }

  @discardableResult
  open func tapOnSenderField() throws -> Void {
    self.senderSuggestShown = !self.senderSuggestShown
    self.recipientSuggestShown = false
  }

  @discardableResult
  open func getRecipientSuggest() throws -> YSArray<Contact> {
    let filledRecipients = self.allEmailsEnteredToRecipientsFields()
    let contacts = self.contacts.filter({
      (contact) in
      !filledRecipients.includes(contact.email)
    })
    let notGeneratedYabble: Yabble! = (try self.getNotGeneratedYabble())
    if notGeneratedYabble == nil {
      return contacts.slice(0, 10)
    }
    let contactsInAbookMatchedWithQuery = contacts.filter({
      (contact) in
      contact.email.includes(notGeneratedYabble.email) || contact.name.includes(notGeneratedYabble.email)
    })
    if contactsInAbookMatchedWithQuery.length != 0 {
      return contactsInAbookMatchedWithQuery
    }
    if notGeneratedYabble.email.includes("@") {
      let splittedEmail = notGeneratedYabble.email.split("@")
      if splittedEmail.length == 2 {
        let enteredLogin = splittedEmail[0]
        let enteredDomain = splittedEmail[1]
        var domains = copyArray(self.domains)
        if enteredDomain != "" {
          domains = domains.filter({
            (domain) in
            domain.startsWith(enteredDomain)
          })
        }
        return domains.map({
          (domain) in
          Contact("", "\(enteredLogin)@\(domain)")
        }).filter({
          (contact) in
          !filledRecipients.includes(contact.email)
        })
      }
    }
    return YSArray()
  }

  @discardableResult
  open func isRecipientSuggestShown() throws -> Bool {
    let isSuggestEmpty = (try self.getRecipientSuggest()).length == 0
    return self.recipientSuggestShown && !isSuggestEmpty
  }

  @discardableResult
  open func tapOnRecipientSuggestByEmail(_ email: String) throws -> Void {
    let contacts = (try self.getRecipientSuggest()).filter({
      (suggestItem) in
      suggestItem.email == email
    })
    if contacts.length < 0 {
      fail("There is no account with email \(email) in to/cc/bcc suggest")
    }
    (try self.addYabbleBySuggest((try self.composeFieldTypeToRecipientFieldType(self.focusedField!)), contacts[0]))
  }

  @discardableResult
  open func tapOnRecipientSuggestByIndex(_ index: Int32) throws -> Void {
    let contacts = (try self.getRecipientSuggest())
    if contacts.length <= index {
      fail("There is no account with index \(index) in to/cc/bcc suggest")
    }
    (try self.addYabbleBySuggest((try self.composeFieldTypeToRecipientFieldType(self.focusedField!)), contacts[index]))
  }

  @discardableResult
  private func addYabbleBySuggest(_ field: ComposeRecipientFieldType, _ contact: Contact) throws -> Void {
    let notGeneratedYabble: Yabble! = (try self.getNotGeneratedYabble())
    if notGeneratedYabble != nil {
      notGeneratedYabble!.email = contact.email
      notGeneratedYabble!.name = contact.name
      notGeneratedYabble!.type = YabbleType.suggested
    } else {
      self.addYabble(field, Yabble(contact.email, contact.name, YabbleType.suggested))
    }
    self.recipientSuggestShown = false
  }

  @discardableResult
  open func formatValidEmail(_ email: String) -> String {
    var newEmail = email
    let symbolToDelete: YSArray<String> = YSArray("\"'\"", "\"")
    symbolToDelete.forEach({
      (symbol) in
      newEmail = stringReplaceAll(newEmail, symbol, "")
    })
    return newEmail
  }

  private func addYabble(_ field: ComposeRecipientFieldType, _ yabble: Yabble) -> Void {
    if yabble.type == YabbleType.manual {
      yabble.email = self.formatValidEmail(yabble.email)
    }
    self.recipientSuggestShown = yabble.type == YabbleType.new
    switch field {
      case ComposeRecipientFieldType.to:
        self.to.push(yabble)
      case ComposeRecipientFieldType.cc:
        self.cc.push(yabble)
      case ComposeRecipientFieldType.bcc:
        self.bcc.push(yabble)
    }
  }

  private func makeAllYabblesInactive() -> Void {
    self.allRecipients().filter({
      (yabble) in
      yabble.isActive
    }).forEach({
      (yabble) in
      yabble.isActive = false
    })
  }

  @discardableResult
  open func getSenderSuggest() throws -> YSArray<String> {
    return self.aliases
  }

  @discardableResult
  open func isSenderSuggestShown() throws -> Bool {
    return self.senderSuggestShown
  }

  @discardableResult
  open func tapOnSenderSuggestByEmail(_ email: String) throws -> Void {
    self.from = email
    self.senderSuggestShown = false
  }

  @discardableResult
  open func tapOnSenderSuggestByIndex(_ index: Int32) throws -> Void {
    self.from = self.aliases[index]
    self.senderSuggestShown = false
  }

  @discardableResult
  open func getBody() throws -> String {
    return self.body
  }

  @discardableResult
  open func setBody(_ body: String) throws -> Void {
    self.body = self.isBodyCleared ? body : "\(body)\n\n\(self.getSignature())\(self.reOrFwdContent)"
  }

  @discardableResult
  open func pasteBody(_ body: String) throws -> Void {
    (try self.setBody(body))
  }

  @discardableResult
  private func getSignature() -> String {
    var signature = self.mailAppModelHandler.getCurrentAccount().accountSettings.signature
    if signature == "" {
      signature = "--\nSent from Yandex Mail for mobile"
    }
    return stringReplaceAll(signature, "<br>", "\n")
  }

  @discardableResult
  open func clearBody() throws -> Void {
    self.body = "\n"
    self.isBodyCleared = true
  }

  @discardableResult
  open func tapOnBodyField() throws -> Void {
    self.extendedRecipientFormShown = false
    self.recipientSuggestShown = false
    self.senderSuggestShown = false
    self.focusedField = ComposeFieldType.body
    self.generateYabbleIfNeeded()
    self.makeAllYabblesInactive()
  }

  @discardableResult
  open func getSubject() throws -> String {
    return self.subject
  }

  @discardableResult
  open func setSubject(_ subject: String) throws -> Void {
    self.subject = subject
  }

  @discardableResult
  open func tapOnSubjectField() throws -> Void {
    self.extendedRecipientFormShown = false
    self.recipientSuggestShown = false
    self.senderSuggestShown = false
    self.focusedField = ComposeFieldType.subject
    self.generateYabbleIfNeeded()
    self.makeAllYabblesInactive()
  }

  @discardableResult
  open func getAttachments() throws -> YSArray<ComposeAttachment> {
    return self.attachments
  }

}

