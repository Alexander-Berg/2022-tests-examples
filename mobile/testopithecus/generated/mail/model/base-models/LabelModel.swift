// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/model/base-models/label-model.ts >>>

import Foundation

open class MarkableImportantModel: MarkableImportant {
  private var model: MessageListDisplayModel
  private var accHandler: MailAppModelHandler
  public init(_ model: MessageListDisplayModel, _ accHandler: MailAppModelHandler) {
    self.model = model
    self.accHandler = accHandler
  }

  @discardableResult
  open func markAsImportant(_ order: Int32) throws -> Void {
    for mid in self.model.getThreadByOrder(order) {
      self.accHandler.getCurrentAccount().messagesDB.storedMessage(mid).mutableHead.important = true
    }
  }

  @discardableResult
  open func markAsUnimportant(_ order: Int32) throws -> Void {
    for mid in self.model.getThreadByOrder(order) {
      self.accHandler.getCurrentAccount().messagesDB.storedMessage(mid).mutableHead.important = false
    }
  }

}

open class LabelModel: CreatableLabel {
  private var accHandler: MailAppModelHandler
  public init(_ accHandler: MailAppModelHandler) {
    self.accHandler = accHandler
  }

  open func applyLabelsToMessages(_ mids: YSSet<MessageId>, _ labelNames: YSArray<LabelName>) -> Void {
    labelNames.forEach({
      (labelName) in
      if !self.accHandler.getCurrentAccount().messagesDB.getLabelList().includes(labelName) {
        resolveThrow({
          () in
          (try self.createLabel(labelName))
        }
, nil)
      }
      self.accHandler.getCurrentAccount().messagesDB.applyLabelToMessages(labelName, mids)
    })
  }

  open func removeLabelsFromMessages(_ mids: YSSet<MessageId>, _ labelNames: YSArray<LabelName>) -> Void {
    labelNames.forEach({
      (labelName) in
      self.accHandler.getCurrentAccount().messagesDB.removeLabelFromMessages(labelName, mids)
    })
  }

  @discardableResult
  open func getMessageLabels(_ mid: MessageId) -> YSSet<LabelName> {
    return self.accHandler.getCurrentAccount().messagesDB.getMessageLabels(mid)
  }

  @discardableResult
  open func getMessagesLabels(_ mids: YSSet<MessageId>) -> YSSet<LabelName> {
    let labels = YSSet<LabelName>()
    for mid in setToArray(mids) {
      self.getMessageLabels(mid).forEach({
        (label) in
        labels.add(label)
      })
    }
    return labels
  }

  @discardableResult
  open func createLabel(_ labelName: String) throws -> Void {
    self.accHandler.getCurrentAccount().messagesDB.createLabel(labelName)
  }

  @discardableResult
  open func removeLabel(_ labelName: String) throws -> Void {
    self.accHandler.getCurrentAccount().messagesDB.removeLabel(labelName)
  }

}

open class ApplyLabelModel: ApplyLabel {
  private var selectedToAdd: YSArray<LabelName> = YSArray()
  private var deselectedToRemove: YSArray<LabelName> = YSArray()
  private var accHandler: MailAppModelHandler
  private var openMessageModel: OpenMessageModel
  private var contextMenuModel: ContextMenuModel
  private var messageListDisplayModel: MessageListDisplayModel
  private var groupModeModel: GroupModeModel
  private var labelModel: LabelModel
  public init(_ accHandler: MailAppModelHandler, _ openMessageModel: OpenMessageModel, _ contextMenuModel: ContextMenuModel, _ messageListDisplayModel: MessageListDisplayModel, _ groupModeModel: GroupModeModel, _ labelModel: LabelModel) {
    self.accHandler = accHandler
    self.openMessageModel = openMessageModel
    self.contextMenuModel = contextMenuModel
    self.messageListDisplayModel = messageListDisplayModel
    self.groupModeModel = groupModeModel
    self.labelModel = labelModel
  }

  @discardableResult
  private func getMids() throws -> YSSet<MessageId>! {
    if self.openMessageModel.openedMessage != int64(-1) {
      return YSSet(YSArray(self.openMessageModel.openedMessage))
    }
    let contextMenuOrder = (try self.contextMenuModel.getOrderOfMessageWithOpenedContextMenu())
    if contextMenuOrder != -1 {
      return YSSet(YSArray(self.messageListDisplayModel.getMessageId(contextMenuOrder)))
    }
    let groupModeSelectedOrders = (try self.groupModeModel.getSelectedMessages())
    if groupModeSelectedOrders.size > 0 {
      return YSSet(self.messageListDisplayModel.getMidsByOrders(groupModeSelectedOrders))
    }
    return nil
  }

  @discardableResult
  open func tapOnCreateLabel() throws -> Void {
  }

  @discardableResult
  open func getLabelList() throws -> YSArray<LabelName> {
    return self.accHandler.getCurrentAccount().messagesDB.getLabelList()
  }

  @discardableResult
  open func getSelectedLabels() throws -> YSArray<LabelName> {
    let selected = self.labelModel.getMessagesLabels(requireNonNull((try self.getMids()), "There is no opened/selected messages"))
    self.deselectedToRemove.forEach({
      (label) in
      selected.delete(label)
    })
    self.selectedToAdd.forEach({
      (label) in
      selected.add(label)
    })
    return setToArray(selected)
  }

  @discardableResult
  open func selectLabelsToAdd(_ labelNames: YSArray<LabelName>) throws -> Void {
    self.selectedToAdd = labelNames
  }

  @discardableResult
  open func deselectLabelsToRemove(_ labelNames: YSArray<LabelName>) throws -> Void {
    self.deselectedToRemove = labelNames
  }

  @discardableResult
  open func tapOnDoneButton() throws -> Void {
    let mids = requireNonNull((try self.getMids()), "There is no opened/selected messages")
    self.labelModel.removeLabelsFromMessages(mids, self.deselectedToRemove)
    self.labelModel.applyLabelsToMessages(mids, self.selectedToAdd)
    self.selectedToAdd = YSArray()
    self.deselectedToRemove = YSArray()
    (try self.contextMenuModel.close())
    (try self.groupModeModel.unselectAllMessages())
  }

}

