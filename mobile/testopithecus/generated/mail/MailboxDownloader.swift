// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/mailbox-downloader.ts >>>

import Foundation

open class MailboxDownloader: AppModelProvider {
  private var clients: YSArray<MailboxClient>
  private var logger: Logger
  public init(_ clients: YSArray<MailboxClient>, _ logger: Logger) {
    self.clients = clients
    self.logger = logger
  }

  @discardableResult
  open func takeAppModel() -> AppModel {
    self.logger.info("Downloading mailbox started")
    let accountsData: YSArray<AccountMailboxData> = YSArray()
    for client in self.clients {
      self.logger.info("Downloading account (\(client.oauthAccount.account.login)) started")
      let filters = client.listFilter().rules
      let settings = client.getSettings().payload!
      let isTabEnabled = settings.userParameters.showFoldersTabs
      let folderList = client.getFolderList(isTabEnabled).filter({
        (folder) in
        folder.name != DefaultFolderName.outgoing
      })
      let allLabels = client.getLabelList()
      let labelList = allLabels.filter({
        (label) in
        label.type == LabelType.user
      })
      let fidToFolder = YSMap<FolderId, Folder>()
      let lidToLabel = YSMap<LabelID, Label>()
      folderList.forEach({
        (folder) in
        fidToFolder.set(folder.fid, folder)
      })
      labelList.forEach({
        (label) in
        lidToLabel.set(label.lid, label)
      })
      let messages = YSMap<MessageId, FullMessage>()
      let messageToFolder = YSMap<MessageId, FolderName>()
      let messageToLabels = YSMap<MessageId, YSArray<LabelName>>()
      let threads = YSMap<ID, YSSet<MessageId>>()
      let defaultEmail = settings.settingsSetup.defaultEmail
      let aliases = settings.accountInformation.emails.map({
        (email) in
        display(email)
      })
      let replyTo = settings.settingsSetup.replyTo
      let contacts = client.getAllContactsList(1000)
      let zeroSuggest = client.getZeroSuggest().map({
        (suggest) in
        suggest.show_text
      })
      let promoteMail360 = settings.settingsSetup.promoteMail360
      let translationLangs = client.getTranslationLangs().translationLangs
      let translationLangNames = translationLangs.map({
        (lang) in
        lang.name
      })
      let accountSettings = AccountSettingsModel(settings.settingsSetup.folderThreadView, settings.userParameters.showFoldersTabs, settings.settingsSetup.mobileSign, settings.settingsSetup.signatureTop, folderList.map({
        (folder) in
        folder.name!
      }))
      for folder in folderList {
        let messagesDTO = isFolderOfThreadedType(folder.type) ? client.getThreadsInFolder(folder.fid, 10, isTabEnabled) : client.getMessagesInFolder(folder.fid, 10, isTabEnabled)
        messagesDTO.forEach({
          (messageDTO) in
          let messageModel = FullMessage.fromMeta(messageDTO)
          let tid: Int64! = messageDTO.tid
          let threadSize: Int32! = messageModel.head.threadCounter
          if tid != nil && threadSize != nil {
            for threadMessageDTO in client.getMessagesInThread(tid, threadSize, isTabEnabled) {
              let mid = threadMessageDTO.mid
              if !threads.has(tid) {
                threads.set(tid, YSSet())
              }
              threads.`get`(tid)!.add(mid)
              let messageBody = client.getMessageBody(mid)
              let langCode = messageBody.lang
              let quickReply = messageBody.quickReply
              let smartReplies = messageBody.smartReplies.map({
                (smartReply) in
                smartReply.text
              })
              messages.set(mid, FullMessage.fromMeta(threadMessageDTO, removeAllNonLetterSymbols(messageBody.body[0].content!), self.getLanguageNameById(translationLangs, langCode), self.getTranslation(client, langCode, mid), quickReply, smartReplies))
              messageToFolder.set(mid, requireNonNull(undefinedToNull(fidToFolder.`get`(threadMessageDTO.fid)), "Folder with fid \(threadMessageDTO.fid) has no folder!").name!)
              messageToLabels.set(mid, self.getLabelNames(threadMessageDTO, lidToLabel))
            }
          } else {
            let mid = messageDTO.mid
            let messageBody = client.getMessageBody(mid)
            let langCode = messageBody.lang
            let quickReply = messageBody.quickReply
            let smartReplies = messageBody.smartReplies.map({
              (smartReply) in
              smartReply.text
            })
            messages.set(mid, FullMessage.fromMeta(messageDTO, removeAllNonLetterSymbols(messageBody.body[0].content!), self.getLanguageNameById(translationLangs, langCode), self.getTranslation(client, langCode, mid), quickReply, smartReplies))
            messageToFolder.set(mid, requireNonNull(undefinedToNull(fidToFolder.`get`(messageDTO.fid)), "Folder with fid \(messageDTO.fid) has no folder!").name!)
            messageToLabels.set(mid, self.getLabelNames(messageDTO, lidToLabel))
          }
        })
      }
      let folderToMessages: YSMap<FolderName, YSSet<MessageId>> = YSMap<FolderName, YSSet<MessageId>>()
      let tabsToMessages: YSMap<FolderName, YSSet<MessageId>> = YSMap<FolderName, YSSet<MessageId>>()
      for folderDTO in folderList {
        if isFolderOfTabType(folderDTO.type) {
          tabsToMessages.set(formatFolderNameIfNeeded(folderDTO.name!), YSSet<MessageId>())
        }
        folderToMessages.set(formatFolderNameIfNeeded(folderDTO.name!), YSSet<MessageId>())
      }
      messageToFolder.__forEach({
        (folder, msg) in
        if isTab(folder) {
          tabsToMessages.`get`(formatFolderNameIfNeeded(folder))!.add(msg)
        }
        folderToMessages.`get`(formatFolderNameIfNeeded(folder))!.add(msg)
      })
      let labelToMessages: YSMap<LabelName, YSSet<MessageId>> = YSMap<LabelName, YSSet<MessageId>>()
      for labelDTO in labelList {
        labelToMessages.set(labelDTO.name!, YSSet<MessageId>())
      }
      messageToLabels.__forEach({
        (labels, msg) in
        labels.forEach({
          (label) in
          if !labelToMessages.has(label) {
            labelToMessages.set(label, YSSet())
          }
          labelToMessages.`get`(label)!.add(msg)
        })
      })
      let accountData = AccountMailboxData(client, MessageListDatabase(messages, folderToMessages, labelToMessages, tabsToMessages, valuesArray(threads)), defaultEmail, aliases.concat(replyTo), contacts, filters, accountSettings, zeroSuggest, translationLangNames, promoteMail360)
      accountsData.push(accountData)
      self.logger.info("Downloading account (\(client.oauthAccount.account.login)) finished")
    }
    self.logger.info("Downloading mailbox finished")
    self.logger.info("\n")
    let accountDataHandler = MailAppModelHandler(accountsData)
    return MailboxModel(accountDataHandler)
  }

  @discardableResult
  private func getTranslation(_ client: MailboxClient, _ sourceLangCode: LanguageName, _ mid: ID) -> YSMap<LanguageName, String> {
    let targetLangCode: LanguageCode = sourceLangCode == TranslatorLanguageCode.russian ? TranslatorLanguageCode.english : TranslatorLanguageCode.russian
    let targetLangName = targetLangCode == TranslatorLanguageCode.english ? TranslatorLanguageName.english : TranslatorLanguageName.russian
    return YSMap<LanguageName, String>().set(targetLangName, removeAllNonLetterSymbols(client.translateMessage(mid, targetLangCode).body[0].content))
  }

  @discardableResult
  private func getLanguageNameById(_ translationLangs: YSArray<TranslationLangsPayload>, _ lang: String) -> String {
    let filteredLanguage = translationLangs.filter({
      (language) in
      language.lang == lang
    })
    return filteredLanguage.length == 1 ? filteredLanguage[0].name : ""
  }

  @discardableResult
  private func getLabelNames(_ msg: MessageMeta, _ lidToLabel: YSMap<LabelID, Label>) -> YSArray<LabelName> {
    let messageLids: YSArray<String> = copyArray(msg.lid)
    return messageLids.filter({
      (lid) in
      lidToLabel.has(lid)
    }).map({
      (lid) in
      lidToLabel.`get`(lid)!.name!
    })
  }

}

