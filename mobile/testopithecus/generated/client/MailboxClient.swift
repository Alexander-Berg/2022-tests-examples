// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM client/mailbox-client.ts >>>

import Foundation

open class MailboxClient {
  private let platform: MBTPlatform
  public let oauthAccount: OAuthUserAccount
  private var network: SyncNetwork
  private var jsonSerializer: JSONSerializer
  public var logger: Logger
  public init(_ platform: MBTPlatform, _ oauthAccount: OAuthUserAccount, _ network: SyncNetwork, _ jsonSerializer: JSONSerializer, _ logger: Logger) {
    self.platform = platform
    self.oauthAccount = oauthAccount
    self.network = network
    self.jsonSerializer = jsonSerializer
    self.logger = logger
  }

  @discardableResult
  open func getFolderList(_ withTabs: Bool = false) -> YSArray<Folder> {
    let request = ContainersRequest(withTabs)
    let jsonArray = self.getJsonResponse(request) as! ArrayJSONItem
    let folders: YSArray<Folder> = YSArray()
    jsonArray.asArray().forEach({
      (folderItem) in
      let fid: JSONItem! = (folderItem as! MapJSONItem).`get`("fid")
      if fid != nil {
        folders.push(folderFromJSONItem(folderItem)!)
      }
    })
    return folders
  }

  @discardableResult
  open func getFolderByName(_ name: String, _ withTabs: Bool = false) -> Folder {
    let result = self.getFolderList(withTabs).filter({
      (f) in
      f.name == name
    })
    if result.length == 0 {
      fail("На бэке нет папки '\(name)'!")
    }
    return result[0]
  }

  @discardableResult
  open func getLabelList() -> YSArray<Label> {
    let request = ContainersRequest()
    let jsonArray = self.getJsonResponse(request) as! ArrayJSONItem
    let labels: YSArray<Label> = YSArray()
    jsonArray.asArray().forEach({
      (labelItem) in
      let lid: JSONItem! = (labelItem as! MapJSONItem).`get`("lid")
      if lid != nil {
        labels.push(labelFromJSONItem(labelItem)!)
      }
    })
    return labels
  }

  @discardableResult
  open func getLabelByName(_ name: String) -> Label {
    let result = self.getLabelList().filter({
      (l) in
      l.name == name
    })
    if result.length == 0 {
      fail("На бэке нет папки '\(name)'!")
    }
    return result[0]
  }

  @discardableResult
  open func getCustomUserLabelsList() -> YSArray<Label> {
    return self.getLabelList().filter({
      (label) in
      label.type == LabelType.user
    })
  }

  @discardableResult
  open func getAllContactsList(_ limit: Int32) -> YSArray<Contact> {
    let request = ABookTopRequest(limit)
    return self.getContactsList(request)
  }

  @discardableResult
  open func getContacts(_ data: GetAbookContactsRequestData) -> AbookContactsResponseData {
    let request = GetAbookContactsRequest(data)
    let response = self.getJsonResponse(request) as! MapJSONItem
    return contactsFromJSONItem(response)!
  }

  @discardableResult
  open func createContacts(_ newContacts: CreateAbookContactsRequestData) -> YSArray<String> {
    let request = CreateAbookContactsRequest(newContacts)
    let response = self.getJsonResponse(request) as! MapJSONItem
    return contactIdsFromJSONItem(response)!
  }

  @discardableResult
  open func deleteContacts(_ contactIds: YSArray<String>) -> YSArray<String> {
    let request = DeleteAbookContactsRequest(contactIds)
    let response = self.getJsonResponse(request) as! MapJSONItem
    return contactIdsFromJSONItem(response)!
  }

  @discardableResult
  open func getMessagesInFolder(_ fid: ID, _ limit: Int32, _ withTabs: Bool = false) -> YSArray<MessageMeta> {
    let messageRequestItem = MessageRequestItem.messagesInFolder(fid, 0, limit)
    let request = MessagesRequestPack(YSArray(messageRequestItem), false, withTabs)
    return self.getMessagesList(request)
  }

  @discardableResult
  open func getThreadsInFolder(_ fid: ID, _ limit: Int32, _ withTabs: Bool = false) -> YSArray<MessageMeta> {
    let messageRequestItem = MessageRequestItem.threads(fid, 0, limit)
    let request = MessagesRequestPack(YSArray(messageRequestItem), false, withTabs)
    return self.getMessagesList(request)
  }

  @discardableResult
  open func getMessagesInThread(_ tid: ID, _ limit: Int32, _ withTabs: Bool = false) -> YSArray<MessageMeta> {
    let messageRequestItem = MessageRequestItem.messagesInThread(tid, 0, limit)
    let request = MessagesRequestPack(YSArray(messageRequestItem), false, withTabs)
    return self.getMessagesList(request)
  }

  @discardableResult
  open func getSettings() -> SettingsResponse {
    let request = SettingsRequest()
    let response = self.getJsonResponse(request)
    return settingsResponseFromJSONItem(response)!
  }

  @discardableResult
  open func createFilter(_ data: CreateUpdateFilterRuleRequestData) -> CreateUpdateFilterRuleResponse {
    let request = CreateFilterRuleRequest(data)
    let response = self.getJsonResponse(request, 3)
    return filterIdFromJSONItem(response)!
  }

  @discardableResult
  open func updateFilter(_ data: CreateUpdateFilterRuleRequestData) -> CreateUpdateFilterRuleResponse {
    let request = UpdateFilterRuleRequest(data)
    let response = self.getJsonResponse(request)
    return filterIdFromJSONItem(response)!
  }

  @discardableResult
  open func listFilter() -> FiltersResponseData {
    let request = ListFilterRuleRequest()
    let response = self.getJsonResponse(request)
    return filtersFromJSONItem(response)!
  }

  open func applyFilter(_ id: String) -> Void {
    let request = ApplyFilterRuleRequest(id)
    self.executeRequest(request)
  }

  open func deleteFilter(_ id: String) -> Void {
    let request = DeleteFilterRuleRequest(id)
    self.executeRequest(request)
  }

  open func disableFilter(_ id: String) -> Void {
    let request = DisableFilterRuleRequest(id)
    self.executeRequest(request)
  }

  open func enableFilter(_ id: String) -> Void {
    let request = EnableFilterRuleRequest(id)
    self.executeRequest(request)
  }

  open func markMessageAsRead(_ mid: ID) -> Void {
    let request = MarkReadNetworkRequest(YSArray(mid), YSArray(), true)
    self.executeRequest(request)
  }

  open func markMessageAsUnread(_ mid: ID) -> Void {
    let request = MarkReadNetworkRequest(YSArray(mid), YSArray(), false)
    self.executeRequest(request)
  }

  open func markThreadAsRead(_ tid: ID) -> Void {
    let request = MarkReadNetworkRequest(YSArray(), YSArray(tid), true)
    self.executeRequest(request)
  }

  open func markThreadAsUnread(_ tid: ID) -> Void {
    let request = MarkReadNetworkRequest(YSArray(), YSArray(tid), false)
    self.executeRequest(request)
  }

  open func markMessagesWithLabel(_ mids: YSArray<ID>, _ lid: LabelID) -> Void {
    let request = MarkWithLabelsNetworkRequest(mids, YSArray(), YSArray(lid), true)
    self.executeRequest(request)
  }

  open func unmarkMessagesWithLabel(_ mids: YSArray<ID>, _ lid: LabelID) -> Void {
    let request = MarkWithLabelsNetworkRequest(mids, YSArray(), YSArray(lid), false)
    self.executeRequest(request)
  }

  open func markThreadWithLabel(_ tid: ID, _ lid: LabelID) -> Void {
    let request = MarkWithLabelsNetworkRequest(YSArray(), YSArray(tid), YSArray(lid), true)
    self.executeRequest(request)
  }

  open func unmarkThreadWithLabel(_ tid: ID, _ lid: LabelID) -> Void {
    let request = MarkWithLabelsNetworkRequest(YSArray(), YSArray(tid), YSArray(lid), false)
    self.executeRequest(request)
  }

  open func removeMessageByThreadId(_ fid: ID, _ tid: ID) -> Void {
    let request = DeleteMessagesNetworkRequest(YSArray(), YSArray(tid), fid)
    self.executeRequest(request)
  }

  open func moveThreadToFolder(_ tid: ID, _ fid: ID) -> Void {
    let request = MoveToFolderNetworkRequest(YSArray(), YSArray(tid), fid, fid)
    self.executeRequest(request)
  }

  open func moveMessageToFolder(_ mid: ID, _ fid: ID) -> Void {
    let request = MoveToFolderNetworkRequest(YSArray(mid), YSArray(), fid, fid)
    self.executeRequest(request)
  }

  open func createFolder(_ name: String) -> Void {
    let request = CreateFolderRequest(name, nil, nil)
    self.executeRequest(request)
  }

  open func createLabel(_ label: LabelData) -> Void {
    let request = CreateLabelRequest(label)
    self.executeRequest(request)
  }

  open func deleteLabel(_ lid: LabelID) -> Void {
    let request = DeleteLabelRequest(lid)
    self.executeRequest(request)
  }

  open func sendMessage(_ to: String, _ subject: String, _ text: String, _ references: String! = nil) -> Void {
    let settings = self.getSettings()
    let composeCheck = settings.payload!.accountInformation.composeCheck
    let task = MailSendRequestBuilder().setTo(to).setComposeCheck(composeCheck).setSubject(subject).setBody(text).setReferences(references).build()
    self.getJsonResponse(SendMailNetworkRequest(task))
  }

  @discardableResult
  open func getMessageBody(_ mid: ID) -> MessageBodyPayload {
    let request = MessageBodyRequest(YSArray(mid), true)
    let json = self.getJsonResponse(request)
    let response: MessageBodyResponse! = messageBodyResponseFromJSONItem(json)
    return response![0].payload!
  }

  @discardableResult
  open func getMessageReference(_ mid: ID) -> String {
    return self.getMessageBody(mid).info.rfcId
  }

  open func setParameter(_ key: String, _ value: String) -> Void {
    let request = SetParametersRequest(SetParametersItems(YSArray(SetParametersItem(key, value))))
    self.executeRequest(request)
  }

  open func moveToSpam(_ fid: ID, _ tid: ID) -> Void {
    let request = MarkSpamNetworkRequest(YSArray(), YSArray(tid), fid, true)
    self.executeRequest(request)
  }

  open func archive(_ local: String, _ tid: ID) -> Void {
    let request = ArchiveMessagesNetworkRequest(YSArray(), YSArray(tid), local)
    self.executeRequest(request)
  }

  @discardableResult
  open func getSearchResults(_ query: String) -> YSMap<MessageId, FullMessage> {
    let request = SearchQueryRequest(query)
    let messages: YSMap<MessageId, FullMessage> = YSMap()
    let response: SearchResponse! = searchResponseFromJSONItem(self.getJsonResponse(request))
    response!.messages.forEach({
      (message) in
      messages.set(message.mid, FullMessage.fromMeta(message))
    })
    return messages
  }

  @discardableResult
  open func getZeroSuggest() -> YSArray<ZeroSuggestResponse> {
    let request = ZeroSuggestRequest()
    let response = self.getJsonResponse(request) as! ArrayJSONItem
    let suggests: YSArray<ZeroSuggestResponse> = YSArray()
    response.asArray().forEach({
      (suggest) in
      suggests.push(zeroSuggestFromJSONItem(suggest)!)
    })
    return suggests
  }

  @discardableResult
  open func getTranslationLangs() -> TranslationLangsResponse {
    let request = TranslationLangsRequest()
    let response = self.getJsonResponse(request) as! MapJSONItem
    return translationLangsFromJSONItem(response)!
  }

  @discardableResult
  open func translateMessage(_ mid: ID, _ targetLang: String) -> TranslatedMessageResponse {
    let request = TranslateMessageRequest(targetLang, mid.toString())
    let response = self.getJsonResponse(request) as! MapJSONItem
    return translatedMessageFromJSONItem(response)!
  }

  open func saveQueryToZeroSuggest(_ query: String) -> Void {
    let request = SaveQueryToZeroSuggestRequest(query)
    self.executeRequest(request)
  }

  open func deleteQueryFromZeroSuggest(_ query: String) -> Void {
    let request = DeleteQueryFromZeroSuggestRequest(query)
    self.executeRequest(request)
  }

  @discardableResult
  open func getSuggests(_ query: String) -> YSArray<SuggestResponse> {
    let request = SuggestRequest(query)
    let response = self.getJsonResponse(request) as! ArrayJSONItem
    let suggests: YSArray<SuggestResponse> = YSArray()
    response.asArray().forEach({
      (suggest) in
      suggests.push(suggestFromJSONItem(suggest)!)
    })
    return suggests
  }

  @discardableResult
  private func getMessagesList(_ request: NetworkRequest) -> YSArray<MessageMeta> {
    let response = self.getJsonResponse(request)
    let messageResponse = messageResponseFromJSONItem(response)!
    let messages: YSArray<MessageMeta> = YSArray()
    messageResponse.payload![0].items.forEach({
      (message) in
      messages.push(message)
    })
    return messages
  }

  @discardableResult
  private func getContactsList(_ request: NetworkRequest) -> YSArray<Contact> {
    let jsonMap = self.getJsonResponse(request) as! MapJSONItem
    let contacts: YSArray<Contact> = YSArray()
    let jsonContactArray = jsonMap.getMap("contacts")!.`get`("contact") as! ArrayJSONItem
    jsonContactArray.asArray().forEach({
      (contactItem) in
      let contact: Contact! = contactFromABookTopJSONItem(contactItem)
      if contact != nil {
        contacts.push(contact)
      }
    })
    return contacts
  }

  @discardableResult
  private func getJsonResponse(_ request: NetworkRequest, _ retries: Int32 = 0) -> JSONItem {
    let jsonString = self.executeRequest(request, retries)
    let response = self.jsonSerializer.deserialize(jsonString)
    self.logger.info(JSONItemGetDebugDescription(response.getValue()))
    return response.getValue()
  }

  @discardableResult
  private func executeRequest(_ request: NetworkRequest, _ retries: Int32 = 0) -> String {
    let host = PublicBackendConfig.baseUrl(self.oauthAccount.type)
    let requestEnricher = DefaultNetworkInterceptor(PlatformImpl(self.convertPlatform(self.platform), false), "testopithecus", {
      () in
      NetworkExtra(true, "fake")
    }
)
    let result: Result<String> = self.network.syncExecuteWithRetries(retries, host, requestEnricher.interceptSync(request), self.oauthAccount.oauthToken)
    if result.isError() {
      fail(result.getError().message)
    }
    return result.getValue()
  }

  @discardableResult
  private func convertPlatform(_ platform: MBTPlatform) -> PlatformType {
    switch platform {
      case MBTPlatform.IOS:
        return PlatformType.ios
      case MBTPlatform.Desktop:
        return PlatformType.electron
      default:
        return PlatformType.android
    }
  }

}

open class MailboxClientHandler {
  public var clientsManager: AccountsManager
  public var mailboxClients: YSArray<MailboxClient>
  public init(_ mailboxClients: YSArray<MailboxClient>) {
    self.mailboxClients = mailboxClients
    self.clientsManager = AccountsManager(mailboxClients.map({
      (client) in
      client.oauthAccount.account
    }))
  }

  open func loginToAccount(_ account: UserAccount) -> Void {
    self.clientsManager.logInToAccount(account)
  }

  open func switchToClientForAccountWithLogin(_ login: String) -> Void {
    self.clientsManager.switchToAccount(login)
  }

  @discardableResult
  open func getCurrentClient() -> MailboxClient {
    return self.mailboxClients[self.clientsManager.currentAccount!]
  }

  @discardableResult
  open func getLoggedInAccounts() -> YSArray<UserAccount> {
    return self.clientsManager.getLoggedInAccounts()
  }

  open func revokeToken(_ account: UserAccount) -> Void {
    return self.clientsManager.revokeToken(account)
  }

  open func exitFromReloginWindow() -> Void {
    self.clientsManager.exitFromReloginWindow()
  }

}

fileprivate class PlatformImpl: Platform {
  public let type: PlatformType
  public let isTablet: Bool
  public init(_ type: PlatformType, _ isTablet: Bool) {
    self.type = type
    self.isTablet = isTablet
  }

}

