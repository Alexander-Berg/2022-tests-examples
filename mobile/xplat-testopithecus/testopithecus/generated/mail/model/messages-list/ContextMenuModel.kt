// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/model/messages-list/context-menu-model.ts >>>

package com.yandex.xplat.testopithecus

import com.yandex.xplat.common.*
import com.yandex.xplat.eventus.common.*
import com.yandex.xplat.eventus.*
import com.yandex.xplat.mapi.*
import com.yandex.xplat.testopithecus.common.*

public open class MessageActionItem {
    companion object {
        @JvmStatic val reply: MessageActionName = "Reply"
        @JvmStatic val replyAll: MessageActionName = "Reply to all"
        @JvmStatic val forward: MessageActionName = "Forward"
        @JvmStatic val delete: MessageActionName = "Delete"
        @JvmStatic val markAsUnread: MessageActionName = "Mark as unread"
        @JvmStatic val markAsRead: MessageActionName = "Mark as read"
        @JvmStatic val spam: MessageActionName = "Spam!"
        @JvmStatic val notSpam: MessageActionName = "Not spam!"
        @JvmStatic val markAsImportant: MessageActionName = "Mark as important"
        @JvmStatic val markAsNotImportant: MessageActionName = "Mark as not important"
        @JvmStatic val moveToFolder: MessageActionName = "Move to folder"
        @JvmStatic val applyLabel: MessageActionName = "Apply label"
        @JvmStatic val archive: MessageActionName = "Archive"
        @JvmStatic val showTranslator: MessageActionName = "Show translator"
        @JvmStatic val print: MessageActionName = "Print"
        @JvmStatic val allActions: YSArray<MessageActionName> = mutableListOf(MessageActionItem.reply, MessageActionItem.replyAll, MessageActionItem.forward, MessageActionItem.delete, MessageActionItem.markAsRead, MessageActionItem.markAsUnread, MessageActionItem.spam, MessageActionItem.notSpam, MessageActionItem.markAsImportant, MessageActionItem.markAsNotImportant, MessageActionItem.moveToFolder, MessageActionItem.applyLabel, MessageActionItem.archive, MessageActionItem.showTranslator, MessageActionItem.print)
    }
}

public open class ContextMenuModel(private var deleteMessageModel: DeleteMessageModel, private var importantMessage: MarkableImportantModel, private var markableRead: MarkableReadModel, private var accHandler: MailAppModelHandler, private var messageListDisplayModel: MessageListDisplayModel, private var spammable: SpamableModel, private var compose: ComposeModel, private var archiveMessage: ArchiveMessageModel, private var openMessageModel: OpenMessageModel, private var translatorBarModel: TranslatorBarModel): ContextMenu {
    private var order: Int = -1
    open override fun openFromShortSwipe(order: Int): Unit {
        this.order = order
    }

    open override fun openFromMessageView(): Unit {
        this.order = requireNonNull(this.openMessageModel.getOrder(), "There is no opened message")
    }

    open override fun close(): Unit {
        if (this.openMessageModel.getOrder() == null) {
            this.order = -1
        }
    }

    open override fun getAvailableActions(): YSArray<MessageActionName> {
        val mid = this.messageListDisplayModel.getMessageId(this.order)
        val folder = this.accHandler.getCurrentAccount().messagesDB.storedFolder(mid)
        val actions = this.messageActionsByFolder(folder)
        val message = this.accHandler.getCurrentAccount().messagesDB.storedMessage(mid)
        val isRead = message.mutableHead.read
        val isImportant = message.mutableHead.important
        val isOneRecipient = message.to.size < 2
        val indexRead = actions.lastIndexOf(MessageActionItem.markAsRead)
        val indexUnread = actions.lastIndexOf(MessageActionItem.markAsUnread)
        if (indexRead != -1 && indexUnread != -1) {
            if (isRead) actions.splice(indexRead, 1) else actions.splice(indexUnread, 1)
        }
        val indexImportant = actions.lastIndexOf(MessageActionItem.markAsImportant)
        val indexUnimportant = actions.lastIndexOf(MessageActionItem.markAsNotImportant)
        if (indexImportant != -1 && indexUnimportant != -1) {
            if (isImportant) actions.splice(indexImportant, 1) else actions.splice(indexUnimportant, 1)
        }
        val indexReplyAll = actions.lastIndexOf(MessageActionItem.replyAll)
        if (indexReplyAll != -1 && isOneRecipient) {
            actions.splice(indexReplyAll, 1)
        }
        val indexTranslator = actions.lastIndexOf(MessageActionItem.showTranslator)
        val isShowTranslatorButtonShown = this.isShowTranslatorButtonShown()
        if (!isShowTranslatorButtonShown && indexTranslator != -1) {
            actions.splice(indexTranslator, 1)
        }
        return actions
    }

    open fun getOrderOfMessageWithOpenedContextMenu(): Int {
        return this.order
    }

    private fun getMidOfMessageWithOpenedContextMenu(): MessageId {
        return this.messageListDisplayModel.getMessageId(this.order)
    }

    open override fun deleteMessage(): Unit {
        this.deleteMessageModel.deleteMessage(this.order)
        this.close()
        this.closeMessageIfOpened()
    }

    open override fun markAsImportant(): Unit {
        this.importantMessage.markAsImportant(this.order)
        this.close()
    }

    open override fun markAsUnimportant(): Unit {
        this.importantMessage.markAsUnimportant(this.order)
        this.close()
    }

    open override fun markAsRead(): Unit {
        this.markableRead.markAsRead(this.order)
        this.close()
    }

    open override fun markAsUnread(): Unit {
        this.markableRead.markAsUnread(this.order)
        this.close()
    }

    open override fun openMoveToFolderScreen(): Unit {
    }

    open override fun archive(): Unit {
        this.archiveMessage.archiveMessage(this.order)
        this.close()
        this.closeMessageIfOpened()
    }

    open override fun markAsNotSpam(): Unit {
        this.spammable.moveFromSpam(this.order)
        this.close()
        this.closeMessageIfOpened()
    }

    open override fun markAsSpam(): Unit {
        this.spammable.moveToSpam(this.order)
        this.close()
        this.closeMessageIfOpened()
    }

    open override fun openApplyLabelsScreen(): Unit {
    }

    open override fun openForwardCompose(): Unit {
        this.compose.openForwardCompose(this.getMidOfMessageWithOpenedContextMenu())
        this.close()
    }

    open override fun openReplyAllCompose(): Unit {
        this.compose.openReplyAllCompose(this.getMidOfMessageWithOpenedContextMenu())
        this.close()
    }

    open override fun openReplyCompose(): Unit {
        this.compose.openReplyCompose(this.getMidOfMessageWithOpenedContextMenu())
        this.close()
    }

    open override fun showTranslator(): Unit {
        return this.translatorBarModel.forceShowBar()
    }

    private fun isShowTranslatorButtonShown(): Boolean {
        val isMessageOpened = this.openMessageModel.openedMessage != int64(-1)
        val isTranslatorBarShown = this.translatorBarModel.isTranslatorBarShown()
        return !isTranslatorBarShown && isMessageOpened
    }

    private fun messageActionsByFolder(folder: FolderName): YSArray<MessageActionName> {
        val actions = copyArray(MessageActionItem.allActions)
        when (folder) {
            DefaultFolderName.archive -> {
                for (folder in mutableListOf(MessageActionItem.archive, MessageActionItem.notSpam)) {
                    actions.splice(actions.lastIndexOf(folder), 1)
                }
                return actions
            }
            DefaultFolderName.sent -> {
                for (folder in mutableListOf(MessageActionItem.spam, MessageActionItem.notSpam)) {
                    actions.splice(actions.lastIndexOf(folder), 1)
                }
                return actions
            }
            DefaultFolderName.trash -> {
                for (folder in mutableListOf(MessageActionItem.markAsNotImportant, MessageActionItem.markAsImportant, MessageActionItem.notSpam, MessageActionItem.applyLabel)) {
                    actions.splice(actions.lastIndexOf(folder), 1)
                }
                return actions
            }
            DefaultFolderName.spam -> {
                for (folder in mutableListOf(MessageActionItem.markAsNotImportant, MessageActionItem.markAsImportant, MessageActionItem.spam, MessageActionItem.applyLabel)) {
                    actions.splice(actions.lastIndexOf(folder), 1)
                }
                return actions
            }
            DefaultFolderName.draft -> {
                return mutableListOf(MessageActionItem.forward, MessageActionItem.delete)
            }
            DefaultFolderName.template -> {
                return mutableListOf(MessageActionItem.delete)
            }
            else -> {
                actions.splice(actions.lastIndexOf(MessageActionItem.notSpam), 1)
                return actions
            }
        }
    }

    private fun closeMessageIfOpened(): Unit {
        if (this.openMessageModel.openedMessage != int64(-1)) {
            this.openMessageModel.closeMessage()
        }
    }

}

