// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/model/compose/compose-model.ts >>>

package com.yandex.xplat.testopithecus

import com.yandex.xplat.common.*
import com.yandex.xplat.eventus.common.*
import com.yandex.xplat.eventus.*
import com.yandex.xplat.mapi.*
import com.yandex.xplat.testopithecus.common.*

public open class ComposeConstants {
    companion object {
        @JvmStatic val forwardWrapperStartMessage: String = "-------- Beginning of forwarded message -------- "
        @JvmStatic val forwardWrapperEndMessage: String = "-------- End of forwarded message --------"
    }
}

public open class ComposeModel(private val mailAppModelHandler: MailAppModelHandler): Compose, ComposeRecipientFields, ComposeRecipientSuggest, ComposeSenderSuggest, ComposeSubject, ComposeBody {
    private var to: YSArray<Yabble> = mutableListOf()
    private var cc: YSArray<Yabble> = mutableListOf()
    private var bcc: YSArray<Yabble> = mutableListOf()
    private var subject: String = ""
    private var body: String = ""
    private var from: String = ""
    private var contacts: YSArray<Contact> = mutableListOf()
    private var aliases: YSArray<String> = mutableListOf()
    private var attachments: YSArray<ComposeAttachment> = mutableListOf()
    private var reOrFwdContent: String = ""
    private var composeType: ComposeType = ComposeType.clean
    private var extendedRecipientFormShown: Boolean = false
    private var recipientSuggestShown: Boolean = false
    private var senderSuggestShown: Boolean = false
    private var composeOpened: Boolean = false
    private var composeEmailProvider: ComposeEmailProvider = ComposeEmailProvider.instance
    private var focusedField: ComposeFieldType? = ComposeFieldType.to
    private var midOfRepliedOrForwarderMessage: MessageId? = null
    private var isBodyCleared: Boolean = false
    private var domains: YSArray<String> = mutableListOf("yandex.ru", "yahoo.com", "gmail.com", "mail.ru", "rambler.ru", "icloud.com", "qip.ru", "bk.ru", "inbox.ru")
    open override fun openCompose(): Unit {
        this.body = "\n\n${this.getSignature()}"
        this.contacts = this.mailAppModelHandler.getCurrentAccount().contacts
        this.aliases = this.mailAppModelHandler.getCurrentAccount().aliases
        this.from = this.mailAppModelHandler.getCurrentAccount().defaultEmail
        this.composeOpened = true
    }

    open override fun isSendButtonEnabled(): Boolean {
        val allRecipients = this.allRecipients()
        val validYabbles = allRecipients.filter( {
            yabble ->
            mutableListOf(YabbleType.manual, YabbleType.suggested).contains(yabble.type)
        })
        val invalidYabbles = allRecipients.filter( {
            yabble ->
            yabble.type == YabbleType.invalid
        })
        return validYabbles.size > 0 && invalidYabbles.size == 0
    }

    private fun createYabbleFromEmail(fullEmail: String): Yabble {
        if (fullEmail.includes("<")) {
            val email = fullEmail.slice(fullEmail.indexOf("<") + 1, fullEmail.indexOf(">"))
            val name = fullEmail.slice(fullEmail.indexOf("\"") + 1, fullEmail.lastIndexOf("\""))
            return Yabble(email, name, YabbleType.suggested)
        }
        return Yabble(fullEmail, fullEmail, YabbleType.suggested)
    }

    private fun parseNumberToDateAndFormat(ts: Long): String {
        val date = YSDate(int64ToDouble(ts))
        val year = date.getFullYear()
        val month = this.formatDatePartIfNeeded(date.getMonth() + 1)
        val day = this.formatDatePartIfNeeded(date.getDate())
        val hours = this.formatDatePartIfNeeded(date.getHours())
        val minutes = this.formatDatePartIfNeeded(date.getMinutes())
        return "${day}.${month}.${year}, ${hours}:${minutes}"
    }

    private fun formatDatePartIfNeeded(datePart: Int): String {
        return if (datePart < 10) "0${datePart}" else "${datePart}"
    }

    private fun setFieldsForReply(mid: MessageId): Unit {
        val message = this.getMessageByMid(mid)
        val date = this.parseNumberToDateAndFormat(message.head.timestamp)
        val from = message.head.from
        this.reOrFwdContent = "\n\n${date}, ${from}:\n${message.body}"
        this.body = "\n\n${this.getSignature()}${this.reOrFwdContent}"
        this.subject = "Re: ${message.head.subject}"
        this.midOfRepliedOrForwarderMessage = mid
        this.to = mutableListOf(this.createYabbleFromEmail(message.head.from))
    }

    private fun getMessageByMid(mid: MessageId): FullMessageView {
        return this.mailAppModelHandler.getCurrentAccount().messagesDB.storedMessage(mid, null)
    }

    open fun openReplyCompose(mid: MessageId): Unit {
        this.openCompose()
        this.setFieldsForReply(mid)
        this.composeType = ComposeType.reply
    }

    open fun openReplyAllCompose(mid: MessageId): Unit {
        this.openCompose()
        this.setFieldsForReply(mid)
        this.composeType = ComposeType.replyAll
    }

    open fun openForwardCompose(mid: MessageId): Unit {
        this.openCompose()
        val message = this.getMessageByMid(mid)
        val date = this.parseNumberToDateAndFormat(message.head.timestamp)
        this.subject = "Fwd: ${message.head.subject}"
        this.reOrFwdContent = "\n\n${ComposeConstants.forwardWrapperStartMessage}\n${date}, ${message.head.from}:\n" + "${message.body}\n\n\n${ComposeConstants.forwardWrapperEndMessage}"
        this.body = "\n\n${this.getSignature()}${this.reOrFwdContent}"
        this.composeType = ComposeType.forward
        this.midOfRepliedOrForwarderMessage = mid
    }

    open override fun closeCompose(saveDraft: Boolean): Unit {
        if (saveDraft) {
            this.saveMessage()
        }
        this.dropFields()
        this.composeOpened = false
    }

    open override fun isComposeOpened(): Boolean {
        return this.composeOpened
    }

    open override fun sendMessage(): Unit {
        val isReOrFwd = this.composeType != ComposeType.clean
        if (isReOrFwd) {
            val mid = requireNonNull(this.midOfRepliedOrForwarderMessage, "Mid should be no null")
            val message = this.getMessageByMid(mid)
            val threadCounter = if (message.head.threadCounter == null) 1 else message.head.threadCounter
            val sentMsgMid: MessageId = this.createSentMessage(threadCounter!!)
            this.mailAppModelHandler.getCurrentAccount().messagesDB.addThreadMessagesToThreadWithMid(mutableListOf(sentMsgMid), mid)
        } else {
            this.createSentMessage(0)
        }
        this.closeCompose(false)
    }

    private fun saveMessage(): Unit {
        val isReOrFwd = this.composeType != ComposeType.clean
        if (isReOrFwd) {
            val mid = requireNonNull(this.midOfRepliedOrForwarderMessage, "Mid should be non null")
            val message = this.getMessageByMid(mid)
            val threadSize = if (message.head.threadCounter == null) 1 else message.head.threadCounter
            val draftMsgMid: MessageId = this.createDraftMessage(threadSize!!)
            this.mailAppModelHandler.getCurrentAccount().messagesDB.addThreadMessagesToThreadWithMid(mutableListOf(draftMsgMid), mid)
        } else {
            this.createDraftMessage(0)
        }
    }

    private fun createDraftMessage(threadSize: Int): MessageId {
        val draftMessage = this.getDraft().toFullMessage(threadSize + 1, true)
        val messagesDB = this.mailAppModelHandler.getCurrentAccount().messagesDB
        val draftMsgMid = int64(messagesDB.getMessages().size + 1)
        messagesDB.addMessage(draftMsgMid, draftMessage, DefaultFolderName.draft)
        return draftMsgMid
    }

    private fun isMessageToYourself(): Boolean {
        val allRecipientEmails = this.allRecipients().map( {
            to ->
            formatLogin(to.email)
        })
        return (this.aliases.filter( {
            alias ->
            allRecipientEmails.contains(alias)
        }).size > 0 || allRecipientEmails.contains(this.from))
    }

    private fun createSentMessage(threadSize: Int): MessageId {
        val sentMessage = this.getDraft().toFullMessage(threadSize + 1, true)
        val messagesDB = this.mailAppModelHandler.getCurrentAccount().messagesDB
        val sentMsgMid = int64(messagesDB.getMessages().size + 1)
        messagesDB.addMessage(sentMsgMid, sentMessage, DefaultFolderName.sent)
        if (this.isMessageToYourself()) {
            val receivedMsgMid = int64(messagesDB.getMessages().size + 1)
            val receivedMessage = this.getDraft().toFullMessage(threadSize + 2, false)
            messagesDB.addMessage(receivedMsgMid, receivedMessage, DefaultFolderName.inbox)
            messagesDB.addThread(mutableListOf(sentMsgMid, receivedMsgMid))
        }
        return sentMsgMid
    }

    private fun dropFields(): Unit {
        this.to = mutableListOf()
        this.cc = mutableListOf()
        this.bcc = mutableListOf()
        this.subject = ""
        this.body = ""
        this.from = ""
        this.extendedRecipientFormShown = false
        this.recipientSuggestShown = false
        this.senderSuggestShown = false
        this.focusedField = ComposeFieldType.to
        this.reOrFwdContent = ""
        this.midOfRepliedOrForwarderMessage = null
    }

    open fun getDraft(): Draft {
        return Draft(this.to, this.cc, this.bcc, this.from, this.subject, this.body, this.attachments)
    }

    open override fun deleteRecipientByTapOnCross(`field`: ComposeRecipientFieldType, index: Int): Unit {
        this.deleteRecipientByIndex(`field`, index)
    }

    open override fun deleteLastRecipientByTapOnBackspace(`field`: ComposeRecipientFieldType): Unit {
        val recipients = this.getRecipientFieldValue(`field`)
        this.deleteRecipientByIndex(`field`, recipients.size - 1)
    }

    private fun deleteRecipientByIndex(`field`: ComposeRecipientFieldType, index: Int): Unit {
        when (`field`) {
            ComposeRecipientFieldType.to -> {
                this.to.splice(index, 1)
            }
            ComposeRecipientFieldType.cc -> {
                this.cc.splice(index, 1)
            }
            ComposeRecipientFieldType.bcc -> {
                this.bcc.splice(index, 1)
            }
        }
        this.recipientSuggestShown = false
    }

    open override fun expandExtendedRecipientForm(): Unit {
        this.extendedRecipientFormShown = true
        this.recipientSuggestShown = false
    }

    open override fun getRecipientFieldValue(`field`: ComposeRecipientFieldType): YSArray<Yabble> {
        when (`field`) {
            ComposeRecipientFieldType.to -> {
                return this.to
            }
            ComposeRecipientFieldType.cc -> {
                return this.cc
            }
            ComposeRecipientFieldType.bcc -> {
                return this.bcc
            }
        }
    }

    open override fun getCompactRecipientFieldValue(): String {
        val allEnteredEmails = this.allRecipients()
        val allEnteredEmailsLength = allEnteredEmails.size
        return if (allEnteredEmailsLength == 0) "" else if (allEnteredEmailsLength == 1) "${allEnteredEmails[0].emailOrName()}" else "${allEnteredEmails[0].emailOrName()} and ${allEnteredEmailsLength - 1} more"
    }

    open fun getFocusedField(): ComposeFieldType? {
        return this.focusedField
    }

    open override fun tapOnRecipient(`field`: ComposeRecipientFieldType, index: Int): Unit {
        var recipientsList: YSArray<Yabble> = mutableListOf()
        when (`field`) {
            ComposeRecipientFieldType.to -> {
                recipientsList = this.to
            }
            ComposeRecipientFieldType.cc -> {
                recipientsList = this.cc
            }
            ComposeRecipientFieldType.bcc -> {
                recipientsList = this.bcc
            }
        }
        if (recipientsList.size <= index) {
            fail("There is no recipient in field ${`field`.toString()} with index ${index}")
            return
        }
        recipientsList[index].isActive = true
    }

    open override fun getSenderFieldValue(): String {
        return this.from
    }

    open override fun isExtendedRecipientFormShown(): Boolean {
        return this.extendedRecipientFormShown
    }

    open override fun minimizeExtendedRecipientForm(): Unit {
        this.extendedRecipientFormShown = false
        this.recipientSuggestShown = false
    }

    open fun getNotGeneratedYabble(): Yabble? {
        val newYabbles = this.allRecipients().filter( {
            yabble ->
            yabble.type == YabbleType.new
        })
        val newYabblesLength = newYabbles.size
        if (newYabblesLength > 1) {
            throw YSError("There are ${newYabblesLength} new yabbles. Max = 1")
        }
        return if (newYabblesLength == 0) null else newYabbles[0]
    }

    open override fun pasteToRecipientField(`field`: ComposeRecipientFieldType, value: String, generateYabble: Boolean): Unit {
        this.setRecipientField(`field`, value, generateYabble)
    }

    open override fun setRecipientField(`field`: ComposeRecipientFieldType, value: String, generateYabble: Boolean): Unit {
        this.addYabble(`field`, Yabble(value, "", this.getYabbleType(value, generateYabble)))
    }

    private fun isEmailValid(value: String): Boolean {
        return (this.composeEmailProvider.validEmails.contains(value) || this.from == formatLogin(value) || this.aliases.contains(formatLogin(value)))
    }

    private fun getYabbleType(value: String, generateYabble: Boolean): YabbleType {
        return if (!generateYabble) YabbleType.new else if (this.isEmailValid(value)) YabbleType.manual else YabbleType.invalid
    }

    private fun allRecipients(): YSArray<Yabble> {
        return this.to.concat(this.cc).concat(this.bcc)
    }

    private fun allEmailsEnteredToRecipientsFields(): YSArray<String> {
        return this.allRecipients().map( {
            yabble ->
            yabble.email
        })
    }

    private fun generateYabbleIfNeeded(): Unit {
        val notGeneratedYabbles = this.allRecipients().filter( {
            yabble ->
            yabble.type == YabbleType.new
        })
        val notGeneratedYabblesLength = notGeneratedYabbles.size
        if (notGeneratedYabblesLength > 1) {
            fail("There are ${notGeneratedYabblesLength} new yabbles. Max = 1")
        }
        notGeneratedYabbles.forEach(__LBL__ComposeModel_1@ {
            yabble ->
            yabble.type = if (this.isEmailValid(yabble.email)) YabbleType.manual else YabbleType.invalid
            yabble.email = if (this.isEmailValid(yabble.email)) this.formatValidEmail(yabble.email) else yabble.email
        })
    }

    open override fun generateYabbleByTapOnEnter(): Unit {
        this.generateYabbleIfNeeded()
        this.recipientSuggestShown = false
    }

    open override fun tapOnRecipientField(`field`: ComposeRecipientFieldType): Unit {
        this.recipientSuggestShown = !this.recipientSuggestShown
        if (mutableListOf(ComposeFieldType.subject, ComposeFieldType.body, null).contains(this.focusedField) && this.allRecipients().size > 0 && !this.extendedRecipientFormShown && `field` == ComposeRecipientFieldType.to) {
            this.extendedRecipientFormShown = true
        }
        if (this.focusedField != this.recipientFieldTypeToComposeFieldType(`field`)) {
            this.focusedField = this.recipientFieldTypeToComposeFieldType(`field`)
            this.generateYabbleIfNeeded()
        }
    }

    private fun recipientFieldTypeToComposeFieldType(`field`: ComposeRecipientFieldType): ComposeFieldType {
        when (`field`) {
            ComposeRecipientFieldType.to -> {
                return ComposeFieldType.to
            }
            ComposeRecipientFieldType.cc -> {
                return ComposeFieldType.cc
            }
            ComposeRecipientFieldType.bcc -> {
                return ComposeFieldType.bcc
            }
        }
    }

    private fun composeFieldTypeToRecipientFieldType(`field`: ComposeFieldType): ComposeRecipientFieldType {
        when (`field`) {
            ComposeFieldType.to -> {
                return ComposeRecipientFieldType.to
            }
            ComposeFieldType.cc -> {
                return ComposeRecipientFieldType.cc
            }
            ComposeFieldType.bcc -> {
                return ComposeRecipientFieldType.bcc
            }
            else -> {
                throw YSError("There is no equivalent for ComposeFieldType.${`field`.toString()} in ComposeRecipientFieldType enum")
            }
        }
    }

    open override fun tapOnSenderField(): Unit {
        this.senderSuggestShown = !this.senderSuggestShown
        this.recipientSuggestShown = false
    }

    open override fun getRecipientSuggest(): YSArray<Contact> {
        val filledRecipients = this.allEmailsEnteredToRecipientsFields()
        val contacts = this.contacts.filter( {
            contact ->
            !filledRecipients.contains(contact.email)
        })
        val notGeneratedYabble = this.getNotGeneratedYabble()
        if (notGeneratedYabble == null) {
            return contacts.slice(0, 10)
        }
        val contactsInAbookMatchedWithQuery = contacts.filter( {
            contact ->
            contact.email.includes(notGeneratedYabble.email) || contact.name.includes(notGeneratedYabble.email)
        })
        if (contactsInAbookMatchedWithQuery.size != 0) {
            return contactsInAbookMatchedWithQuery
        }
        if (notGeneratedYabble.email.includes("@")) {
            val splittedEmail = notGeneratedYabble.email.split("@")
            if (splittedEmail.size == 2) {
                val enteredLogin = splittedEmail[0]
                val enteredDomain = splittedEmail[1]
                var domains = copyArray(this.domains)
                if (enteredDomain != "") {
                    domains = domains.filter( {
                        domain ->
                        domain.startsWith(enteredDomain)
                    })
                }
                return domains.map( {
                    domain ->
                    Contact("", "${enteredLogin}@${domain}")
                }).filter( {
                    contact ->
                    !filledRecipients.contains(contact.email)
                })
            }
        }
        return mutableListOf()
    }

    open override fun isRecipientSuggestShown(): Boolean {
        val isSuggestEmpty = this.getRecipientSuggest().size == 0
        return this.recipientSuggestShown && !isSuggestEmpty
    }

    open override fun tapOnRecipientSuggestByEmail(email: String): Unit {
        val contacts = this.getRecipientSuggest().filter( {
            suggestItem ->
            suggestItem.email == email
        })
        if (contacts.size < 0) {
            fail("There is no account with email ${email} in to/cc/bcc suggest")
        }
        this.addYabbleBySuggest(this.composeFieldTypeToRecipientFieldType(this.focusedField!!), contacts[0])
    }

    open override fun tapOnRecipientSuggestByIndex(index: Int): Unit {
        val contacts = this.getRecipientSuggest()
        if (contacts.size <= index) {
            fail("There is no account with index ${index} in to/cc/bcc suggest")
        }
        this.addYabbleBySuggest(this.composeFieldTypeToRecipientFieldType(this.focusedField!!), contacts[index])
    }

    private fun addYabbleBySuggest(`field`: ComposeRecipientFieldType, contact: Contact): Unit {
        val notGeneratedYabble = this.getNotGeneratedYabble()
        if (notGeneratedYabble != null) {
            notGeneratedYabble!!.email = contact.email
            notGeneratedYabble!!.name = contact.name
            notGeneratedYabble!!.type = YabbleType.suggested
        } else {
            this.addYabble(`field`, Yabble(contact.email, contact.name, YabbleType.suggested))
        }
        this.recipientSuggestShown = false
    }

    open fun formatValidEmail(email: String): String {
        var newEmail = email
        val symbolToDelete: YSArray<String> = mutableListOf("\"'\"", "\"")
        symbolToDelete.forEach(__LBL__ComposeModel_2@ {
            symbol ->
            newEmail = stringReplaceAll(newEmail, symbol, "")
        })
        return newEmail
    }

    private fun addYabble(`field`: ComposeRecipientFieldType, yabble: Yabble): Unit {
        if (yabble.type == YabbleType.manual) {
            yabble.email = this.formatValidEmail(yabble.email)
        }
        this.recipientSuggestShown = yabble.type == YabbleType.new
        when (`field`) {
            ComposeRecipientFieldType.to -> {
                this.to.add(yabble)
            }
            ComposeRecipientFieldType.cc -> {
                this.cc.add(yabble)
            }
            ComposeRecipientFieldType.bcc -> {
                this.bcc.add(yabble)
            }
        }
    }

    private fun makeAllYabblesInactive(): Unit {
        this.allRecipients().filter( {
            yabble ->
            yabble.isActive
        }).forEach(__LBL__ComposeModel_3@ {
            yabble ->
            yabble.isActive = false
        })
    }

    open override fun getSenderSuggest(): YSArray<String> {
        return this.aliases
    }

    open override fun isSenderSuggestShown(): Boolean {
        return this.senderSuggestShown
    }

    open override fun tapOnSenderSuggestByEmail(email: String): Unit {
        this.from = email
        this.senderSuggestShown = false
    }

    open override fun tapOnSenderSuggestByIndex(index: Int): Unit {
        this.from = this.aliases[index]
        this.senderSuggestShown = false
    }

    open override fun getBody(): String {
        return this.body
    }

    open override fun setBody(body: String): Unit {
        this.body = if (this.isBodyCleared) body else "${body}\n\n${this.getSignature()}${this.reOrFwdContent}"
    }

    open override fun pasteBody(body: String): Unit {
        this.setBody(body)
    }

    private fun getSignature(): String {
        var signature = this.mailAppModelHandler.getCurrentAccount().accountSettings.signature
        if (signature == "") {
            signature = "--\nSent from Yandex Mail for mobile"
        }
        return stringReplaceAll(signature, "<br>", "\n")
    }

    open override fun clearBody(): Unit {
        this.body = "\n"
        this.isBodyCleared = true
    }

    open override fun tapOnBodyField(): Unit {
        this.extendedRecipientFormShown = false
        this.recipientSuggestShown = false
        this.senderSuggestShown = false
        this.focusedField = ComposeFieldType.body
        this.generateYabbleIfNeeded()
        this.makeAllYabblesInactive()
    }

    open override fun getSubject(): String {
        return this.subject
    }

    open override fun setSubject(subject: String): Unit {
        this.subject = subject
    }

    open override fun tapOnSubjectField(): Unit {
        this.extendedRecipientFormShown = false
        this.recipientSuggestShown = false
        this.senderSuggestShown = false
        this.focusedField = ComposeFieldType.subject
        this.generateYabbleIfNeeded()
        this.makeAllYabblesInactive()
    }

    open fun getAttachments(): YSArray<ComposeAttachment> {
        return this.attachments
    }

}

