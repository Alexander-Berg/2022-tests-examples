// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/components/folder-list-component.ts >>>

package com.yandex.xplat.testopithecus

import com.yandex.xplat.common.*
import com.yandex.xplat.eventus.common.*
import com.yandex.xplat.eventus.*
import com.yandex.xplat.mapi.*
import com.yandex.xplat.testopithecus.common.*

public open class FolderListComponent: MBTComponent {
    open override fun getComponentType(): String {
        return FolderListComponent.type
    }

    open override fun assertMatches(model: App, application: App): Unit {
        val multiAccountModel = MultiAccountFeature.`get`.castIfSupported(model)
        val multiAccountApplication = MultiAccountFeature.`get`.castIfSupported(application)
        if (multiAccountModel != null && multiAccountApplication != null) {
            val currAppAcc = multiAccountApplication.getCurrentAccount()
            val currModelAcc = multiAccountModel.getCurrentAccount()
            assertStringEquals(currModelAcc, currAppAcc, "User Email is incorrect")
            val accNumApp = multiAccountApplication.getNumberOfAccounts()
            val accNumModel = multiAccountModel.getNumberOfAccounts()
            assertInt32Equals(accNumModel, accNumApp, "The number of accounts is incorrect")
        }
        val folderNavigatorModel = FolderNavigatorFeature.`get`.castIfSupported(model)
        val folderNavigatorApplication = FolderNavigatorFeature.`get`.castIfSupported(application)
        if (folderNavigatorModel != null && folderNavigatorApplication != null) {
            val folderListModel = this.formatFolderNameToCounterList(folderNavigatorModel.getFoldersList())
            val folderNamesModel = keysArray(folderListModel)
            val folderListApplication = this.formatFolderNameToCounterList(folderNavigatorApplication.getFoldersList(), folderNamesModel)
            val folderNamesApplication = keysArray(folderListApplication)
            assertInt32Equals(folderNamesModel.size, folderNamesApplication.size, "Different number of folders")
            for (folderName in folderNamesApplication) {
                assertTrue(folderNamesModel.contains(folderName), "There is no folder ${folderName} in model")
            }
            for (folderName in folderNamesApplication) {
                assertInt32Equals(folderListModel.`get`(folderName)!!, folderListApplication.`get`(folderName)!!, "Folder ${folderName} has incorrect unread counter")
            }
            val modelCurrentContainer = folderNavigatorModel.getCurrentContainer()
            val appCurrentContainer = folderNavigatorApplication.getCurrentContainer()
            assertTrue(modelCurrentContainer == appCurrentContainer, "Different current folder. Expected: ${modelCurrentContainer}. Actual: ${appCurrentContainer}")
        }
        val labelNavigatorModel = LabelNavigatorFeature.`get`.castIfSupported(model)
        val labelNavigatorApplication = LabelNavigatorFeature.`get`.castIfSupported(application)
        if (labelNavigatorModel != null && labelNavigatorApplication != null) {
            val labelListModel = labelNavigatorModel.getLabelList()
            val labelListApplication = labelNavigatorApplication.getLabelList()
            assertInt32Equals(labelListModel.size, labelListApplication.size, "Different number of labels")
            for (label in labelListApplication) {
                val labelName = requireNonNull(this.getNotTrimmedContainerNameIfNeeded(label, labelListModel), "There is no label started with ${label}")
                assertTrue(labelListModel.contains(labelName), "There is no label ${label}")
            }
        }
        val clearFolderModel = ClearFolderInFolderListFeature.`get`.castIfSupported(model)
        val clearFolderApp = ClearFolderInFolderListFeature.`get`.castIfSupported(application)
        if (clearFolderModel != null && clearFolderApp != null) {
            assertBooleanEquals(clearFolderModel.doesClearTrashButtonExist(), clearFolderApp.doesClearTrashButtonExist(), "Different clear trash button existence state")
            assertBooleanEquals(clearFolderModel.doesClearSpamButtonExist(), clearFolderApp.doesClearSpamButtonExist(), "Different clear spam button existence state")
        }
        TabBarComponent().assertMatches(model, application)
    }

    private fun getFolderNameFromFullFolderName(fullFolderName: FolderName): FolderName {
        return fullFolderName.split("|").reverse()[0]
    }

    private fun formatFolderNameToCounterList(folderList: YSMap<FolderName, Int>, notTrimmedFolderNames: YSArray<FolderName>? = null): YSMap<FolderName, Int> {
        val result: YSMap<FolderName, Int> = mutableMapOf()
        for (fullFolderName in folderList.keys()) {
            val folderName = this.getFolderNameFromFullFolderName(fullFolderName)
            val formattedFolderName = if (notTrimmedFolderNames == null) folderName else requireNonNull(this.getNotTrimmedContainerNameIfNeeded(folderName, notTrimmedFolderNames), "There is no folder started with ${folderName}")
            result.set(formattedFolderName, folderList.`get`(fullFolderName)!!)
        }
        return result
    }

    private fun getNotTrimmedContainerNameIfNeeded(containerName: String, notTrimmedContainerNames: YSArray<String>): String? {
        if (!containerName.includes("...")) {
            return containerName
        }
        val containerNameWithoutDots = containerName.substring(0, containerName.length - 4)
        for (notTrimmedContainerName in notTrimmedContainerNames) {
            if (notTrimmedContainerName.includes(containerNameWithoutDots)) {
                return notTrimmedContainerName
            }
        }
        return null
    }

    open override fun tostring(): String {
        return this.getComponentType()
    }

    companion object {
        @JvmStatic val type: String = "FolderListComponent"
    }
}

public open class FolderListActions: MBTComponentActions {
    open override fun getActions(_model: App): YSArray<MBTAction> {
        val actions: YSArray<MBTAction> = mutableListOf()
        return actions
    }

}

