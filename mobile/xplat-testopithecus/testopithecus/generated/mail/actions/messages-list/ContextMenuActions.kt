// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/actions/messages-list/context-menu-actions.ts >>>

package com.yandex.xplat.testopithecus

import com.yandex.xplat.common.*
import com.yandex.xplat.eventus.common.*
import com.yandex.xplat.eventus.*
import com.yandex.xplat.mapi.*
import com.yandex.xplat.testopithecus.common.*

public abstract class BaseShortSwipeContextMenuAction protected constructor(protected var order: Int, private var type: MBTActionType): MBTAction {
    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
    }

    open override fun canBePerformed(model: App): Boolean {
        val messageListModel = MessageListDisplayFeature.`get`.forceCast(model)
        val messages = messageListModel.getMessageList(10)
        val canPerform = this.canBePerformedImpl(messages[this.order])
        return this.order < messages.size && canPerform
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        this.performImpl(ContextMenuFeature.`get`.forceCast(model))
        this.performImpl(ContextMenuFeature.`get`.forceCast(application))
        return history.currentComponent
    }

    open override fun getActionType(): MBTActionType {
        return this.type
    }

    open override fun tostring(): String {
        return "${this.type}(${this.order})"
    }

    abstract fun canBePerformedImpl(message: MessageView): Boolean
    abstract fun performImpl(modelOrApplication: ContextMenu): Unit
    abstract override fun events(): YSArray<EventusEvent>
}

public abstract class BaseMailViewContextMenuAction protected constructor(private var type: MBTActionType): MBTAction {
    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
    }

    open override fun canBePerformed(model: App): Boolean {
        val openedMessage = MessageViewerFeature.`get`.forceCast(model).getOpenedMessage().head
        return this.canBePerformedImpl(openedMessage)
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        this.performImpl(ContextMenuFeature.`get`.forceCast(model))
        this.performImpl(ContextMenuFeature.`get`.forceCast(application))
        return history.currentComponent
    }

    open override fun getActionType(): MBTActionType {
        return this.type
    }

    open override fun tostring(): String {
        return "${this.type}"
    }

    abstract fun canBePerformedImpl(message: MessageView): Boolean
    abstract fun performImpl(modelOrApplication: ContextMenu): Unit
    abstract override fun events(): YSArray<EventusEvent>
}

public open class ShortSwipeOpenContextMenuAction(private val order: Int): MBTAction {
    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
    }

    open override fun canBePerformed(model: App): Boolean {
        val isInGroupMode = GroupModeFeature.`get`.forceCast(model).isInGroupMode()
        val isOutgoingFolderOpened = ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer().name == DefaultFolderName.outgoing
        val messages = MessageListDisplayFeature.`get`.forceCast(model).getMessageList(10)
        return !isInGroupMode && !isOutgoingFolderOpened && this.order < messages.size
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf()
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        ContextMenuFeature.`get`.forceCast(model).openFromShortSwipe(this.order)
        ContextMenuFeature.`get`.forceCast(application).openFromShortSwipe(this.order)
        return ContextMenuComponent()
    }

    open override fun tostring(): String {
        return "${ShortSwipeOpenContextMenuAction.type}(${this.order})"
    }

    open override fun getActionType(): MBTActionType {
        return ShortSwipeOpenContextMenuAction.type
    }

    companion object {
        @JvmStatic val type: MBTActionType = "ShortSwipeOpenContextMenuAction"
    }
}

public open class ShortSwipeContextMenuDeleteAction(private val order: Int): MBTAction {
    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
    }

    open override fun canBePerformed(model: App): Boolean {
        return true
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageListEvents.openMessageActions(this.order, fakeMid()), Eventus.messageListEvents.deleteMessage(this.order, fakeMid()))
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromShortSwipe(this.order)
        appContextMenu.openFromShortSwipe(this.order)
        modelContextMenu.deleteMessage()
        appContextMenu.deleteMessage()
        return MaillistComponent()
    }

    open override fun tostring(): String {
        return "${ShortSwipeContextMenuDeleteAction.type}(${this.order})"
    }

    open override fun getActionType(): MBTActionType {
        return ShortSwipeContextMenuDeleteAction.type
    }

    companion object {
        @JvmStatic val type: MBTActionType = "ShortSwipeContextMenuDeleteAction"
    }
}

public open class ShortSwipeContextMenuMarkAsSpamAction(private val order: Int): MBTAction {
    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
    }

    open override fun canBePerformed(model: App): Boolean {
        return ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer().name != DefaultFolderName.spam
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageListEvents.openMessageActions(this.order, fakeMid()), Eventus.messageListEvents.markMessageAsSpam(this.order, fakeMid()))
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromShortSwipe(this.order)
        appContextMenu.openFromShortSwipe(this.order)
        modelContextMenu.markAsSpam()
        appContextMenu.markAsSpam()
        return MaillistComponent()
    }

    open override fun tostring(): String {
        return "${ShortSwipeContextMenuMarkAsSpamAction.type}(${this.order})"
    }

    open override fun getActionType(): MBTActionType {
        return ShortSwipeContextMenuMarkAsSpamAction.type
    }

    companion object {
        @JvmStatic val type: MBTActionType = "ShortSwipeContextMenuMarkAsSpamAction"
    }
}

public open class ShortSwipeContextMenuMarkAsNotSpamAction(private val order: Int): MBTAction {
    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
    }

    open override fun canBePerformed(model: App): Boolean {
        return ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer().name == DefaultFolderName.spam
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageListEvents.openMessageActions(this.order, fakeMid()), Eventus.messageListEvents.markMessageAsNotSpam(this.order, fakeMid()))
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromShortSwipe(this.order)
        appContextMenu.openFromShortSwipe(this.order)
        modelContextMenu.markAsNotSpam()
        appContextMenu.markAsNotSpam()
        return MaillistComponent()
    }

    open override fun tostring(): String {
        return "${ShortSwipeContextMenuMarkAsNotSpamAction.type}(${this.order})"
    }

    open override fun getActionType(): MBTActionType {
        return ShortSwipeContextMenuMarkAsNotSpamAction.type
    }

    companion object {
        @JvmStatic val type: MBTActionType = "ShortSwipeContextMenuMarkAsNotSpamAction"
    }
}

public open class ShortSwipeContextMenuOpenApplyLabelsAction(private val order: Int): MBTAction {
    open override fun canBePerformed(model: App): Boolean {
        return !mutableListOf(DefaultFolderName.spam, DefaultFolderName.trash).contains(ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer().name)
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageListEvents.openMessageActions(this.order, fakeMid()))
    }

    open override fun getActionType(): String {
        return ShortSwipeContextMenuOpenApplyLabelsAction.type
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromShortSwipe(this.order)
        appContextMenu.openFromShortSwipe(this.order)
        modelContextMenu.openApplyLabelsScreen()
        appContextMenu.openApplyLabelsScreen()
        return ApplyLabelComponent()
    }

    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return (MessageListDisplayFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
    }

    open override fun tostring(): String {
        return "${ShortSwipeContextMenuOpenApplyLabelsAction.type}(${this.order})"
    }

    companion object {
        @JvmStatic val type: MBTActionType = "ShortSwipeContextMenuOpenApplyLabelsAction"
    }
}

public open class ShortSwipeContextMenuApplyLabelsAction(private val order: Int, private val labels: YSArray<LabelName>): MBTAction {
    open override fun canBePerformed(model: App): Boolean {
        return !mutableListOf(DefaultFolderName.spam, DefaultFolderName.trash).contains(ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer().name)
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageListEvents.openMessageActions(this.order, fakeMid()), Eventus.messageListEvents.markMessageAs(this.order, fakeMid()))
    }

    open override fun getActionType(): String {
        return ShortSwipeContextMenuApplyLabelsAction.type
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromShortSwipe(this.order)
        appContextMenu.openFromShortSwipe(this.order)
        modelContextMenu.openApplyLabelsScreen()
        appContextMenu.openApplyLabelsScreen()
        val modelApplyLabel = ApplyLabelFeature.`get`.forceCast(model)
        val appApplyLabel = ApplyLabelFeature.`get`.forceCast(application)
        modelApplyLabel.selectLabelsToAdd(this.labels)
        appApplyLabel.selectLabelsToAdd(this.labels)
        modelApplyLabel.tapOnDoneButton()
        appApplyLabel.tapOnDoneButton()
        return history.currentComponent
    }

    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return (ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures) && MessageViewerFeature.`get`.includedAll(modelFeatures, applicationFeatures))
    }

    open override fun tostring(): String {
        return "${ShortSwipeContextMenuApplyLabelsAction.type}(${this.order})"
    }

    companion object {
        @JvmStatic val type: MBTActionType = "ShortSwipeContextMenuApplyLabelsAction"
    }
}

public open class ShortSwipeContextMenuRemoveLabelsAction(private val order: Int, private val labels: YSArray<LabelName>): MBTAction {
    open override fun canBePerformed(model: App): Boolean {
        return !mutableListOf(DefaultFolderName.spam, DefaultFolderName.trash).contains(ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer().name)
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageListEvents.openMessageActions(this.order, fakeMid()), Eventus.messageListEvents.markMessageAs(this.order, fakeMid()))
    }

    open override fun getActionType(): String {
        return ShortSwipeContextMenuRemoveLabelsAction.type
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromShortSwipe(this.order)
        appContextMenu.openFromShortSwipe(this.order)
        modelContextMenu.openApplyLabelsScreen()
        appContextMenu.openApplyLabelsScreen()
        val modelApplyLabel = ApplyLabelFeature.`get`.forceCast(model)
        val appApplyLabel = ApplyLabelFeature.`get`.forceCast(application)
        modelApplyLabel.deselectLabelsToRemove(this.labels)
        appApplyLabel.deselectLabelsToRemove(this.labels)
        modelApplyLabel.tapOnDoneButton()
        appApplyLabel.tapOnDoneButton()
        return history.currentComponent
    }

    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return (MessageListDisplayFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
    }

    open override fun tostring(): String {
        return "${ShortSwipeContextMenuRemoveLabelsAction.type}"
    }

    companion object {
        @JvmStatic val type: MBTActionType = "ShortSwipeContextMenuRemoveLabelsAction"
    }
}

public open class ShortSwipeContextMenuOpenReplyComposeAction(private val order: Int): MBTAction {
    open override fun canBePerformed(model: App): Boolean {
        return !mutableListOf(DefaultFolderName.draft, DefaultFolderName.template).contains(ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer().name)
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageListEvents.openMessageActions(this.order, fakeMid()), Eventus.messageListEvents.replyMessage(this.order, fakeMid()))
    }

    open override fun getActionType(): String {
        return ShortSwipeContextMenuOpenReplyComposeAction.type
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromShortSwipe(this.order)
        appContextMenu.openFromShortSwipe(this.order)
        modelContextMenu.openReplyCompose()
        appContextMenu.openReplyCompose()
        return ComposeComponent()
    }

    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return (MessageListDisplayFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures) && ComposeFeature.`get`.includedAll(modelFeatures, applicationFeatures))
    }

    open override fun tostring(): String {
        return "${ShortSwipeContextMenuOpenReplyComposeAction.type}"
    }

    companion object {
        @JvmStatic val type: MBTActionType = "ShortSwipeContextMenuOpenReplyComposeAction"
    }
}

public open class ShortSwipeContextMenuOpenForwardComposeAction(private val order: Int): MBTAction {
    open override fun canBePerformed(model: App): Boolean {
        return !mutableListOf(DefaultFolderName.draft, DefaultFolderName.template).contains(ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer().name)
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageListEvents.openMessageActions(this.order, fakeMid()), Eventus.messageListEvents.forwardMessage(this.order, fakeMid()))
    }

    open override fun getActionType(): String {
        return ShortSwipeContextMenuOpenReplyComposeAction.type
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromShortSwipe(this.order)
        appContextMenu.openFromShortSwipe(this.order)
        modelContextMenu.openForwardCompose()
        appContextMenu.openForwardCompose()
        return ComposeComponent()
    }

    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return (MessageListDisplayFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures) && ComposeFeature.`get`.includedAll(modelFeatures, applicationFeatures))
    }

    open override fun tostring(): String {
        return "${ShortSwipeContextMenuOpenForwardComposeAction.type}"
    }

    companion object {
        @JvmStatic val type: MBTActionType = "ShortSwipeContextMenuOpenForwardComposeAction"
    }
}

public open class ShortSwipeContextMenuMarkAsReadAction(order: Int): BaseShortSwipeContextMenuAction(order, ShortSwipeContextMenuMarkAsReadAction.type) {
    open override fun performImpl(modelOrApplication: ContextMenu): Unit {
        modelOrApplication.openFromShortSwipe(this.order)
        modelOrApplication.markAsRead()
    }

    open override fun canBePerformedImpl(message: MessageView): Boolean {
        return MarkAsRead.canMarkRead(message)
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageListEvents.openMessageActions(this.order, fakeMid()), Eventus.messageListEvents.markMessageAsRead(this.order, fakeMid()))
    }

    companion object {
        @JvmStatic val type: MBTActionType = "ShortSwipeContextMenuMarkAsReadAction"
    }
}

public open class ShortSwipeContextMenuMarkAsUnreadAction(order: Int): BaseShortSwipeContextMenuAction(order, ShortSwipeContextMenuMarkAsUnreadAction.type) {
    open override fun performImpl(modelOrApplication: ContextMenu): Unit {
        modelOrApplication.openFromShortSwipe(this.order)
        modelOrApplication.markAsUnread()
    }

    open override fun canBePerformedImpl(message: MessageView): Boolean {
        return MarkAsUnread.canMarkUnread(message)
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageListEvents.openMessageActions(this.order, fakeMid()), Eventus.messageListEvents.markMessageAsUnread(this.order, fakeMid()))
    }

    companion object {
        @JvmStatic val type: MBTActionType = "ShortSwipeContextMenuMarkAsUnreadAction"
    }
}

public open class ShortSwipeContextMenuMarkAsImportantAction(order: Int): BaseShortSwipeContextMenuAction(order, ShortSwipeContextMenuMarkAsImportantAction.type) {
    open override fun performImpl(modelOrApplication: ContextMenu): Unit {
        modelOrApplication.openFromShortSwipe(this.order)
        modelOrApplication.markAsImportant()
    }

    open override fun canBePerformedImpl(message: MessageView): Boolean {
        return MarkAsImportant.canMarkImportant(message)
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageListEvents.openMessageActions(this.order, fakeMid()), Eventus.messageListEvents.markMessageAsImportant(this.order, fakeMid()))
    }

    companion object {
        @JvmStatic val type: MBTActionType = "ShortSwipeContextMenuMarkAsImportantAction"
    }
}

public open class ShortSwipeContextMenuMarkAsUnimportantAction(order: Int): BaseShortSwipeContextMenuAction(order, ShortSwipeContextMenuMarkAsUnimportantAction.type) {
    open override fun performImpl(modelOrApplication: ContextMenu): Unit {
        modelOrApplication.openFromShortSwipe(this.order)
        modelOrApplication.markAsUnimportant()
    }

    open override fun canBePerformedImpl(message: MessageView): Boolean {
        return MarkAsUnimportant.canMarkUnimportant(message)
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageListEvents.openMessageActions(1, fakeMid()), Eventus.messageListEvents.markMessageAsNotImportant(1, fakeMid()))
    }

    companion object {
        @JvmStatic val type: MBTActionType = "ShortSwipeContextMenuMarkAsUnimportantAction"
    }
}

public open class ShortSwipeContextMenuOpenMoveToFolderAction(private val order: Int): MBTAction {
    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return (FolderNavigatorFeature.`get`.included(modelFeatures) && MoveToFolderFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
    }

    open override fun canBePerformed(model: App): Boolean {
        return true
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageListEvents.openMessageActions(this.order, fakeMid()))
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromShortSwipe(this.order)
        appContextMenu.openFromShortSwipe(this.order)
        modelContextMenu.openMoveToFolderScreen()
        appContextMenu.openMoveToFolderScreen()
        return MoveToFolderComponent()
    }

    open override fun tostring(): String {
        return "${ShortSwipeContextMenuOpenMoveToFolderAction.type}${this.order}"
    }

    open override fun getActionType(): MBTActionType {
        return ShortSwipeContextMenuOpenMoveToFolderAction.type
    }

    companion object {
        @JvmStatic val type: MBTActionType = "ShortSwipeContextMenuOpenMoveToFolderAction"
    }
}

public open class ShortSwipeContextMenuMoveToFolderAction(private val order: Int, private val folderName: FolderName): MBTAction {
    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return (FolderNavigatorFeature.`get`.included(modelFeatures) && MoveToFolderFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
    }

    open override fun canBePerformed(model: App): Boolean {
        val folderList = FolderNavigatorFeature.`get`.forceCast(model).getFoldersList()
        return folderList.has(this.folderName)
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageListEvents.openMessageActions(this.order, fakeMid()), Eventus.messageListEvents.moveMessageToFolder(this.order, fakeMid()))
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromShortSwipe(this.order)
        appContextMenu.openFromShortSwipe(this.order)
        modelContextMenu.openMoveToFolderScreen()
        appContextMenu.openMoveToFolderScreen()
        MoveToFolderFeature.`get`.forceCast(model).tapOnFolder(this.folderName)
        MoveToFolderFeature.`get`.forceCast(application).tapOnFolder(this.folderName)
        return history.currentComponent
    }

    open override fun tostring(): String {
        return "${ShortSwipeContextMenuOpenMoveToFolderAction.type}${this.order}"
    }

    open override fun getActionType(): MBTActionType {
        return ShortSwipeContextMenuOpenMoveToFolderAction.type
    }

    companion object {
        @JvmStatic val type: MBTActionType = "ShortSwipeContextMenuOpenMoveToFolderAction"
    }
}

public open class ShortSwipeContextMenuArchiveAction(private val order: Int): MBTAction {
    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return (ContainerGetterFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
    }

    open override fun canBePerformed(model: App): Boolean {
        val isInArchiveFolder = ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer().name == DefaultFolderName.archive
        return !isInArchiveFolder
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageListEvents.openMessageActions(this.order, fakeMid()), Eventus.messageListEvents.archiveMessage(this.order, fakeMid()))
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromShortSwipe(this.order)
        appContextMenu.openFromShortSwipe(this.order)
        modelContextMenu.archive()
        appContextMenu.archive()
        return history.currentComponent
    }

    open override fun tostring(): String {
        return "${ShortSwipeContextMenuArchiveAction.type}${this.order}"
    }

    open override fun getActionType(): MBTActionType {
        return ShortSwipeContextMenuArchiveAction.type
    }

    companion object {
        @JvmStatic val type: MBTActionType = "ShortSwipeContextMenuArchiveAction"
    }
}

public open class MessageViewOpenContextMenuAction(): MBTAction {
    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
    }

    open override fun canBePerformed(model: App): Boolean {
        return MessageViewerFeature.`get`.forceCast(model).isMessageOpened()
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf()
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        ContextMenuFeature.`get`.forceCast(model).openFromMessageView()
        ContextMenuFeature.`get`.forceCast(application).openFromMessageView()
        return ContextMenuComponent()
    }

    open override fun tostring(): String {
        return "${MessageViewOpenContextMenuAction.type}"
    }

    open override fun getActionType(): MBTActionType {
        return MessageViewOpenContextMenuAction.type
    }

    companion object {
        @JvmStatic val type: MBTActionType = "MessageViewOpenContextMenuAction"
    }
}

public open class MessageViewContextMenuOpenApplyLabelsAction(): MBTAction {
    open override fun canBePerformed(model: App): Boolean {
        return !mutableListOf(DefaultFolderName.spam, DefaultFolderName.trash).contains(ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer().name)
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageViewEvents.openMessageActions(0))
    }

    open override fun getActionType(): String {
        return MessageViewContextMenuOpenApplyLabelsAction.type
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromMessageView()
        appContextMenu.openFromMessageView()
        modelContextMenu.openApplyLabelsScreen()
        appContextMenu.openApplyLabelsScreen()
        return ApplyLabelComponent()
    }

    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return (MessageListDisplayFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
    }

    open override fun tostring(): String {
        return "${MessageViewContextMenuOpenApplyLabelsAction.type}"
    }

    companion object {
        @JvmStatic val type: MBTActionType = "MessageViewContextMenuOpenApplyLabelsAction"
    }
}

public open class MessageViewContextMenuApplyLabelsAction(private val labels: YSArray<LabelName>): MBTAction {
    open override fun canBePerformed(model: App): Boolean {
        return !mutableListOf(DefaultFolderName.spam, DefaultFolderName.trash).contains(ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer().name)
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.markAs())
    }

    open override fun getActionType(): String {
        return MessageViewContextMenuApplyLabelsAction.type
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromMessageView()
        appContextMenu.openFromMessageView()
        modelContextMenu.openApplyLabelsScreen()
        appContextMenu.openApplyLabelsScreen()
        val modelApplyLabel = ApplyLabelFeature.`get`.forceCast(model)
        val appApplyLabel = ApplyLabelFeature.`get`.forceCast(application)
        modelApplyLabel.selectLabelsToAdd(this.labels)
        appApplyLabel.selectLabelsToAdd(this.labels)
        modelApplyLabel.tapOnDoneButton()
        appApplyLabel.tapOnDoneButton()
        return history.currentComponent
    }

    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return (MessageListDisplayFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures) && MessageViewerFeature.`get`.includedAll(modelFeatures, applicationFeatures))
    }

    open override fun tostring(): String {
        return "${MessageViewContextMenuApplyLabelsAction.type}"
    }

    companion object {
        @JvmStatic val type: MBTActionType = "MessageViewContextMenuApplyLabelsAction"
    }
}

public open class MessageViewContextMenuRemoveLabelsAction(private val labels: YSArray<LabelName>): MBTAction {
    open override fun canBePerformed(model: App): Boolean {
        val modelApplyLabel = ApplyLabelFeature.`get`.forceCast(model)
        val selectedLabels = modelApplyLabel.getSelectedLabels()
        for (label in this.labels) {
            if (!selectedLabels.contains(label)) {
                return false
            }
        }
        return !mutableListOf(DefaultFolderName.spam, DefaultFolderName.trash).contains(ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer().name)
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.markAs())
    }

    open override fun getActionType(): String {
        return MessageViewContextMenuRemoveLabelsAction.type
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromMessageView()
        appContextMenu.openFromMessageView()
        modelContextMenu.openApplyLabelsScreen()
        appContextMenu.openApplyLabelsScreen()
        val modelApplyLabel = ApplyLabelFeature.`get`.forceCast(model)
        val appApplyLabel = ApplyLabelFeature.`get`.forceCast(application)
        modelApplyLabel.deselectLabelsToRemove(this.labels)
        appApplyLabel.deselectLabelsToRemove(this.labels)
        modelApplyLabel.tapOnDoneButton()
        appApplyLabel.tapOnDoneButton()
        return history.currentComponent
    }

    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return (MessageListDisplayFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures) && MessageViewerFeature.`get`.includedAll(modelFeatures, applicationFeatures))
    }

    open override fun tostring(): String {
        return "${MessageViewContextMenuRemoveLabelsAction.type}"
    }

    companion object {
        @JvmStatic val type: MBTActionType = "MessageViewContextMenuRemoveLabelsAction"
    }
}

public open class MessageViewContextMenuOpenMoveToFolderAction(): MBTAction {
    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return (FolderNavigatorFeature.`get`.included(modelFeatures) && MoveToFolderFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
    }

    open override fun canBePerformed(model: App): Boolean {
        return true
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageViewEvents.openMessageActions(0))
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromMessageView()
        appContextMenu.openFromMessageView()
        modelContextMenu.openMoveToFolderScreen()
        appContextMenu.openMoveToFolderScreen()
        return MoveToFolderComponent()
    }

    open override fun tostring(): String {
        return "${MessageViewContextMenuOpenMoveToFolderAction.type}"
    }

    open override fun getActionType(): MBTActionType {
        return MessageViewContextMenuOpenMoveToFolderAction.type
    }

    companion object {
        @JvmStatic val type: MBTActionType = "MessageViewContextMenuOpenMoveToFolderAction"
    }
}

public open class MessageViewContextMenuMoveToFolderAction(private val folderName: FolderName): MBTAction {
    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return (FolderNavigatorFeature.`get`.included(modelFeatures) && MoveToFolderFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
    }

    open override fun canBePerformed(model: App): Boolean {
        val folderList = FolderNavigatorFeature.`get`.forceCast(model).getFoldersList()
        return folderList.has(this.folderName)
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.moveToFolder())
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromMessageView()
        appContextMenu.openFromMessageView()
        modelContextMenu.openMoveToFolderScreen()
        appContextMenu.openMoveToFolderScreen()
        MoveToFolderFeature.`get`.forceCast(model).tapOnFolder(this.folderName)
        MoveToFolderFeature.`get`.forceCast(application).tapOnFolder(this.folderName)
        return history.currentComponent
    }

    open override fun tostring(): String {
        return "${MessageViewContextMenuMoveToFolderAction.type}"
    }

    open override fun getActionType(): MBTActionType {
        return MessageViewContextMenuMoveToFolderAction.type
    }

    companion object {
        @JvmStatic val type: MBTActionType = "MessageViewContextMenuMoveToFolderAction"
    }
}

public open class MessageViewContextMenuDeleteAction(): MBTAction {
    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
    }

    open override fun canBePerformed(model: App): Boolean {
        return true
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.delete())
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromMessageView()
        appContextMenu.openFromMessageView()
        modelContextMenu.deleteMessage()
        appContextMenu.deleteMessage()
        return MaillistComponent()
    }

    open override fun tostring(): String {
        return "${MessageViewContextMenuDeleteAction.type}"
    }

    open override fun getActionType(): MBTActionType {
        return MessageViewContextMenuDeleteAction.type
    }

    companion object {
        @JvmStatic val type: MBTActionType = "MessageViewContextMenuDeleteAction"
    }
}

public open class MessageViewContextMenuMarkAsSpamAction(): MBTAction {
    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
    }

    open override fun canBePerformed(model: App): Boolean {
        return !mutableListOf(DefaultFolderName.sent, DefaultFolderName.spam, DefaultFolderName.draft, DefaultFolderName.template).contains(ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer().name)
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.markAsSpam())
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromMessageView()
        appContextMenu.openFromMessageView()
        modelContextMenu.markAsSpam()
        appContextMenu.markAsSpam()
        return MaillistComponent()
    }

    open override fun tostring(): String {
        return "${MessageViewContextMenuMarkAsSpamAction.type}"
    }

    open override fun getActionType(): MBTActionType {
        return MessageViewContextMenuMarkAsSpamAction.type
    }

    companion object {
        @JvmStatic val type: MBTActionType = "MessageViewContextMenuMarkAsSpamAction"
    }
}

public open class MessageViewContextMenuMarkAsNotSpamAction(): MBTAction {
    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures)
    }

    open override fun canBePerformed(model: App): Boolean {
        return ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer().name == DefaultFolderName.spam
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.markAsNotSpam())
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromMessageView()
        appContextMenu.openFromMessageView()
        modelContextMenu.markAsNotSpam()
        appContextMenu.markAsNotSpam()
        return MaillistComponent()
    }

    open override fun tostring(): String {
        return "${MessageViewContextMenuMarkAsNotSpamAction.type}"
    }

    open override fun getActionType(): MBTActionType {
        return MessageViewContextMenuMarkAsNotSpamAction.type
    }

    companion object {
        @JvmStatic val type: MBTActionType = "MessageViewContextMenuMarkAsNotSpamAction"
    }
}

public open class MessageViewContextMenuMarkAsReadAction(): BaseMailViewContextMenuAction(MessageViewContextMenuMarkAsReadAction.type) {
    open fun requiredFeature(): Feature<ContextMenu> {
        return ContextMenuFeature.`get`
    }

    open override fun canBePerformedImpl(message: MessageView): Boolean {
        return MarkAsRead.canMarkRead(message)
    }

    open override fun performImpl(modelOrApplication: ContextMenu): Unit {
        modelOrApplication.openFromMessageView()
        modelOrApplication.markAsRead()
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.markAsRead())
    }

    companion object {
        @JvmStatic val type: MBTActionType = "MessageViewContextMenuMarkAsReadAction"
    }
}

public open class MessageViewContextMenuMarkAsUnreadAction(): BaseMailViewContextMenuAction(MessageViewContextMenuMarkAsUnreadAction.type) {
    open fun requiredFeature(): Feature<ContextMenu> {
        return ContextMenuFeature.`get`
    }

    open override fun canBePerformedImpl(message: MessageView): Boolean {
        return MarkAsUnread.canMarkUnread(message)
    }

    open override fun performImpl(modelOrApplication: ContextMenu): Unit {
        modelOrApplication.openFromMessageView()
        modelOrApplication.markAsUnread()
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.markAsUnread())
    }

    companion object {
        @JvmStatic val type: MBTActionType = "MessageViewContextMenuMarkAsUnreadAction"
    }
}

public open class MessageViewContextMenuMarkAsImportantAction(): BaseMailViewContextMenuAction(MessageViewContextMenuMarkAsImportantAction.type) {
    open fun requiredFeature(): Feature<ContextMenu> {
        return ContextMenuFeature.`get`
    }

    open override fun canBePerformedImpl(message: MessageView): Boolean {
        return MarkAsImportant.canMarkImportant(message)
    }

    open override fun performImpl(modelOrApplication: ContextMenu): Unit {
        modelOrApplication.openFromMessageView()
        modelOrApplication.markAsImportant()
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.markAsImportant())
    }

    companion object {
        @JvmStatic val type: MBTActionType = "MessageViewContextMenuMarkAsImportantAction"
    }
}

public open class MessageViewContextMenuMarkAsUnimportantAction(): BaseMailViewContextMenuAction(MessageViewContextMenuMarkAsUnimportantAction.type) {
    open fun requiredFeature(): Feature<ContextMenu> {
        return ContextMenuFeature.`get`
    }

    open override fun canBePerformedImpl(message: MessageView): Boolean {
        return MarkAsUnimportant.canMarkUnimportant(message)
    }

    open override fun performImpl(modelOrApplication: ContextMenu): Unit {
        modelOrApplication.openFromMessageView()
        modelOrApplication.markAsUnimportant()
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.markAsNotImportant())
    }

    companion object {
        @JvmStatic val type: MBTActionType = "MessageViewContextMenuMarkAsUnimportantAction"
    }
}

public open class MessageViewContextMenuArchiveAction(): MBTAction {
    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return (ContainerGetterFeature.`get`.included(modelFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
    }

    open override fun canBePerformed(model: App): Boolean {
        val isInArchiveFolder = ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer().name == DefaultFolderName.archive
        return !isInArchiveFolder
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageActionsEvents.archive())
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromMessageView()
        appContextMenu.openFromMessageView()
        modelContextMenu.archive()
        appContextMenu.archive()
        return MaillistComponent()
    }

    open override fun tostring(): String {
        return "${MessageViewContextMenuArchiveAction.type}"
    }

    open override fun getActionType(): MBTActionType {
        return MessageViewContextMenuArchiveAction.type
    }

    companion object {
        @JvmStatic val type: MBTActionType = "MessageViewContextMenuArchiveAction"
    }
}

public open class MessageViewContextMenuShowTranslatorAction(): MBTAction {
    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return (TranslatorBarFeature.`get`.includedAll(modelFeatures, applicationFeatures) && ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures))
    }

    open override fun canBePerformed(model: App): Boolean {
        return true
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageViewEvents.openMessageActions(0))
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromMessageView()
        appContextMenu.openFromMessageView()
        modelContextMenu.showTranslator()
        appContextMenu.showTranslator()
        return history.currentComponent
    }

    open override fun tostring(): String {
        return "${MessageViewContextMenuShowTranslatorAction.type}"
    }

    open override fun getActionType(): MBTActionType {
        return MessageViewContextMenuShowTranslatorAction.type
    }

    companion object {
        @JvmStatic val type: MBTActionType = "MessageViewContextMenuShowTranslatorAction"
    }
}

public open class MessageViewContextMenuOpenReplyComposeAction(): MBTAction {
    open override fun canBePerformed(model: App): Boolean {
        return !mutableListOf(DefaultFolderName.draft, DefaultFolderName.template).contains(ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer().name)
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageViewEvents.reply(0))
    }

    open override fun getActionType(): String {
        return MessageViewContextMenuOpenReplyComposeAction.type
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromMessageView()
        appContextMenu.openFromMessageView()
        modelContextMenu.openReplyCompose()
        appContextMenu.openReplyCompose()
        return ComposeComponent()
    }

    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return (ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures) && ComposeFeature.`get`.includedAll(modelFeatures, applicationFeatures))
    }

    open override fun tostring(): String {
        return "${MessageViewContextMenuOpenReplyComposeAction.type}"
    }

    companion object {
        @JvmStatic val type: MBTActionType = "MessageViewContextMenuOpenReplyComposeAction"
    }
}

public open class MessageViewContextMenuOpenForwardComposeAction(): MBTAction {
    open override fun canBePerformed(model: App): Boolean {
        return !mutableListOf(DefaultFolderName.draft, DefaultFolderName.template).contains(ContainerGetterFeature.`get`.forceCast(model).getCurrentContainer().name)
    }

    open override fun events(): YSArray<EventusEvent> {
        return mutableListOf(Eventus.messageViewEvents.openMessageActions(0), Eventus.messageViewEvents.reply(0))
    }

    open override fun getActionType(): String {
        return MessageViewContextMenuOpenForwardComposeAction.type
    }

    open override fun perform(model: App, application: App, history: MBTHistory): MBTComponent {
        val modelContextMenu = ContextMenuFeature.`get`.forceCast(model)
        val appContextMenu = ContextMenuFeature.`get`.forceCast(application)
        modelContextMenu.openFromMessageView()
        appContextMenu.openFromMessageView()
        modelContextMenu.openForwardCompose()
        appContextMenu.openForwardCompose()
        return ComposeComponent()
    }

    open override fun supported(modelFeatures: YSArray<FeatureID>, applicationFeatures: YSArray<FeatureID>): Boolean {
        return (ContextMenuFeature.`get`.includedAll(modelFeatures, applicationFeatures) && ComposeFeature.`get`.includedAll(modelFeatures, applicationFeatures))
    }

    open override fun tostring(): String {
        return "${MessageViewContextMenuOpenForwardComposeAction.type}"
    }

    companion object {
        @JvmStatic val type: MBTActionType = "MessageViewContextMenuOpenForwardComposeAction"
    }
}

