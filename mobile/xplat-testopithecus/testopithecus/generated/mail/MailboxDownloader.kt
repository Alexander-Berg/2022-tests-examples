// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mail/mailbox-downloader.ts >>>

package com.yandex.xplat.testopithecus

import com.yandex.xplat.common.*
import com.yandex.xplat.eventus.common.*
import com.yandex.xplat.eventus.*
import com.yandex.xplat.mapi.*
import com.yandex.xplat.testopithecus.common.*

public open class MailboxDownloader(private var clients: YSArray<MailboxClient>, private var logger: Logger): AppModelProvider {
    open override fun takeAppModel(): AppModel {
        this.logger.info("Downloading mailbox started")
        val accountsData: YSArray<AccountMailboxData> = mutableListOf()
        for (client in this.clients) {
            this.logger.info("Downloading account (${client.oauthAccount.account.login}) started")
            val filters = client.listFilter().rules
            val settings = client.getSettings().payload!!
            val isTabEnabled = settings.userParameters.showFoldersTabs
            val folderList = client.getFolderList(isTabEnabled).filter( {
                folder ->
                folder.name != DefaultFolderName.outgoing
            })
            val allLabels = client.getLabelList()
            val labelList = allLabels.filter( {
                label ->
                label.type == LabelType.user
            })
            val fidToFolder = mutableMapOf<FolderId, Folder>()
            val lidToLabel = mutableMapOf<LabelID, Label>()
            folderList.forEach( {
                folder ->
                fidToFolder.set(folder.fid, folder)
            })
            labelList.forEach( {
                label ->
                lidToLabel.set(label.lid, label)
            })
            val messages = mutableMapOf<MessageId, FullMessage>()
            val messageToFolder = mutableMapOf<MessageId, FolderName>()
            val messageToLabels = mutableMapOf<MessageId, YSArray<LabelName>>()
            val threads = mutableMapOf<ID, YSSet<MessageId>>()
            val defaultEmail = settings.settingsSetup.defaultEmail
            val aliases = settings.accountInformation.emails.map( {
                email ->
                display(email)
            })
            val replyTo = settings.settingsSetup.replyTo
            val contacts = client.getAllContactsList(1000)
            val zeroSuggest = client.getZeroSuggest().map( {
                suggest ->
                suggest.show_text
            })
            val promoteMail360 = settings.settingsSetup.promoteMail360
            val translationLangs = client.getTranslationLangs().translationLangs
            val translationLangNames = translationLangs.map( {
                lang ->
                lang.name
            })
            val accountSettings = AccountSettingsModel(settings.settingsSetup.folderThreadView, settings.userParameters.showFoldersTabs, settings.settingsSetup.mobileSign, settings.settingsSetup.signatureTop, folderList.map( {
                folder ->
                folder.name!!
            }))
            for (folder in folderList) {
                val messagesDTO = if (isFolderOfThreadedType(folder.type)) client.getThreadsInFolder(folder.fid, 10, isTabEnabled) else client.getMessagesInFolder(folder.fid, 10, isTabEnabled)
                messagesDTO.forEach(__LBL__MailboxDownloader_1@ {
                    messageDTO ->
                    val messageModel = FullMessage.fromMeta(messageDTO)
                    val tid = messageDTO.tid
                    val threadSize = messageModel.head.threadCounter
                    if (tid != null && threadSize != null) {
                        for (threadMessageDTO in client.getMessagesInThread(tid, threadSize, isTabEnabled)) {
                            val mid = threadMessageDTO.mid
                            if (!threads.has(tid)) {
                                threads.set(tid, YSSet())
                            }
                            threads.`get`(tid)!!.add(mid)
                            val messageBody = client.getMessageBody(mid)
                            val langCode = messageBody.lang
                            val quickReply = messageBody.quickReply
                            val smartReplies = messageBody.smartReplies.map( {
                                smartReply ->
                                smartReply.text
                            })
                            messages.set(mid, FullMessage.fromMeta(threadMessageDTO, removeAllNonLetterSymbols(messageBody.body[0].content!!), this.getLanguageNameById(translationLangs, langCode), this.getTranslation(client, langCode, mid), quickReply, smartReplies))
                            messageToFolder.set(mid, requireNonNull(undefinedToNull(fidToFolder.`get`(threadMessageDTO.fid)), "Folder with fid ${threadMessageDTO.fid} has no folder!").name!!)
                            messageToLabels.set(mid, this.getLabelNames(threadMessageDTO, lidToLabel))
                        }
                    } else {
                        val mid = messageDTO.mid
                        val messageBody = client.getMessageBody(mid)
                        val langCode = messageBody.lang
                        val quickReply = messageBody.quickReply
                        val smartReplies = messageBody.smartReplies.map( {
                            smartReply ->
                            smartReply.text
                        })
                        messages.set(mid, FullMessage.fromMeta(messageDTO, removeAllNonLetterSymbols(messageBody.body[0].content!!), this.getLanguageNameById(translationLangs, langCode), this.getTranslation(client, langCode, mid), quickReply, smartReplies))
                        messageToFolder.set(mid, requireNonNull(undefinedToNull(fidToFolder.`get`(messageDTO.fid)), "Folder with fid ${messageDTO.fid} has no folder!").name!!)
                        messageToLabels.set(mid, this.getLabelNames(messageDTO, lidToLabel))
                    }
                })
            }
            val folderToMessages: YSMap<FolderName, YSSet<MessageId>> = mutableMapOf<FolderName, YSSet<MessageId>>()
            val tabsToMessages: YSMap<FolderName, YSSet<MessageId>> = mutableMapOf<FolderName, YSSet<MessageId>>()
            for (folderDTO in folderList) {
                if (isFolderOfTabType(folderDTO.type)) {
                    tabsToMessages.set(formatFolderNameIfNeeded(folderDTO.name!!), YSSet<MessageId>())
                }
                folderToMessages.set(formatFolderNameIfNeeded(folderDTO.name!!), YSSet<MessageId>())
            }
            messageToFolder.__forEach(__LBL__MailboxDownloader_2@ {
                folder, msg ->
                if (isTab(folder)) {
                    tabsToMessages.`get`(formatFolderNameIfNeeded(folder))!!.add(msg)
                }
                folderToMessages.`get`(formatFolderNameIfNeeded(folder))!!.add(msg)
            })
            val labelToMessages: YSMap<LabelName, YSSet<MessageId>> = mutableMapOf<LabelName, YSSet<MessageId>>()
            for (labelDTO in labelList) {
                labelToMessages.set(labelDTO.name!!, YSSet<MessageId>())
            }
            messageToLabels.__forEach(__LBL__MailboxDownloader_3@ {
                labels, msg ->
                labels.forEach(__LBL__MailboxDownloader_4@ {
                    label ->
                    if (!labelToMessages.has(label)) {
                        labelToMessages.set(label, YSSet())
                    }
                    labelToMessages.`get`(label)!!.add(msg)
                })
            })
            val accountData = AccountMailboxData(client, MessageListDatabase(messages, folderToMessages, labelToMessages, tabsToMessages, valuesArray(threads)), defaultEmail, aliases.concat(replyTo), contacts, filters, accountSettings, zeroSuggest, translationLangNames, promoteMail360)
            accountsData.add(accountData)
            this.logger.info("Downloading account (${client.oauthAccount.account.login}) finished")
        }
        this.logger.info("Downloading mailbox finished")
        this.logger.info("\n")
        val accountDataHandler = MailAppModelHandler(accountsData)
        return MailboxModel(accountDataHandler)
    }

    private fun getTranslation(client: MailboxClient, sourceLangCode: LanguageName, mid: ID): YSMap<LanguageName, String> {
        val targetLangCode: LanguageCode = if (sourceLangCode == TranslatorLanguageCode.russian) TranslatorLanguageCode.english else TranslatorLanguageCode.russian
        val targetLangName = if (targetLangCode == TranslatorLanguageCode.english) TranslatorLanguageName.english else TranslatorLanguageName.russian
        return mutableMapOf<LanguageName, String>().set(targetLangName, removeAllNonLetterSymbols(client.translateMessage(mid, targetLangCode).body[0].content))
    }

    private fun getLanguageNameById(translationLangs: YSArray<TranslationLangsPayload>, lang: String): String {
        val filteredLanguage = translationLangs.filter( {
            language ->
            language.lang == lang
        })
        return if (filteredLanguage.size == 1) filteredLanguage[0].name else ""
    }

    private fun getLabelNames(msg: MessageMeta, lidToLabel: YSMap<LabelID, Label>): YSArray<LabelName> {
        val messageLids: YSArray<String> = copyArray(msg.lid)
        return messageLids.filter( {
            lid ->
            lidToLabel.has(lid)
        }).map( {
            lid ->
            lidToLabel.`get`(lid)!!.name!!
        })
    }

}

