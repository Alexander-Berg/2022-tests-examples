import { TSVisibility } from '../../../src/generators-model/basic-types'
import {
  TSBinaryExpression,
  TSCallExpression,
  TSExpressionKind,
  TSIdentifier,
  TSMemberAccessExpression,
  TSUnaryExpression,
} from '../../../src/generators-model/expression'
import { TSExtensionList } from '../../../src/generators-model/global-types'
import { TSExpressionStatement, TSReturnStatement, TSStatementKind } from '../../../src/generators-model/statement'
import Config from '../../../src/generators/swift/config'
import { SwiftFileGenerator } from '../../../src/generators/swift/file-generator'
import Printer from '../../../src/utils/printer'
import {
  alias_,
  any_,
  anyArg,
  arr_,
  arrArg,
  block_,
  bool_,
  boolArg,
  class_,
  constructor_,
  ctorArg,
  double_,
  doubleArg,
  e_empty,
  e_extends,
  e_implements,
  enum_,
  enumWithValues_,
  field_,
  field_extra_,
  fun_,
  funArg,
  function_,
  gen_,
  int32_,
  int32Arg,
  int64_,
  int64Arg,
  interface_,
  lit_,
  m_,
  method_,
  null_,
  nullArg,
  ref_,
  refArg,
  refs_,
  RESERVED_KEYWORD__BREAK__,
  RESERVED_KEYWORD__THROW__,
  str_,
  strArg,
  void_,
} from '../../__helpers__/test-helpers'
import { testTypeMappingsProviderGenerator } from '../../__helpers__/test-type-mapping'

describe(SwiftFileGenerator, () => {
  it('should be able to flush', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.writeHeader()
    const writer = jest.fn(() => {
      /* Empty */
    })
    fileGenerator.flush(writer)
    expect(writer).toHaveBeenCalledWith(
      'output.swift',
      new Printer()
        .addLine('// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM input.ts >>>')
        .addLine()
        .addLine('import Foundation')
        .addLine()
        .print(),
    )
  })
  it('should be able to extend imported types', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    expect(fileGenerator.extendImportedTypes([], '')).toBeUndefined() // As it does nothing
  })

  // HELPERS
  it('should generate visibility', () => {
    expect((SwiftFileGenerator as any).stringifyVisibility(TSVisibility.Private)).toBe('private')
    expect((SwiftFileGenerator as any).stringifyVisibility(TSVisibility.Protected)).toBe('public')
    expect((SwiftFileGenerator as any).stringifyVisibility(TSVisibility.Public)).toBe('public')
  })
  it('should generate public or fileprivate from export', () => {
    expect((SwiftFileGenerator as any).stringifyExport(false)).toBe('fileprivate')
    expect((SwiftFileGenerator as any).stringifyExport(true)).toBe('public')
  })

  // FILE HEADER
  it('should generate file header with empty config', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.writeHeader()
    expect(printer.print()).toBe(
      new Printer()
        .addLine('// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM input.ts >>>')
        .addLine()
        .addLine('import Foundation')
        .addLine()
        .print(),
    )
  })
  it('should generate file header with extra imports from config', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
      { additionalImports: ['Extra1', 'Extra2'], serializableEnums: false } as Config,
    )
    fileGenerator.writeHeader()
    expect(printer.print()).toBe(
      new Printer()
        .addLine('// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM input.ts >>>')
        .addLine()
        .addLine('import Foundation')
        .addLine()
        .addLine('import Extra1')
        .addLine('import Extra2')
        .addLine()
        .print(),
    )
  })

  // ALIASES
  it('should generate aliases for numbers', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(alias_('A1', true, int32_()))
    fileGenerator.write(alias_('A2', true, int64_()))
    fileGenerator.write(alias_('A3', true, double_()))
    expect(printer.print()).toBe(
      'public typealias A1 = Int32\n\npublic typealias A2 = Int64\n\npublic typealias A3 = Double\n\n',
    )
  })
  it('should generate aliases for strings', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(alias_('MyAlias', false, str_()))
    expect(printer.print()).toBe('fileprivate typealias MyAlias = String\n\n')
  })
  it('should generate aliases for boolean', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(alias_('MyAlias', true, bool_()))
    expect(printer.print()).toBe('public typealias MyAlias = Bool\n\n')
  })
  it('should generate aliases for any', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(alias_('MyAlias', false, any_()))
    expect(printer.print()).toBe('fileprivate typealias MyAlias = Any\n\n')
  })
  it('should generate aliases for void', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(alias_('MyAlias', false, void_()))
    expect(printer.print()).toBe('fileprivate typealias MyAlias = Void\n\n')
  })
  it('should generate aliases for closures', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(
      alias_('MyAlias', true, fun_([int32_(), str_(), fun_([str_(), ref_('Error')], void_())], void_())),
    )
    expect(printer.print()).toBe(
      'public typealias MyAlias = (Int32, String, @escaping (String, Error) -> Void) -> Void\n\n',
    )
  })
  it('should generate aliases for arrays', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(
      alias_(
        'MyAlias',
        false,
        arr_(arr_(fun_([str_(), int64_()], fun_([bool_(), arr_(double_(), false)], void_())), false), false),
      ),
    )
    expect(printer.print()).toBe(
      'fileprivate typealias MyAlias = YSArray<YSArray<(String, Int64) -> (Bool, YSArray<Double>) -> Void>>\n\n',
    )
  })

  // ENUMS
  it('should generate empty enums', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(enum_('MyEnum', true))
    const expected = new Printer().beginScope('public enum MyEnum').endScope().print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate standard enums', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(enum_('MyEnum', false, 'A', 'B', 'C'))
    const expected = new Printer()
      .beginScope('fileprivate enum MyEnum')
      .addLine('case A')
      .addLine('case B')
      .addLine('case C')
      .endScope()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate non-serializable standard enums even if option is specicified', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
      { additionalImports: [], serializableEnums: true },
    )
    fileGenerator.write(enum_('MyEnum', false, 'A', 'B', 'C'))
    const expected = new Printer()
      .beginScope('fileprivate enum MyEnum')
      .addLine('case A')
      .addLine('case B')
      .addLine('case C')
      .endScope()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate enums with string raw values', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(
      enumWithValues_('MyEnum', true, [
        {
          name: 'A',
          value: 'AAA',
        },
        {
          name: 'B',
          value: '"BBB"',
        },
      ]),
    )
    const expected = new Printer()
      .beginScope('public enum MyEnum : String')
      .addLine('case A = "AAA"')
      .addLine('case B = "\\"BBB\\""')
      .beginScope('public func toString() -> String')
      .addLine('return self.rawValue')
      .endScope()
      .endScope()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate serializable enums with string raw values', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
      { serializableEnums: true, additionalImports: [] },
    )
    fileGenerator.write(
      enumWithValues_('MyEnum', true, [
        {
          name: 'A',
          value: 'AAA',
        },
        {
          name: 'B',
          value: '"BBB"',
        },
      ]),
    )
    const expected = new Printer()
      .beginScope('public enum MyEnum : String, Codable')
      .addLine('case A = "AAA"')
      .addLine('case B = "\\"BBB\\""')
      .beginScope('public func toString() -> String')
      .addLine('return self.rawValue')
      .endScope()
      .endScope()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate enums with number raw values', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(
      enumWithValues_('MyEnum', false, [
        {
          name: 'A',
          value: 10,
        },
        {
          name: 'B',
          value: 20,
        },
      ]),
    )
    const expected = new Printer()
      .beginScope('fileprivate enum MyEnum : Int32')
      .addLine('case A = 10')
      .addLine('case B = 20')
      .beginScope('fileprivate func toInt() -> Int32')
      .addLine('return self.rawValue')
      .endScope()
      .endScope()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate serializable enums with number raw values', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
      { serializableEnums: true, additionalImports: [] },
    )
    fileGenerator.write(
      enumWithValues_('MyEnum', false, [
        {
          name: 'A',
          value: 10,
        },
        {
          name: 'B',
          value: 20,
        },
      ]),
    )
    const expected = new Printer()
      .beginScope('fileprivate enum MyEnum : Int32, Codable')
      .addLine('case A = 10')
      .addLine('case B = 20')
      .beginScope('fileprivate func toInt() -> Int32')
      .addLine('return self.rawValue')
      .endScope()
      .endScope()
      .print()
    expect(printer.print()).toBe(expected)
  })

  // FUNCTIONS
  it('should generate non-args function declarations', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(function_('f', [], int64_(), [], true))
    const expected = new Printer().addLine('@discardableResult').addLine('public func f() -> Int64').print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function declarations', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(
      function_(
        'f',
        [arrArg('a', double_(), false), int32Arg('n'), funArg('f', [bool_(), str_()], any_())],
        fun_([int64_(), str_()], void_()),
        [],
        true,
      ),
    )
    const expected = new Printer()
      .addLine('@discardableResult')
      .addLine(
        'public func f(_ a: YSArray<Double>, _ n: Int32, _ f: @escaping (Bool, String) -> Any)' +
          ' -> (Int64, String) -> Void',
      )
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate generic function declarations', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(
      function_(
        'f',
        [arrArg('a', ref_('A'), false), int32Arg('n'), funArg('f', [bool_(), str_()], any_())],
        fun_([int64_(), str_()], ref_('B')),
        [gen_('A'), gen_('B')],
        true,
      ),
    )
    const expected = new Printer()
      .addLine('@discardableResult')
      .addLine(
        'public func f<A, B>(_ a: YSArray<A>, _ n: Int32, _ f: @escaping (Bool, String) -> Any)' +
          ' -> (Int64, String) -> B',
      )
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function declarations with empty body', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(
      function_(
        'f',
        [arrArg('a', ref_('A'), false), int64Arg('n'), funArg('f', [bool_(), null_(str_())], any_())],
        fun_([int32_(), str_()], ref_('B')),
        [gen_('A'), gen_('B')],
        true,
        block_(),
      ),
    )
    const expected = new Printer()
      .addLine('@discardableResult')
      .beginScope(
        'public func f<A, B>(_ a: YSArray<A>, _ n: Int64, _ f: @escaping (Bool, String?) -> Any)' +
          ' -> (Int32, String) -> B',
      )
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function declarations with non-empty body', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(
      function_(
        'f',
        [arrArg('a', ref_('A'), false), int64Arg('n'), funArg('f', [null_(bool_()), str_()], any_())],
        fun_([int32_(), str_()], ref_('B')),
        [gen_('A'), gen_('B')],
        true,
        block_([
          {
            kind: TSStatementKind.Return,
            expression: {
              kind: TSExpressionKind.Unary,
              operator: '!',
              operand: {
                kind: TSExpressionKind.Identifier,
                name: 'a',
              } as TSIdentifier,
            } as TSUnaryExpression,
          } as TSReturnStatement,
        ]),
      ),
    )
    const expected = new Printer()
      .addLine('@discardableResult')
      .beginScope(
        'public func f<A, B>(_ a: YSArray<A>, _ n: Int64, _ f: @escaping (Bool?, String) -> Any)' +
          ' -> (Int32, String) -> B',
      )
      .addLine('return !a')
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with constraints generics', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(
      function_(
        'f',
        [arrArg('a', ref_('A'), false)],
        void_(),
        [
          gen_('T1', refs_('C1', 'I1', 'I2')),
          gen_('T2', [ref_('C1', [arr_(int32_(), false)]), ref_('I1'), ref_('I2')]),
          gen_('T3', refs_('C1')),
          gen_('T4', refs_('I1', 'I2')),
        ],
        true,
      ),
    )
    const line =
      'public func f<T1: C1 & I1 & I2, T2: C1<YSArray<Int32>> & I1 & I2, T3: C1, T4: I1 & I2>(_ a: YSArray<A>) -> Void'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with default string value', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(function_('f', [strArg('a', 'default')], void_(), [], true))
    const line = 'public func f(_ a: String = "default") -> Void'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with default nil string value', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(function_('f', [nullArg(strArg('a'), null)], void_(), [], true))
    const line = 'public func f(_ a: String! = nil) -> Void'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with default int32 value', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(function_('f', [int32Arg('a', 5)], void_(), [], true))
    const line = 'public func f(_ a: Int32 = 5) -> Void'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with nullable int32 value, nil as default', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(function_('f', [nullArg(int32Arg('a'), null)], void_(), [], true))
    const line = 'public func f(_ a: Int32! = nil) -> Void'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with default int64 value', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(function_('f', [int64Arg('a', 5)], void_(), [], true))
    const line = 'public func f(_ a: Int64 = 5) -> Void'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with nullabe int64 value, nil as default', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(function_('f', [nullArg(int64Arg('a'), null)], void_(), [], true))
    const line = 'public func f(_ a: Int64! = nil) -> Void'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with default boolean value (true)', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(function_('f', [boolArg('a', true)], void_(), [], true))
    const line = 'public func f(_ a: Bool = true) -> Void'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with default boolean value (false)', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(function_('f', [boolArg('a', false)], void_(), [], true))
    const line = 'public func f(_ a: Bool = false) -> Void'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with nullable boolean value, nil as default', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(function_('f', [nullArg(boolArg('a'), null)], void_(), [], true))
    const line = 'public func f(_ a: Bool! = nil) -> Void'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with default double value', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(function_('f', [doubleArg('a', 10.5)], void_(), [], true))
    const line = 'public func f(_ a: Double = 10.5) -> Void'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with nullable double value, null as default', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(function_('f', [nullArg(doubleArg('a'), null)], void_(), [], true))
    const line = 'public func f(_ a: Double! = nil) -> Void'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it("should generate function without default value when it's not set", () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(function_('f', [anyArg('a')], void_(), [], true))
    const line = 'public func f(_ a: Any) -> Void'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with reserved keyword in its name and parameters', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(
      function_(RESERVED_KEYWORD__BREAK__, [refArg(RESERVED_KEYWORD__THROW__, 'A')], void_(), [], true),
    )
    const line = `public func \`${RESERVED_KEYWORD__BREAK__}\`(_ \`${RESERVED_KEYWORD__THROW__}\`: A) -> Void`
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })

  // INTERFACES
  it('should generate protocol without methods', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(interface_('I', [], [], true, []))
    const expected = new Printer().beginScope('public protocol I').endScope().addLine().print()
    expect(printer.print()).toBe(expected)
  })
  it('should skip generics from protocol definition (not supported)', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(interface_('I', [], [], false, []))
    const expected = new Printer().beginScope('fileprivate protocol I').endScope().addLine().print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate protocol with extension list', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(interface_('I', refs_('I1', 'I2'), [], true, []))
    const expected = new Printer().beginScope('public protocol I: I1, I2').endScope().addLine().print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate protocol with methods list', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    const methods = [
      method_('m1', TSVisibility.Public, [], void_(), m_(false, false, false, false), []),
      method_(
        'm2',
        TSVisibility.Protected,
        [refArg('a', 'A'), int32Arg('n'), refArg('c', 'C')],
        fun_([null_(double_())], ref_('B')),
        m_(false, true, false, false),
        [gen_('C')],
      ),
      method_('m3', TSVisibility.Public, [nullArg(strArg('a'))], null_(str_()), m_(false, false, false, false), []),
      method_(
        RESERVED_KEYWORD__BREAK__,
        TSVisibility.Private,
        [refArg(RESERVED_KEYWORD__THROW__, 'A')],
        void_(),
        m_(false, false, false, false),
        [],
      ),
    ]
    fileGenerator.write(interface_('I', refs_('I1', 'I2'), methods, true, []))
    const expected = new Printer()
      .beginScope('public protocol I: I1, I2')
      .addLine('func m1() -> Void')
      .addLine('@discardableResult')
      .addLine('static func m2<C>(_ a: A, _ n: Int32, _ c: C) -> (Double?) -> B')
      .addLine('@discardableResult')
      .addLine('func m3(_ a: String!) -> String!')
      .addLine(`func \`${RESERVED_KEYWORD__BREAK__}\`(_ \`${RESERVED_KEYWORD__THROW__}\`: A) -> Void`)
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate protocol with property list', () => {
    const printer = new Printer()
    const fields = [
      field_('prop1', int32_(), TSVisibility.Public, field_extra_(false, false, false, false, false)),
      field_('prop2', int32_(), TSVisibility.Public, field_extra_(true, false, false, false, false)),
      field_(RESERVED_KEYWORD__BREAK__, bool_(), TSVisibility.Public, field_extra_(true, false, false, false, false)),
    ]
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(interface_('A1', [], [], true, fields))
    const expected = new Printer()
      .beginScope('public protocol A1')
      .addLine('var prop1: Int32 { get set }')
      .addLine('var prop2: Int32 { get }')
      .addLine(`var \`${RESERVED_KEYWORD__BREAK__}\`: Bool { get }`)
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })

  // CLASSES
  it('should generate class without members if none provided', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(
      class_(
        'C',
        {
          extendsType: ref_('C1', [ref_('C11', [int32_(), ref_('C111')])]),
          implementsList: refs_('I1', 'I2'),
        } as TSExtensionList,
        undefined, // constructor
        [], // methods
        [], // fields
        true, // abstract
        true, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer().beginScope('open class C: C1<C11<Int32, C111>>, I1, I2').endScope().addLine().print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate class with methods', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    const methods = [
      method_('m1', TSVisibility.Public, [], void_(), m_(false, false, false, true), []),
      method_(
        'm2',
        TSVisibility.Protected,
        [nullArg(refArg('a', 'A')), doubleArg('n'), refArg('c', 'C')],
        fun_([int32_()], ref_('B')),
        m_(true, false, false, true),
        [gen_('C')],
      ),
      method_(
        'm3',
        TSVisibility.Private,
        [refArg('a', 'A'), int64Arg('n'), refArg('c', 'C')],
        fun_([double_()], ref_('B')),
        m_(false, true, false, true),
        [gen_('C')],
      ),
      method_(
        'm4',
        TSVisibility.Public,
        [strArg('a'), int32Arg('n')],
        void_(),
        m_(false, false, true, false),
        [],
        block_([
          {
            kind: TSStatementKind.ExpressionStatement,
            expression: {
              kind: TSExpressionKind.Call,
              expression: {
                kind: TSExpressionKind.Identifier,
                name: 'f',
              } as TSIdentifier,
              args: [lit_(10)],
              typeArguments: [],
              optionalChaining: false,
            } as TSCallExpression,
          } as TSExpressionStatement,
          {
            kind: TSStatementKind.ExpressionStatement,
            expression: {
              kind: TSExpressionKind.Call,
              expression: {
                kind: TSExpressionKind.Identifier,
                name: 'g',
              } as TSIdentifier,
              args: [lit_('hi')],
              typeArguments: [],
              optionalChaining: false,
            } as TSCallExpression,
          } as TSExpressionStatement,
        ]),
      ),
      method_(
        'm5',
        TSVisibility.Public,
        [funArg('f', [null_(str_())], null_(int32_()))],
        null_(fun_([null_(str_())], null_(ref_('A')))),
        m_(false, false, false, false),
        [],
      ),
      method_(
        RESERVED_KEYWORD__BREAK__,
        TSVisibility.Public,
        [refArg(RESERVED_KEYWORD__THROW__, 'A')],
        void_(),
        m_(false, false, false, false),
        [],
      ),
    ]
    fileGenerator.write(
      class_(
        'C',
        e_implements(['I1, I2']),
        undefined, // constructor
        methods, // methods
        [], // fields
        true, // abstract
        false, // export
        [gen_('A'), gen_('B')], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('fileprivate class C<A, B>: I1, I2')
      .beginScope('public func m1() -> Void')
      .endScope()
      .addLine()
      .addLine('@discardableResult')
      .beginScope('public func m2<C>(_ a: A!, _ n: Double, _ c: C) -> (Int32) -> B')
      .addLine('fatalError("Must be overridden in subclasses")')
      .endScope()
      .addLine()
      .addLine('@discardableResult')
      .beginScope('private class func m3<C>(_ a: A, _ n: Int64, _ c: C) -> (Double) -> B')
      .endScope()
      .addLine()
      .beginScope('public override func m4(_ a: String, _ n: Int32) -> Void')
      .addLine('f(10)')
      .addLine('g("hi")')
      .endScope()
      .addLine()
      .addLine('@discardableResult')
      .beginScope('public func m5(_ f: @escaping (String?) -> Int32?) -> ((String?) -> A?)!')
      .endScope()
      .addLine()
      .beginScope(`public func \`${RESERVED_KEYWORD__BREAK__}\`(_ \`${RESERVED_KEYWORD__THROW__}\`: A) -> Void`)
      .endScope()
      .addLine()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate proper visibility qualifiers for methods if exported class', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    const methods = [
      method_('m1', TSVisibility.Public, [], void_(), m_(false, false, false, false), []),
      method_('m2', TSVisibility.Protected, [], void_(), m_(false, false, false, false), []),
      method_('m3', TSVisibility.Private, [], void_(), m_(false, false, false, false), []),
    ]
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        undefined, // constructor
        methods, // methods
        [], // fields
        false, // abstract
        true, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('open class C')
      .beginScope('open func m1() -> Void')
      .endScope()
      .addLine()
      .beginScope('open func m2() -> Void')
      .endScope()
      .addLine()
      .beginScope('private func m3() -> Void')
      .endScope()
      .addLine()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate proper visibility qualifiers for methods if non-exported class', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    const methods = [
      method_('m1', TSVisibility.Public, [], void_(), m_(false, false, false, false), []),
      method_('m2', TSVisibility.Protected, [], void_(), m_(false, false, false, false), []),
      method_('m3', TSVisibility.Private, [], void_(), m_(false, false, false, false), []),
    ]
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        undefined, // constructor
        methods, // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('fileprivate class C')
      .beginScope('public func m1() -> Void')
      .endScope()
      .addLine()
      .beginScope('public func m2() -> Void')
      .endScope()
      .addLine()
      .beginScope('private func m3() -> Void')
      .endScope()
      .addLine()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate class with fields', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    const fields = [
      field_('f1', int32_(), TSVisibility.Public, field_extra_(false, false, false, false, false), lit_(0)),
      field_('f2', ref_('A'), TSVisibility.Private, field_extra_(true, false, false, false, false)),
      field_('f3', int64_(), TSVisibility.Protected, field_extra_(true, true, false, false, false), lit_(0)),
      field_('f4', str_(), TSVisibility.Public, field_extra_(false, true, false, false, false), lit_('Hello')),
      field_('f5', null_(ref_('T')), TSVisibility.Public, field_extra_(false, false, true, false, false), lit_(null)),
      field_('f6', null_(ref_('T')), TSVisibility.Public, field_extra_(true, false, true, false, false), lit_(null)),
      field_(
        'f7',
        null_(fun_(refs_('A'), null_(ref_('B')))),
        TSVisibility.Private,
        field_extra_(true, false, false, false, false),
      ),
      field_('f8', arr_(null_(str_()), false), TSVisibility.Private, field_extra_(true, false, false, false, false)),
      field_(
        RESERVED_KEYWORD__BREAK__,
        str_(),
        TSVisibility.Public,
        field_extra_(false, false, false, false, false),
        lit_('instance field'),
      ),
      field_(
        RESERVED_KEYWORD__THROW__,
        str_(),
        TSVisibility.Public,
        field_extra_(false, true, false, false, false),
        lit_('static field'),
      ),
    ]
    fileGenerator.write(
      class_(
        'C',
        e_extends('B'),
        undefined, // constructor
        [], // methods
        fields, // fields
        false, // abstract
        true, // export
        [gen_('A')], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('open class C<A>: B')
      .addLine('public var f1: Int32 = 0')
      .addLine('private let f2: A')
      .addLine('public static let f3: Int64 = 0')
      .addLine('public static var f4: String = "Hello"')
      .addLine('public weak var f5: T! = nil')
      .addLine('public weak var f6: T! = nil') // Weak properties are `var` disregarding readonly settings.
      .addLine('private let f7: ((A) -> B?)!')
      .addLine('private let f8: YSArray<String?>')
      .addLine(`public var \`${RESERVED_KEYWORD__BREAK__}\`: String = "instance field"`)
      .addLine(`public static var \`${RESERVED_KEYWORD__THROW__}\`: String = "static field"`)
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate constructor', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    const args = [ctorArg('a', int32_()), ctorArg('b', str_()), ctorArg(RESERVED_KEYWORD__BREAK__, str_())]
    const ctor = constructor_(args, TSVisibility.Public, false, block_())
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        ctor, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('fileprivate class C')
      .beginScope(`public init(_ a: Int32, _ b: String, _ \`${RESERVED_KEYWORD__BREAK__}\`: String)`)
      .endScope()
      .addLine()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate constructor with single statement', () => {
    function fieldAssignmentStatement(name: string): TSExpressionStatement {
      return {
        kind: TSStatementKind.ExpressionStatement,
        expression: {
          kind: TSExpressionKind.Binary,
          operator: '=',
          left: {
            kind: TSExpressionKind.MemberAccess,
            object: {
              kind: TSExpressionKind.This,
            },
            member: {
              kind: TSExpressionKind.Identifier,
              name,
            },
          } as TSMemberAccessExpression,
          right: {
            kind: TSExpressionKind.Identifier,
            name,
          } as TSIdentifier,
        } as TSBinaryExpression,
      }
    }

    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    const ctor = constructor_(
      [ctorArg('a', int64_()), ctorArg('b', str_())],
      TSVisibility.Public,
      false,
      block_([fieldAssignmentStatement('a')]),
    )
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        ctor, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('fileprivate class C')
      .beginScope('public init(_ a: Int64, _ b: String)')
      .addLine('self.a = a')
      .endScope()
      .addLine()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate constructor with more that one statements', () => {
    function fieldAssignmentStatement(name: string): TSExpressionStatement {
      return {
        kind: TSStatementKind.ExpressionStatement,
        expression: {
          kind: TSExpressionKind.Binary,
          operator: '=',
          left: {
            kind: TSExpressionKind.MemberAccess,
            object: {
              kind: TSExpressionKind.This,
            },
            member: {
              kind: TSExpressionKind.Identifier,
              name,
            },
          } as TSMemberAccessExpression,
          right: {
            kind: TSExpressionKind.Identifier,
            name,
          } as TSIdentifier,
        } as TSBinaryExpression,
      }
    }

    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    const ctor = constructor_(
      [ctorArg('a', double_()), ctorArg('b', str_())],
      TSVisibility.Public,
      false,
      block_([fieldAssignmentStatement('a'), fieldAssignmentStatement('b')]),
    )
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        ctor, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('fileprivate class C')
      .beginScope('public init(_ a: Double, _ b: String)')
      .addLine('self.a = a')
      .addLine('self.b = b')
      .endScope()
      .addLine()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate constructor with single super call', () => {
    function superCallWithArgument(name: string): TSExpressionStatement {
      return {
        kind: TSStatementKind.ExpressionStatement,
        expression: {
          kind: TSExpressionKind.Call,
          expression: {
            kind: TSExpressionKind.Super,
          },
          args: [
            {
              kind: TSExpressionKind.Identifier,
              name,
            } as TSIdentifier,
          ],
          typeArguments: [],
          optionalChaining: false,
        } as TSCallExpression,
      }
    }

    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    const ctor = constructor_(
      [ctorArg('a', int32_()), ctorArg('b', str_())],
      TSVisibility.Public,
      false,
      block_([superCallWithArgument('a')]),
    )
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        ctor, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('fileprivate class C')
      .beginScope('public init(_ a: Int32, _ b: String)')
      .addLine('super.init(a)')
      .endScope()
      .addLine()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate constructor with rearranged calls if super and other statements are there single', () => {
    function superCallWithArgument(name: string): TSExpressionStatement {
      return {
        kind: TSStatementKind.ExpressionStatement,
        expression: {
          kind: TSExpressionKind.Call,
          expression: {
            kind: TSExpressionKind.Super,
          },
          args: [
            {
              kind: TSExpressionKind.Identifier,
              name,
            } as TSIdentifier,
          ],
          typeArguments: [],
          optionalChaining: false,
        } as TSCallExpression,
      }
    }
    function fieldAssignmentStatement(name: string): TSExpressionStatement {
      return {
        kind: TSStatementKind.ExpressionStatement,
        expression: {
          kind: TSExpressionKind.Binary,
          operator: '=',
          left: {
            kind: TSExpressionKind.MemberAccess,
            object: {
              kind: TSExpressionKind.This,
            },
            member: {
              kind: TSExpressionKind.Identifier,
              name,
            },
          } as TSMemberAccessExpression,
          right: {
            kind: TSExpressionKind.Identifier,
            name,
          } as TSIdentifier,
        } as TSBinaryExpression,
      }
    }

    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    const ctor = constructor_(
      [ctorArg('a', int64_()), ctorArg('b', str_())],
      TSVisibility.Public,
      false,
      block_([superCallWithArgument('a'), fieldAssignmentStatement('b')]),
    )
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        ctor, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('fileprivate class C')
      .beginScope('public init(_ a: Int64, _ b: String)')
      .addLine('self.b = b')
      .addLine('super.init(a)')
      .endScope()
      .addLine()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate fields for constructor with properties, body and super call', () => {
    function superCall(): TSExpressionStatement {
      return {
        kind: TSStatementKind.ExpressionStatement,
        expression: {
          kind: TSExpressionKind.Call,
          expression: {
            kind: TSExpressionKind.Super,
          },
          args: [],
          typeArguments: [],
          optionalChaining: false,
        } as TSCallExpression,
      }
    }
    function fieldAssignmentStatement(name: string, value: string): TSExpressionStatement {
      return {
        kind: TSStatementKind.ExpressionStatement,
        expression: {
          kind: TSExpressionKind.Binary,
          operator: '=',
          left: {
            kind: TSExpressionKind.MemberAccess,
            object: {
              kind: TSExpressionKind.This,
            },
            member: {
              kind: TSExpressionKind.Identifier,
              name,
            },
          } as TSMemberAccessExpression,
          right: lit_(value),
        } as TSBinaryExpression,
      }
    }

    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    const ctor = constructor_(
      [
        ctorArg('a', int64_(), true, false, false, TSVisibility.Private),
        ctorArg('b', str_(), false, false, false, TSVisibility.Public),
        ctorArg('c', bool_(), true, false, false, TSVisibility.Protected, lit_(true)),
      ],
      TSVisibility.Public,
      false,
      block_([superCall(), fieldAssignmentStatement('d', 'hello')]),
    )
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        ctor, // constructor
        [], // methods
        [field_('d', str_(), TSVisibility.Private, field_extra_(false, false, false, false, false))], // fields
        false, // abstract
        false, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('fileprivate class C')
      .addLine('private var d: String')
      .addLine('private let a: Int64')
      .addLine('public var b: String')
      .addLine('public let c: Bool')
      .beginScope('public init(_ a: Int64, _ b: String, _ c: Bool = true)')
      .addLine('self.a = a')
      .addLine('self.b = b')
      .addLine('self.c = c')
      .addLine('self.d = "hello"')
      .addLine('super.init()')
      .endScope()
      .addLine()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate fields for constructor with properties, no body and no super call', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    const ctor = constructor_(
      [
        ctorArg('a', int64_(), true, false, false, TSVisibility.Private),
        ctorArg('b', str_(), false, false, false, TSVisibility.Public),
        ctorArg('c', bool_(), true, false, false, TSVisibility.Protected, lit_(true)),
      ],
      TSVisibility.Public,
      false,
      block_(),
    )
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        ctor, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('fileprivate class C')
      .addLine('private let a: Int64')
      .addLine('public var b: String')
      .addLine('public let c: Bool')
      .beginScope('public init(_ a: Int64, _ b: String, _ c: Bool = true)')
      .addLine('self.a = a')
      .addLine('self.b = b')
      .addLine('self.c = c')
      .endScope()
      .addLine()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate class with constraints generics', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        undefined, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [
          gen_('T1', refs_('C1', 'I1', 'I2')),
          gen_('T2', [ref_('C1', [arr_(int32_(), false)]), ref_('I1'), ref_('I2')]),
          gen_('T3', refs_('C1')),
          gen_('T4', refs_('I1', 'I2')),
        ], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('fileprivate class C<T1: C1 & I1 & I2, T2: C1<YSArray<Int32>> & I1 & I2, T3: C1, T4: I1 & I2>')
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate class with mutable property in implementing class', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    const classFields = [
      field_('prop1', int32_(), TSVisibility.Public, field_extra_(false, false, false, true, false), lit_(42)),
    ]
    const extensionsList = {
      implementsList: refs_('A1'),
    } as TSExtensionList
    const implementingClass = class_('B1', extensionsList, undefined, [], classFields, false, true, [], false, false)
    fileGenerator.write(implementingClass)

    const expected = new Printer()
      .beginScope('open class B1: A1')
      .addLine('public var prop1: Int32 = 42')
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate class with readonly property in implementing class', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    const classFields = [
      field_('prop1', int32_(), TSVisibility.Public, field_extra_(true, false, false, true, false), lit_(42)),
    ]
    const extensionsList = {
      implementsList: refs_('A1'),
    } as TSExtensionList
    const implementingClass = class_('B1', extensionsList, undefined, [], classFields, false, true, [], false, false)
    fileGenerator.write(implementingClass)

    const expected = new Printer()
      .beginScope('open class B1: A1')
      .addLine('public let prop1: Int32 = 42')
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate class with codable protocol if serializable annotation provided', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        undefined, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        true, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer().beginScope('fileprivate class C: Codable').endScope().addLine().print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate class conforming to interfaces once to each one (no duplicates)', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(
      class_(
        'C',
        e_implements(['I1', 'I1']),
        undefined, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        true, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer().beginScope('fileprivate class C: I1, Codable').endScope().addLine().print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate class with codable protocol if serializable annotation and additional protocol provided', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(
      class_(
        'C',
        e_implements(['I1, I2']),
        undefined, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        true, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer().beginScope('fileprivate class C: I1, I2, Codable').endScope().addLine().print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate class with override init if constructor is marked overriding', () => {
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    fileGenerator.write(
      class_(
        'C',
        e_extends('A'),
        constructor_([], TSVisibility.Public, true, block_()),
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('fileprivate class C: A')
      .beginScope('public override init()')
      .endScope()
      .addLine()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate serializable class with custom json serialized name for field', () => {
    function superCall(): TSExpressionStatement {
      return {
        kind: TSStatementKind.ExpressionStatement,
        expression: {
          kind: TSExpressionKind.Call,
          expression: {
            kind: TSExpressionKind.Super,
          },
          args: [],
          typeArguments: [],
          optionalChaining: false,
        } as TSCallExpression,
      }
    }
    function fieldAssignmentStatement(name: string, value: string): TSExpressionStatement {
      return {
        kind: TSStatementKind.ExpressionStatement,
        expression: {
          kind: TSExpressionKind.Binary,
          operator: '=',
          left: {
            kind: TSExpressionKind.MemberAccess,
            object: {
              kind: TSExpressionKind.This,
            },
            member: {
              kind: TSExpressionKind.Identifier,
              name,
            },
          } as TSMemberAccessExpression,
          right: lit_(value),
        } as TSBinaryExpression,
      }
    }
    const printer = new Printer()
    const fileGenerator = new SwiftFileGenerator(
      'input.ts',
      'output.swift',
      printer,
      testTypeMappingsProviderGenerator(),
    )
    const classFields = [
      field_('prop1', int32_(), TSVisibility.Public, field_extra_(true, false, false, true, false, 'prop2'), lit_(42)),
      field_('d', str_(), TSVisibility.Private, field_extra_(false, false, false, false, false)),
    ]
    const extensionsList = {
      implementsList: refs_(),
    } as TSExtensionList
    const ctor = constructor_(
      [
        ctorArg('a', int64_(), true, false, false, TSVisibility.Private),
        ctorArg('b', str_(), false, false, false, TSVisibility.Public),
        ctorArg('c', bool_(), true, false, false, TSVisibility.Protected, lit_(true)),
      ],
      TSVisibility.Public,
      false,
      block_([superCall(), fieldAssignmentStatement('d', 'hello')]),
    )
    const implementingClass = class_('A1', extensionsList, ctor, [], classFields, false, true, [], true, false)
    fileGenerator.write(implementingClass)

    const expected = new Printer()
      .beginScope('open class A1: Codable')
      .addLine('public let prop1: Int32 = 42')
      .addLine('private var d: String')
      .addLine('private let a: Int64')
      .addLine('public var b: String')
      .addLine('public let c: Bool')
      .beginScope('public init(_ a: Int64, _ b: String, _ c: Bool = true)')
      .addLine('self.a = a')
      .addLine('self.b = b')
      .addLine('self.c = c')
      .addLine('self.d = "hello"')
      .addLine('super.init()')
      .endScope()
      .addLine()
      .addLine()
      .beginScope('enum CodingKeys: String, CodingKey')
      .addLine('case prop1 = "prop2"')
      .addLine('case d')
      .addLine('case a')
      .addLine('case b')
      .addLine('case c')
      .endScope()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
})
