import { writeFileSync } from 'fs-extra'
import { TSVisibility } from '../../../src/generators-model/basic-types'
import {
  TSBinaryExpression,
  TSCallExpression,
  TSExpressionKind,
  TSIdentifier,
  TSMemberAccessExpression,
  TSUnaryExpression,
} from '../../../src/generators-model/expression'
import { TSExtensionList } from '../../../src/generators-model/global-types'
import { TSExpressionStatement, TSReturnStatement, TSStatementKind } from '../../../src/generators-model/statement'
import Config, { KotlinSerializerEngine } from '../../../src/generators/kotlin/config'
import { KotlinFileGenerator } from '../../../src/generators/kotlin/file-generator'
import { GenericProcessor } from '../../../src/generators/kotlin/generic-processor'
import { SerializerExtraInfoGeneratorFactory } from '../../../src/generators/kotlin/serialization/serializer-extra-generator-factory'
import Printer from '../../../src/utils/printer'
import {
  alias_,
  any_,
  anyArg,
  arr_,
  arrArg,
  block_,
  bool_,
  boolArg,
  class_,
  constructor_,
  ctorArg,
  double_,
  doubleArg,
  e_empty,
  e_extends,
  e_full,
  e_implements,
  enum_,
  enumWithValues_,
  field_,
  field_extra_,
  fun_,
  funArg,
  function_,
  gen_,
  int32_,
  int32Arg,
  int64_,
  int64Arg,
  interface_,
  lit_,
  m_,
  method_,
  null_,
  nullArg,
  ref_,
  refArg,
  refs_,
  RESERVED_KEYWORD__BREAK__,
  RESERVED_KEYWORD__THROW__,
  str_,
  strArg,
  void_,
} from '../../__helpers__/test-helpers'
import { testTypeMappingsProviderGenerator } from '../../__helpers__/test-type-mapping'

export function makeFileGenerator(printer: Printer, conf?: Config): KotlinFileGenerator {
  const config: Config = conf || {
    package: 'com.yandex.test',
    additionalImports: [],
    serializer: KotlinSerializerEngine.Moshi,
  }
  return new KotlinFileGenerator(
    'input.ts',
    'output.kt',
    printer,
    testTypeMappingsProviderGenerator(),
    config,
    {
      generate(): string {
        return '__PRFX__123456'
      },
    },
    new GenericProcessor(
      new SerializerExtraInfoGeneratorFactory(writeFileSync).create(KotlinSerializerEngine.Moshi),
      testTypeMappingsProviderGenerator(),
    ),
  )
}
export function makeFileGeneratorWithGenericProcessor(
  printer: Printer,
  writeFileFunction: (filename: string, contents: string) => void,
  ignoreGenericProcessorInFileGenerator = false,
): [KotlinFileGenerator, GenericProcessor] {
  const config: Config = {
    package: 'com.yandex.test',
    additionalImports: [],
    serializer: KotlinSerializerEngine.Moshi,
  }
  const generator = new SerializerExtraInfoGeneratorFactory(writeFileFunction).create(KotlinSerializerEngine.Moshi)
  const genericProcessor = new GenericProcessor(generator, testTypeMappingsProviderGenerator())
  return [
    new KotlinFileGenerator(
      'input.ts',
      'output.kt',
      printer,
      testTypeMappingsProviderGenerator(),
      config,
      {
        generate(): string {
          return '__PRFX__123456'
        },
      },
      ignoreGenericProcessorInFileGenerator ? undefined : genericProcessor,
    ),
    genericProcessor,
  ]
}

describe(KotlinFileGenerator, () => {
  it('should be able to flush', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.writeHeader()
    const writer = jest.fn(() => {
      /* Empty */
    })
    fileGenerator.flush(writer)
    expect(writer).toHaveBeenCalledWith(
      'output.kt',
      new Printer()
        .addLine('// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM input.ts >>>')
        .addLine()
        .addLine('package com.yandex.test')
        .addLine()
        .addLine()
        .print(),
    )
  })

  it('should be able to add additional packages', () => {
    const printer = new Printer()
    const confWithDependencies: Config = {
      package: 'com.yandex.test',
      additionalImports: ['com.yandex.xplat.common', 'com.yandex.xplat.specific'],
      serializer: KotlinSerializerEngine.Moshi,
    }
    const fileGenerator = makeFileGenerator(printer, confWithDependencies)
    fileGenerator.writeHeader()
    const writer = jest.fn(() => {
      /* Empty */
    })
    fileGenerator.flush(writer)
    expect(writer).toHaveBeenCalledWith(
      'output.kt',
      new Printer()
        .addLine('// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM input.ts >>>')
        .addLine()
        .addLine('package com.yandex.test')
        .addLine()
        .addLine('import com.yandex.xplat.common.*')
        .addLine('import com.yandex.xplat.specific.*')
        .addLine()
        .print(),
    )
  })
  it('should be able to extend imported types', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    expect(fileGenerator.extendImportedTypes([], '')).toBeUndefined() // As it does nothing
  })

  // HELPERS
  it('should generate visibility', () => {
    expect((KotlinFileGenerator as any).stringifyVisibility(TSVisibility.Private)).toBe('private')
    expect((KotlinFileGenerator as any).stringifyVisibility(TSVisibility.Protected)).toBe('protected')
    expect((KotlinFileGenerator as any).stringifyVisibility(TSVisibility.Public)).toBe('')
  })
  it('should generate public or private from export', () => {
    expect((KotlinFileGenerator as any).stringifyExport(false)).toBe('private')
    expect((KotlinFileGenerator as any).stringifyExport(true)).toBe('public')
  })

  // FILE HEADER
  it('should generate file header', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.writeHeader()
    expect(printer.print()).toBe(
      new Printer()
        .addLine('// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM input.ts >>>')
        .addLine()
        .addLine('package com.yandex.test')
        .addLine()
        .addLine()
        .print(),
    )
  })

  // ALIASES
  it('should generate aliases for numbers', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(alias_('A1', true, int32_()))
    fileGenerator.write(alias_('A2', true, int64_()))
    fileGenerator.write(alias_('A3', true, double_()))
    expect(printer.print()).toBe(
      'public typealias A1 = Int\n\npublic typealias A2 = Long\n\npublic typealias A3 = Double\n\n',
    )
  })
  it('should generate aliases for strings', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(alias_('MyAlias', false, str_()))
    expect(printer.print()).toBe('private typealias MyAlias = String\n\n')
  })
  it('should generate aliases for boolean', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(alias_('MyAlias', true, bool_()))
    expect(printer.print()).toBe('public typealias MyAlias = Boolean\n\n')
  })
  it('should generate aliases for any', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(alias_('MyAlias', false, any_()))
    expect(printer.print()).toBe('private typealias MyAlias = Any\n\n')
  })
  it('should generate aliases for void', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(alias_('MyAlias', false, void_()))
    expect(printer.print()).toBe('private typealias MyAlias = Unit\n\n')
  })
  it('should generate aliases for functions', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      alias_('MyAlias', true, fun_([int32_(), str_(), fun_([str_(), ref_('Error')], void_())], void_())),
    )
    expect(printer.print()).toBe('public typealias MyAlias = (Int, String, (String, Error) -> Unit) -> Unit\n\n')
  })
  it('should generate aliases for arrays', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      alias_(
        'MyAlias',
        false,
        arr_(arr_(fun_([str_(), int64_()], fun_([bool_(), arr_(double_(), false)], void_())), false), false),
      ),
    )
    expect(printer.print()).toBe(
      'private typealias MyAlias = YSArray<YSArray<(String, Long) -> (Boolean, YSArray<Double>) -> Unit>>\n\n',
    )
  })

  // ENUMS
  it('should generate empty enums', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(enum_('MyEnum', true))
    const expected = new Printer().beginScope('public enum class MyEnum').endScope().print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate standard enums', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(enum_('MyEnum', false, 'A', 'B', 'C'))
    const expected = new Printer()
      .beginScope('private enum class MyEnum')
      .addLine('A,')
      .addLine('B,')
      .addLine('C,')
      .endScope()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate enums with string raw values', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      enumWithValues_('MyEnum', true, [
        {
          name: 'A',
          value: 'AAA',
        },
        {
          name: 'B',
          value: '"BBB"',
        },
      ]),
    )
    const expected = new Printer()
      .beginScope('public enum class MyEnum(val value: String)')
      .addLine('A("AAA"),')
      .addLine('B("\\"BBB\\""),')
      .addLine(';')
      .addLine('override fun toString(): String = value')
      .endScope()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate enums with number raw values', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      enumWithValues_('MyEnum', false, [
        {
          name: 'A',
          value: 10,
        },
        {
          name: 'B',
          value: 20,
        },
      ]),
    )
    const expected = new Printer()
      .beginScope('private enum class MyEnum(val value: Int)')
      .addLine('A(10),')
      .addLine('B(20),')
      .addLine(';')
      .addLine('fun toInt(): Int = value')
      .endScope()
      .print()
    expect(printer.print()).toBe(expected)
  })

  // FUNCTIONS
  it('should generate non-args function declarations', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(function_('f', [], int64_(), [], true))
    const expected = new Printer().addLine('public fun f(): Long').print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function declarations', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      function_(
        'f',
        [arrArg('a', double_(), false), int32Arg('n'), funArg('f', [bool_(), str_()], any_())],
        fun_([int64_(), str_()], void_()),
        [],
        true,
      ),
    )
    const line = 'public fun f(a: YSArray<Double>, n: Int, f: (Boolean, String) -> Any): (Long, String) -> Unit'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate generic function declarations', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      function_(
        'f',
        [arrArg('a', ref_('A'), false), int32Arg('n'), funArg('f', [bool_(), str_()], any_())],
        fun_([int64_(), str_()], ref_('B')),
        [gen_('A'), gen_('B')],
        true,
      ),
    )
    const line = 'public fun <A, B> f(a: YSArray<A>, n: Int, f: (Boolean, String) -> Any): (Long, String) -> B'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function declarations with empty body', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      function_(
        'f',
        [arrArg('a', ref_('A'), false), int64Arg('n'), funArg('f', [bool_(), null_(str_())], any_())],
        fun_([int32_(), str_()], ref_('B')),
        [gen_('A'), gen_('B')],
        true,
        block_(),
      ),
    )
    const line = 'public fun <A, B> f(a: YSArray<A>, n: Long, f: (Boolean, String?) -> Any): (Int, String) -> B'
    const expected = new Printer().beginScope(line).endScope().addLine().print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function declarations with non-empty body', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      function_(
        'f',
        [arrArg('a', ref_('A'), false), int64Arg('n'), funArg('f', [null_(bool_()), str_()], any_())],
        fun_([int32_(), str_()], ref_('B')),
        [gen_('A'), gen_('B')],
        true,
        block_([
          {
            kind: TSStatementKind.Return,
            expression: {
              kind: TSExpressionKind.Unary,
              operator: '!',
              operand: {
                kind: TSExpressionKind.Identifier,
                name: 'a',
              } as TSIdentifier,
            } as TSUnaryExpression,
          } as TSReturnStatement,
        ]),
      ),
    )
    const line = 'public fun <A, B> f(a: YSArray<A>, n: Long, f: (Boolean?, String) -> Any): (Int, String) -> B'
    const expected = new Printer().beginScope(line).addLine('return !a').endScope().addLine().print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with constraints generics', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      function_(
        'f',
        [arrArg('a', ref_('A'), false)],
        void_(),
        [
          gen_('T1', refs_('C1', 'I1', 'I2')),
          gen_('T2', [ref_('C1', [arr_(int32_(), false)]), ref_('I1')]),
          gen_('T3', refs_('C1')),
        ],
        true,
      ),
    )
    // tslint:disable-next-line: max-line-length
    const line =
      'public fun <T1, T2, T3: C1> f(a: YSArray<A>): Unit where T1: C1, T1: I1, T1: I2, T2: C1<YSArray<Int>>, T2: I1'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with default string value', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(function_('f', [strArg('a', 'default')], void_(), [], true))
    const line = 'public fun f(a: String = "default"): Unit'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with default null string value', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(function_('f', [nullArg(strArg('a'), null)], void_(), [], true))
    const line = 'public fun f(a: String? = null): Unit'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with default int32 value', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(function_('f', [int32Arg('a', 5)], void_(), [], true))
    const line = 'public fun f(a: Int = 5): Unit'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with nullable int32 value, null as default', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(function_('f', [nullArg(int32Arg('a'), null)], void_(), [], true))
    const line = 'public fun f(a: Int? = null): Unit'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with default int64 value', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(function_('f', [int64Arg('a', 5)], void_(), [], true))
    const line = 'public fun f(a: Long = 5): Unit'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with nullable int64 value, null as default', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(function_('f', [nullArg(int64Arg('a'), null)], void_(), [], true))
    const line = 'public fun f(a: Long? = null): Unit'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with default boolean value (true)', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(function_('f', [boolArg('a', true)], void_(), [], true))
    const line = 'public fun f(a: Boolean = true): Unit'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with default boolean value (false)', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(function_('f', [boolArg('a', false)], void_(), [], true))
    const line = 'public fun f(a: Boolean = false): Unit'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with nullable boolean value, null as default', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(function_('f', [nullArg(boolArg('a'), null)], void_(), [], true))
    const line = 'public fun f(a: Boolean? = null): Unit'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with default double value', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(function_('f', [doubleArg('a', 10.5)], void_(), [], true))
    const line = 'public fun f(a: Double = 10.5): Unit'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with nullable double value, null as default', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(function_('f', [nullArg(doubleArg('a'), null)], void_(), [], true))
    const line = 'public fun f(a: Double? = null): Unit'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it("should generate function without default value when it's not set", () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(function_('f', [anyArg('a')], void_(), [], true))
    const line = 'public fun f(a: Any): Unit'
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate function with reserved keyword in its name and parameters', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      function_(RESERVED_KEYWORD__BREAK__, [refArg(RESERVED_KEYWORD__THROW__, 'A')], void_(), [], true),
    )
    const line = `public fun \`${RESERVED_KEYWORD__BREAK__}\`(\`${RESERVED_KEYWORD__THROW__}\`: A): Unit`
    const expected = new Printer().addLine(line).print()
    expect(printer.print()).toBe(expected)
  })

  // INTERFACES
  it('should generate interface without methods', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(interface_('I', [], [], true, []))
    const expected = new Printer().beginScope('public interface I').endScope().addLine().print()
    expect(printer.print()).toBe(expected)
  })
  it('should skip generics from interface definition (not supported)', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(interface_('I', [], [], false, []))
    const expected = new Printer().beginScope('private interface I').endScope().addLine().print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate interface with extension list', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(interface_('I', refs_('I1', 'I2'), [], true, []))
    const expected = new Printer().beginScope('public interface I: I1, I2').endScope().addLine().print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate interface with methods list', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    const methods = [
      method_('m1', TSVisibility.Public, [], void_(), m_(false, false, false, false), []),
      method_(
        'm2',
        TSVisibility.Protected,
        [refArg('a', 'A'), int32Arg('n'), refArg('c', 'C')],
        fun_([null_(double_())], ref_('B')),
        m_(false, true, false, false),
        [gen_('C')],
      ),
      method_('m3', TSVisibility.Public, [refArg('a', 'A')], int32_(), m_(false, true, true, false), [
        gen_('Z', refs_('A', 'B')),
        gen_('X', refs_('A')),
        gen_('Y'),
      ]),
      method_(
        RESERVED_KEYWORD__BREAK__,
        TSVisibility.Private,
        [refArg(RESERVED_KEYWORD__THROW__, 'A')],
        void_(),
        m_(false, false, false, false),
        [],
      ),
    ]
    fileGenerator.write(interface_('I', refs_('I1', 'I2'), methods, true, []))
    const expected = new Printer()
      .beginScope('public interface I: I1, I2')
      .addLine('fun m1(): Unit')
      .addLine('fun <C> m2(a: A, n: Int, c: C): (Double?) -> B')
      .addLine('override fun <Z, X: A, Y> m3(a: A): Int where Z: A, Z: B')
      .addLine(`fun \`${RESERVED_KEYWORD__BREAK__}\`(\`${RESERVED_KEYWORD__THROW__}\`: A): Unit`)
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate interface with property list', () => {
    const printer = new Printer()
    const fields = [
      field_('prop1', int32_(), TSVisibility.Public, field_extra_(false, false, false, false, false)),
      field_('prop2', str_(), TSVisibility.Public, field_extra_(true, false, false, false, true)),
      field_(RESERVED_KEYWORD__BREAK__, int32_(), TSVisibility.Public, field_extra_(true, false, false, false, false)),
    ]
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(interface_('A1', [ref_('A')], [], true, fields))
    const expected = new Printer()
      .beginScope('public interface A1: A')
      .addLine('var prop1: Int')
      .addLine('override val prop2: String')
      .addLine(`val \`${RESERVED_KEYWORD__BREAK__}\`: Int`)
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })

  // CLASSES
  it('should generate class without members if none provided', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      class_(
        'C',
        {
          extendsType: ref_('C1', [ref_('C11', [int32_(), ref_('C111')])]),
          implementsList: refs_('I1', 'I2'),
        } as TSExtensionList,
        undefined, // constructor
        [], // methods
        [], // fields
        true, // abstract
        true, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('public abstract class C: C1<C11<Int, C111>>(), I1, I2')
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate class with methods', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    const methods = [
      method_('m1', TSVisibility.Public, [], void_(), m_(false, false, false, false), []),
      method_(
        'm2',
        TSVisibility.Protected,
        [nullArg(refArg('a', 'A')), doubleArg('n'), refArg('c', 'C')],
        fun_([int32_()], ref_('B')),
        m_(true, false, false, false),
        [gen_('C')],
      ),
      method_(
        'm3',
        TSVisibility.Private,
        [refArg('a', 'A'), int64Arg('n'), refArg('c', 'C')],
        fun_([double_()], ref_('B')),
        m_(false, true, false, false),
        [gen_('C', refs_('I1', 'I2')), gen_('D', refs_('I1')), gen_('E')],
      ),
      method_(
        'm4',
        TSVisibility.Protected,
        [strArg('a'), int32Arg('n')],
        void_(),
        m_(false, false, true, false),
        [],
        block_([
          {
            kind: TSStatementKind.ExpressionStatement,
            expression: {
              kind: TSExpressionKind.Call,
              expression: {
                kind: TSExpressionKind.Identifier,
                name: 'f',
              } as TSIdentifier,
              args: [lit_(10)],
              typeArguments: [],
              optionalChaining: false,
            } as TSCallExpression,
          } as TSExpressionStatement,
          {
            kind: TSStatementKind.ExpressionStatement,
            expression: {
              kind: TSExpressionKind.Call,
              expression: {
                kind: TSExpressionKind.Identifier,
                name: 'g',
              } as TSIdentifier,
              args: [lit_('hi')],
              typeArguments: [],
              optionalChaining: false,
            } as TSCallExpression,
          } as TSExpressionStatement,
        ]),
      ),
      method_('m5', TSVisibility.Protected, [strArg('a')], void_(), m_(false, false, false, true), [], block_()),
      method_('m6', TSVisibility.Private, [strArg('a')], void_(), m_(false, false, false, false), [], block_()),
      method_(
        RESERVED_KEYWORD__BREAK__,
        TSVisibility.Public,
        [refArg(RESERVED_KEYWORD__THROW__, 'A')],
        void_(),
        m_(false, false, false, false),
        [],
      ),
      method_(
        'm7',
        TSVisibility.Public,
        [refArg('a', 'A'), refArg('c', 'C')],
        double_(),
        m_(false, true, true, false),
        [gen_('C')],
      ),
      method_(
        'm8',
        TSVisibility.Public,
        [refArg('a', 'A'), refArg('c', 'C')],
        double_(),
        m_(false, true, false, true),
        [gen_('C')],
      ),
    ]
    fileGenerator.write(
      class_(
        'C',
        e_implements(['I1, I2']),
        undefined, // constructor
        methods, // methods
        [], // fields
        true, // abstract
        false, // export
        [gen_('A'), gen_('B')], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('private abstract class C<A, B>: I1, I2')
      .beginScope('open fun m1(): Unit')
      .endScope()
      .addLine()
      .addLine('protected abstract fun <C> m2(a: A?, n: Double, c: C): (Int) -> B')
      .beginScope('protected open override fun m4(a: String, n: Int): Unit')
      .addLine('f(10)')
      .addLine('g("hi")')
      .endScope()
      .addLine()
      .beginScope('protected open override fun m5(a: String): Unit')
      .endScope()
      .addLine()
      .beginScope('private fun m6(a: String): Unit')
      .endScope()
      .addLine()
      .beginScope(`open fun \`${RESERVED_KEYWORD__BREAK__}\`(\`${RESERVED_KEYWORD__THROW__}\`: A): Unit`)
      .endScope()
      .addLine()
      .beginScope('companion object')
      .addLine('@JvmStatic')
      .beginScope('private fun <C, D: I1, E> m3(a: A, n: Long, c: C): (Double) -> B where C: I1, C: I2')
      .endScope()
      .addLine()
      .addLine('@JvmStatic')
      .beginScope('open fun <C> m7(a: A, c: C): Double')
      .endScope()
      .addLine()
      .addLine('@JvmStatic')
      .beginScope('open fun <C> m8(a: A, c: C): Double')
      .endScope()
      .addLine()
      .endScope()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate class with fields', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    const fields = [
      field_('f1', int32_(), TSVisibility.Public, field_extra_(false, false, false, false, false), lit_(0)),
      field_('f2', ref_('A'), TSVisibility.Private, field_extra_(true, false, false, false, false)),
      field_('f3', int64_(), TSVisibility.Protected, field_extra_(true, true, false, false, false), lit_(0)),
      field_('f4', str_(), TSVisibility.Public, field_extra_(false, true, false, false, false), lit_('Hello')),
      field_('f5', null_(ref_('T')), TSVisibility.Public, field_extra_(false, false, true, false, false), lit_(null)),
      field_('f6', null_(ref_('T')), TSVisibility.Public, field_extra_(true, false, true, false, false), lit_(null)),
      field_(
        RESERVED_KEYWORD__BREAK__,
        str_(),
        TSVisibility.Public,
        field_extra_(false, false, false, false, false),
        lit_('instance field'),
      ),
      field_(
        RESERVED_KEYWORD__THROW__,
        str_(),
        TSVisibility.Public,
        field_extra_(false, true, false, false, false),
        lit_('static field'),
      ),
    ]
    fileGenerator.write(
      class_(
        'C',
        e_extends('B'),
        undefined, // constructor
        [], // methods
        fields, // fields
        false, // abstract
        true, // export
        [gen_('A')], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('public open class C<A>: B()')
      .addLine('var f1: Int = 0')
      .addLine('private val f2: A')
      .addLine('var f5: T? = null')
      .addLine('val f6: T? = null') // Weak properties are `var` disregarding readonly settings.
      .addLine(`var \`${RESERVED_KEYWORD__BREAK__}\`: String = "instance field"`)
      .beginScope('companion object')
      .addLine('@JvmStatic protected val f3: Long = 0')
      .addLine('@JvmStatic var f4: String = "Hello"')
      .addLine(`@JvmStatic var \`${RESERVED_KEYWORD__THROW__}\`: String = "static field"`)
      .endScope()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate constructor', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    const args = [ctorArg('a', int32_()), ctorArg('b', str_()), ctorArg(RESERVED_KEYWORD__BREAK__, str_())]
    const ctor = constructor_(args, TSVisibility.Public, false, block_())
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        ctor, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope(`private open class C(a: Int, b: String, \`${RESERVED_KEYWORD__BREAK__}\`: String)`)
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate constructor with single statement', () => {
    function fieldAssignmentStatement(name: string): TSExpressionStatement {
      return {
        kind: TSStatementKind.ExpressionStatement,
        expression: {
          kind: TSExpressionKind.Binary,
          operator: '=',
          left: {
            kind: TSExpressionKind.MemberAccess,
            object: {
              kind: TSExpressionKind.This,
            },
            member: {
              kind: TSExpressionKind.Identifier,
              name,
            },
          } as TSMemberAccessExpression,
          right: {
            kind: TSExpressionKind.Identifier,
            name,
          } as TSIdentifier,
        } as TSBinaryExpression,
      }
    }

    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    const ctor = constructor_(
      [ctorArg('a', int64_()), ctorArg('b', str_())],
      TSVisibility.Public,
      false,
      block_([fieldAssignmentStatement('a')]),
    )
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        ctor, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('private open class C(a: Long, b: String)')
      .beginScope('init')
      .addLine('this.a = a')
      .endScope()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate constructor with more that one statements', () => {
    function fieldAssignmentStatement(name: string): TSExpressionStatement {
      return {
        kind: TSStatementKind.ExpressionStatement,
        expression: {
          kind: TSExpressionKind.Binary,
          operator: '=',
          left: {
            kind: TSExpressionKind.MemberAccess,
            object: {
              kind: TSExpressionKind.This,
            },
            member: {
              kind: TSExpressionKind.Identifier,
              name,
            },
          } as TSMemberAccessExpression,
          right: {
            kind: TSExpressionKind.Identifier,
            name,
          } as TSIdentifier,
        } as TSBinaryExpression,
      }
    }

    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    const ctor = constructor_(
      [ctorArg('a', double_()), ctorArg('b', str_())],
      TSVisibility.Public,
      false,
      block_([fieldAssignmentStatement('a'), fieldAssignmentStatement('b')]),
    )
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        ctor, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('private open class C(a: Double, b: String)')
      .beginScope('init')
      .addLine('this.a = a')
      .addLine('this.b = b')
      .endScope()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate constructor with single super call', () => {
    function superCallWithArgument(name: string): TSExpressionStatement {
      return {
        kind: TSStatementKind.ExpressionStatement,
        expression: {
          kind: TSExpressionKind.Call,
          expression: {
            kind: TSExpressionKind.Super,
          },
          args: [
            {
              kind: TSExpressionKind.Identifier,
              name,
            } as TSIdentifier,
          ],
          typeArguments: [],
          optionalChaining: false,
        } as TSCallExpression,
      }
    }

    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    const ctor = constructor_([ctorArg('a', int32_())], TSVisibility.Public, true, block_([superCallWithArgument('a')]))
    fileGenerator.write(
      class_(
        'C',
        e_extends('A'),
        ctor, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer().beginScope('private open class C(a: Int): A(a)').endScope().addLine().print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate constructor with single super call and function call inside constructor', () => {
    function superCallWithArgument(): TSExpressionStatement {
      return {
        kind: TSStatementKind.ExpressionStatement,
        expression: {
          kind: TSExpressionKind.Call,
          expression: {
            kind: TSExpressionKind.Super,
          },
          args: [
            {
              kind: TSExpressionKind.Call,
              expression: {
                kind: TSExpressionKind.Identifier,
                name: 'k',
              },
              args: [lit_(42)],
              typeArguments: [],
              optionalChaining: false,
            } as TSCallExpression,
          ],
          typeArguments: [],
          optionalChaining: false,
        } as TSCallExpression,
      }
    }

    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    const ctor = constructor_(
      [ctorArg('a', int32_()), ctorArg('b', str_())],
      TSVisibility.Public,
      false,
      block_([superCallWithArgument()]),
    )
    fileGenerator.write(
      class_(
        'C',
        e_extends('A'),
        ctor, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('private open class C(a: Int, b: String): A(k(42))')
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate constructor with rearranged calls if super and other statements are there single', () => {
    function superCallWithArgument(name: string): TSExpressionStatement {
      return {
        kind: TSStatementKind.ExpressionStatement,
        expression: {
          kind: TSExpressionKind.Call,
          expression: {
            kind: TSExpressionKind.Super,
          },
          args: [
            {
              kind: TSExpressionKind.Identifier,
              name,
            } as TSIdentifier,
          ],
          typeArguments: [],
          optionalChaining: false,
        } as TSCallExpression,
      }
    }
    function fieldAssignmentStatement(name: string): TSExpressionStatement {
      return {
        kind: TSStatementKind.ExpressionStatement,
        expression: {
          kind: TSExpressionKind.Binary,
          operator: '=',
          left: {
            kind: TSExpressionKind.MemberAccess,
            object: {
              kind: TSExpressionKind.This,
            },
            member: {
              kind: TSExpressionKind.Identifier,
              name,
            },
          } as TSMemberAccessExpression,
          right: {
            kind: TSExpressionKind.Identifier,
            name,
          } as TSIdentifier,
        } as TSBinaryExpression,
      }
    }

    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    const ctor = constructor_(
      [ctorArg('a', int64_()), ctorArg('b', str_())],
      TSVisibility.Public,
      false,
      block_([superCallWithArgument('a'), fieldAssignmentStatement('b')]),
    )

    fileGenerator.write(
      class_(
        'C', // name
        e_extends('A'), // extension lists
        ctor, // constructor
        [], // methods
        [field_('b', double_(), TSVisibility.Private, field_extra_(false, false, false, false, false))], // fields
        false, // abstract
        false, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('private open class C(a: Long, b: String): A(a)')
      .addLine('private var b: Double')
      .beginScope('init')
      .addLine('this.b = b')
      .endScope()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should move default ctor call to extension list if has base class but does not have a ctor', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      class_(
        'C', // name
        e_extends('A'), // extension lists
        undefined, // constructor
        [], // methods
        [field_('b', double_(), TSVisibility.Private, field_extra_(false, false, false, false, false))],
        false, // abstract
        false, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('private open class C: A()')
      .addLine('private var b: Double')
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should not move default ctor call to extension list if has base class and a ctor', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      class_(
        'C', // name
        e_extends('A'), // extension lists
        constructor_([], TSVisibility.Public, true, block_()),
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer().beginScope('private open class C(): A()').endScope().addLine().print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate full primary ctor syntax if private', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      class_(
        'C', // name
        e_extends('A'), // extension lists
        constructor_([], TSVisibility.Private, false, block_()),
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('private open class C private constructor(): A()')
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate full primary ctor syntax if protected', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      class_(
        'C', // name
        e_extends('A'), // extension lists
        constructor_([], TSVisibility.Protected, false, block_()),
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('private open class C protected constructor(): A()')
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate class with constraints generics', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        undefined, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [
          gen_('T1', refs_('C1', 'I1')),
          gen_('T2', [ref_('C1', [arr_(int32_(), false)]), ref_('I1')]),
          gen_('T3', refs_('C1')),
        ], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope('private open class C<T1, T2, T3: C1> where T1: C1, T1: I1, T2: C1<YSArray<Int>>, T2: I1')
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate class with codable interface if serializable annotation provided', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        undefined, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        true, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .addLine('@JsonClass(generateAdapter = true)')
      .beginScope('private open class C: Codable')
      .beginScope('companion object')
      .beginScope('@JvmStatic fun getRuntimeInfo(): RuntimeClassInfo')
      .addLine('return RuntimeClassInfo("com.yandex.test.C")')
      .endScope()
      .endScope()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate class conforming to interfaces once to each one (no duplicates)', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      class_(
        'C',
        e_implements(['I1', 'I1']),
        undefined, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        true, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .addLine('@JsonClass(generateAdapter = true)')
      .beginScope('private open class C: I1, Codable')
      .beginScope('companion object')
      .beginScope('@JvmStatic fun getRuntimeInfo(): RuntimeClassInfo')
      .addLine('return RuntimeClassInfo("com.yandex.test.C")')
      .endScope()
      .endScope()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  // tslint:disable-next-line:max-line-length
  it('should generate class with codable interface if serializable annotation and additional interfaces provided', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      class_(
        'C',
        e_implements(['I1', 'I2']),
        undefined, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        true, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .addLine('@JsonClass(generateAdapter = true)')
      .beginScope('private open class C: I1, I2, Codable')
      .beginScope('companion object')
      .beginScope('@JvmStatic fun getRuntimeInfo(): RuntimeClassInfo')
      .addLine('return RuntimeClassInfo("com.yandex.test.C")')
      .endScope()
      .endScope()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  // tslint:disable-next-line:max-line-length
  it('should generate class conforming to codable interface once if serializable annotation and directly Codable implementation provided', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      class_(
        'C',
        e_implements(['Codable']),
        undefined, // constructor
        [], // methods
        [], // fields
        false, // abstract
        false, // export
        [], // generics
        true, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .addLine('@JsonClass(generateAdapter = true)')
      .beginScope('private open class C: Codable')
      .beginScope('companion object')
      .beginScope('@JvmStatic fun getRuntimeInfo(): RuntimeClassInfo')
      .addLine('return RuntimeClassInfo("com.yandex.test.C")')
      .endScope()
      .endScope()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate serializable class with constraints generics', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        constructor_([ctorArg('field1', ref_('T1'))], TSVisibility.Public, false, block_([])),
        [], // methods
        [], // fields
        false, // abstract
        true, // export
        [gen_('T1', refs_('C1'))], // generics
        true, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .addLine('@JsonClass(generateAdapter = true)')
      .beginScope('public open class C<T1: C1>(field1: T1): Codable')
      .beginScope('companion object')
      .beginScope('@JvmStatic fun getRuntimeInfo(): RuntimeClassInfo')
      .addLine('return RuntimeClassInfo("com.yandex.test.C")')
      .endScope()
      .endScope()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate interface with mutable property and property in implementing class', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    const classFields = [
      field_('prop1', int32_(), TSVisibility.Public, field_extra_(false, false, false, false, true), lit_(42)),
    ]
    const extensionsList = {
      implementsList: refs_('A1'),
    } as TSExtensionList
    const implementingClass = class_('B1', extensionsList, undefined, [], classFields, false, true, [], false, false)
    fileGenerator.write(implementingClass)

    const expected = new Printer()
      .beginScope('public open class B1: A1')
      .addLine('override var prop1: Int = 42')
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate interface with readonly property and property in implementing class', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    const classFields = [
      field_('prop1', int32_(), TSVisibility.Public, field_extra_(true, false, false, true, false), lit_(42)),
    ]
    const extensionsList = {
      implementsList: refs_('A1'),
    } as TSExtensionList
    const implementingClass = class_('B1', extensionsList, undefined, [], classFields, false, true, [], false, false)
    fileGenerator.write(implementingClass)

    const expected = new Printer()
      .beginScope('public open class B1: A1')
      .addLine('override val prop1: Int = 42')
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate class with @JsonClass(generateAdapter = true) if serializable annotation provided', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        undefined, // constructor
        [], // methods
        [], // fields
        false, // abstract
        true, // export
        [], // generics
        true, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .addLine('@JsonClass(generateAdapter = true)')
      .beginScope('public open class C: Codable')
      .beginScope('companion object')
      .beginScope('@JvmStatic fun getRuntimeInfo(): RuntimeClassInfo')
      .addLine('return RuntimeClassInfo("com.yandex.test.C")')
      .endScope()
      .endScope()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should generate constructor for class with arguments', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    const ctor = constructor_([ctorArg('a', int32_()), ctorArg('b', str_())], TSVisibility.Public, false, block_())
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        ctor, // constructor
        [], // methods
        [], // fields
        false, // abstract
        true, // export
        [], // generics
        true, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .addLine('@JsonClass(generateAdapter = true)')
      .beginScope('public open class C(a: Int, b: String): Codable')
      .beginScope('companion object')
      .beginScope('@JvmStatic fun getRuntimeInfo(): RuntimeClassInfo')
      .addLine('return RuntimeClassInfo("com.yandex.test.C")')
      .endScope()
      .endScope()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should call post-processor with array types', () => {
    const printer = new Printer()
    const writeFileMock = jest.fn()
    const [fileGenerator, genericProcessor] = makeFileGeneratorWithGenericProcessor(printer, writeFileMock)
    genericProcessor.onGenericDetected = jest.fn()
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        constructor_(
          [
            ctorArg('f1', null_(null_(arr_(int32_(), false))), false, false, false, TSVisibility.Public),
            ctorArg('f2', null_(arr_(ref_('A'), false)), true, false, false, TSVisibility.Public),
            ctorArg('f3', null_(arr_(ref_('T'), false)), true, false, false, TSVisibility.Public),
            ctorArg('f4', arr_(ref_('SomeClass'), false), true, false, false, TSVisibility.Public),
          ],
          TSVisibility.Public,
          false,
          block_(),
        ), // constructor
        [], // methods
        [], // fields
        false, // abstract
        true, // export
        [gen_('T')], // generics
        true, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .addLine('@JsonClass(generateAdapter = true)')
      .beginScope(
        'public open class C<T>(var f1: YSArray<Int>??, val f2: YSArray<A>?, ' +
          'val f3: YSArray<T>?, val f4: YSArray<SomeClass>): Codable',
      )
      .beginScope('companion object')
      .beginScope('@JvmStatic fun getRuntimeInfo(): RuntimeClassInfo')
      .addLine('return RuntimeClassInfo("com.yandex.test.C")')
      .endScope()
      .endScope()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
    expect(genericProcessor.onGenericDetected).toBeCalled()
  })

  it('should throw error if unsupported Array subtype in serializable class', () => {
    const printer = new Printer()
    const writeFileMock = jest.fn()
    const [fileGenerator, genericProcessor] = makeFileGeneratorWithGenericProcessor(printer, writeFileMock)

    const elementType = fun_([int64_()], str_())
    genericProcessor.onGenericDetected = jest.fn()
    const clazz = class_(
      'C',
      e_empty(),
      constructor_(
        [ctorArg('f1', arr_(elementType, false), false, false, false, TSVisibility.Public)],
        TSVisibility.Public,
        false,
        block_(),
      ), // constructor
      [], // methods
      [], // fields
      false, // abstract
      true, // export
      [], // generics
      true, // serializable
      false, // parcelable
    )
    expect(() => {
      fileGenerator.write(clazz)
    }).toThrowError('Unsupported Array subtype in Serializable class: YSArray<(Long) -> String>')
  })

  it('should throw error if there is typeParameters for elementType in Array', () => {
    const printer = new Printer()
    const writeFileMock = jest.fn()
    const [fileGenerator, genericProcessor] = makeFileGeneratorWithGenericProcessor(printer, writeFileMock)

    genericProcessor.onGenericDetected = jest.fn()
    const clazz = class_(
      'C',
      e_empty(),
      constructor_(
        [ctorArg('field1', arr_(ref_('SomeOtherClass', [int32_()]), false), false, false, false, TSVisibility.Public)],
        TSVisibility.Public,
        false,
        block_(),
      ), // constructor
      [], // methods
      [], // fields
      false, // abstract
      true, // export
      [], // generics
      true, // serializable
      false, // parcelable
    )
    expect(() => fileGenerator.write(clazz)).toThrowError(
      'Unsupported Array subtype in Serializable class: YSArray<SomeOtherClass<Int>>',
    )
  })
  it('should generate constructor with fields and default values', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    const ctor = constructor_(
      [
        ctorArg('a', int32_(), true, false, false, TSVisibility.Private, lit_(10)),
        ctorArg('b', str_(), false, false, false, TSVisibility.Protected, lit_('Hello')),
        ctorArg('c', bool_(), true, false, false, TSVisibility.Public, lit_(true)),
        ctorArg('d', double_(), true, true, false, TSVisibility.Public, lit_(10.0)),
        ctorArg('e', null_(ref_('Z')), false, false, true, TSVisibility.Public, lit_(null)),
        ctorArg('f', int64_(), true, true, true, TSVisibility.Protected, lit_(10)),
      ],
      TSVisibility.Public,
      false,
      block_(),
    )
    fileGenerator.write(
      class_(
        'C',
        e_full('A', ['I']),
        ctor, // constructor
        [], // methods
        [], // fields
        false, // abstract
        true, // export
        [], // generics
        false, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .beginScope(
        // tslint:disable-next-line: max-line-length
        'public open class C(private val a: Int = 10, protected var b: String = "Hello", val c: Boolean = true, override val d: Double = 10, override var e: Z? = null, protected override val f: Long = 10): A(), I',
      )
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
  it('should not call onGenericDetected if GenericProcessor is null in FileGenerator', () => {
    const printer = new Printer()
    const writeFileMock = jest.fn()
    const [fileGenerator, genericProcessor] = makeFileGeneratorWithGenericProcessor(printer, writeFileMock, true)

    genericProcessor.onGenericDetected = jest.fn()
    fileGenerator.write(
      class_(
        'C',
        e_empty(),
        constructor_(
          [ctorArg('f1', null_(null_(arr_(int32_(), false))), false, false, false, TSVisibility.Public)],
          TSVisibility.Public,
          false,
          block_(),
        ), // constructor
        [], // methods
        [], // fields
        false, // abstract
        true, // export
        [], // generics
        true, // serializable
        false, // parcelable
      ),
    )
    const expected = new Printer()
      .addLine('@JsonClass(generateAdapter = true)')
      .beginScope('public open class C(var f1: YSArray<Int>??): Codable')
      .beginScope('companion object')
      .beginScope('@JvmStatic fun getRuntimeInfo(): RuntimeClassInfo')
      .addLine('return RuntimeClassInfo("com.yandex.test.C")')
      .endScope()
      .endScope()
      .endScope()
      .addLine()
      .print()

    expect(printer.print()).toBe(expected)
    expect(genericProcessor.onGenericDetected).not.toBeCalled()
  })
  it('should generate serializable class with custom json serialized  name for field', () => {
    const printer = new Printer()
    const fileGenerator = makeFileGenerator(printer)
    const classFields = [
      field_('prop1', int32_(), TSVisibility.Public, field_extra_(true, false, false, false, false, 'prop2'), lit_(42)),
      field_('prop2', str_(), TSVisibility.Public, field_extra_(true, false, false, false, false), lit_('aaaaa')),
    ]
    const extensionsList = {
      implementsList: refs_(),
    } as TSExtensionList
    const implementingClass = class_('A1', extensionsList, undefined, [], classFields, false, true, [], true, false)
    fileGenerator.write(implementingClass)

    const expected = new Printer()
      .addLine('@JsonClass(generateAdapter = true)')
      .beginScope('public open class A1: Codable')
      .addLine('@Json(name="prop2")')
      .addLine('val prop1: Int = 42')
      .addLine('val prop2: String = "aaaaa"')
      .beginScope('companion object')
      .beginScope('@JvmStatic fun getRuntimeInfo(): RuntimeClassInfo')
      .addLine('return RuntimeClassInfo("com.yandex.test.A1")')
      .endScope()
      .endScope()
      .endScope()
      .addLine()
      .print()
    expect(printer.print()).toBe(expected)
  })
})
