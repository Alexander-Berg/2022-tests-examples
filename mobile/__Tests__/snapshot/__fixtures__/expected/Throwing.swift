// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM throwing.ts >>>

import Foundation

@discardableResult
fileprivate func f() throws -> Void {
}

@discardableResult
fileprivate func f2() throws -> Void {
}

@discardableResult
fileprivate func f3() throws -> Void {
}

@discardableResult
public func parseJson<T>(_ item: String, _ materializer: @escaping (String) throws -> T) -> T! {
  do {
    return (try materializer(item))
  } catch {
    let e = error
    return nil
  }
}

open class MyException: YSError {
  public override init(_ message: String) {
    super.init(message)
  }

}

fileprivate class B {
  @discardableResult
  public func m2() throws -> Bool {
    let i: I = Impl()
    YSMap<String, String>().__forEach({
      (value, key) throws -> Void in
      (try i.it())
    })
    throw MyException("pizza")
  }

  @discardableResult
  private func m3(_ callback: @escaping (String) throws -> Bool?) -> Bool {
    do {
      (try f())
      return (try self.m2())
    } catch {
      let e = error
      if e is MyException {
        return false
      } else {
        return true
      }
    }
  }

  public func fatal() -> Void {
    fatalError("fatal")
  }

  public func fatal2() -> Void {
    fatalError()
  }

}

fileprivate class C<T>: B {
  @discardableResult
  public override func m2() throws -> Bool {
    return false
  }

}

fileprivate class D: C<Void>, Codable {
  @discardableResult
  public func a() throws -> Bool {
    fatalError("Must be overridden in subclasses")
  }

}

fileprivate protocol I {
  @discardableResult
  func it() throws -> Void
}

fileprivate class Impl: I {
  @discardableResult
  public func it() throws -> Void {
  }

}

open class Foo {
  @discardableResult
  open func callThrowing() throws -> Foo {
    return self
  }

  open func testChainedThrowingCalls() -> Void {
    (try (try (try self.callThrowing()).callThrowing()).callThrowing())
  }

}

