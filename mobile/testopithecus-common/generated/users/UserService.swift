// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM users/user-service.ts >>>

import Foundation

open class UserServiceAccount {
  public var login: String
  public var password: String
  public var uid: String
  public init(_ login: String, _ password: String, _ uid: String) {
    self.login = login
    self.password = password
    self.uid = uid
  }

}

open class UserService {
  public static var userServiceUrl: String = "https://tus.yandex-team.ru"
  public static var userServiceOauthToken: String = ""
  private var network: SyncNetwork
  private var jsonSerializer: JSONSerializer
  private var logger: Logger
  public init(_ network: SyncNetwork, _ jsonSerializer: JSONSerializer, _ logger: Logger) {
    self.network = network
    self.jsonSerializer = jsonSerializer
    self.logger = logger
  }

  @discardableResult
  open func getAccount(_ tusEnv: TusEnv, _ tusConsumer: String, _ tag: String!, _ lockDuration: Int32, _ ignoreLocks: Bool, _ uidd: String!) -> UserServiceAccount! {
    var response: MapJSONItem
    do {
      response = (try self.syncRequest(GetAccountRequest(tusEnv, tusConsumer, tag, lockDuration, ignoreLocks, uidd)))
    } catch {
      let e = error
      self.logger.error("Failed to get account, error: \(extractErrorMessage(e))")
      return nil
    }
    let account = response.`get`("account") as! MapJSONItem
    if account == nil {
      return nil
    }
    let login: String! = self.getFullLogin(account.getString("login"), tag)
    let password: String! = account.getString("password")
    let uid: String! = account.getString("uid")
    if login == nil || password == nil || uid == nil {
      return nil
    }
    self.logger.info("Got account login=\(login!) password=\(password!) uid=\(uid!)")
    return UserServiceAccount(login!, password!, uid!)
  }

  @discardableResult
  private func getFullLogin(_ login: String!, _ tag: String!) -> String! {
    if login == nil || tag == nil {
      return nil
    }
    switch tag {
      case UserServiceEnsemble.getTagByAccountType(AccountType2.Yandex):
        return "\(login!)@\(tag!).ru"
      case UserServiceEnsemble.getTagByAccountType(AccountType2.YandexTeam):
        return "\(login!)@\(tag!).ru"
      case UserServiceEnsemble.getTagByAccountType(AccountType2.Rambler):
        return "\(login!)@\(tag!).ru"
      case UserServiceEnsemble.getTagByAccountType(AccountType2.YandexTest):
        return login!
      case UserServiceEnsemble.getTagByAccountType(AccountType2.Mail):
        return "\(login!)@\(tag!)"
      default:
        return "\(login!)@\(tag!).com"
    }
  }

  open func unlockAccount(_ tusEnv: TusEnv, _ uid: String) -> Void {
    do {
      (try self.syncRequest(UnlockAccountRequest(tusEnv, uid)))
    } catch {
      let e = error
      self.logger.error("Account was not unlocked. error: \(extractErrorMessage(e))")
    }
  }

  @discardableResult
  private func syncRequest(_ networkRequest: NetworkRequest) throws -> MapJSONItem {
    let oauthToken = UserService.userServiceOauthToken
    if oauthToken == "" {
      self.logger.error("Empty OAuth token for Test User Service. Get token here: " + "https://wiki.yandex-team.ru/test-user-service/#autentifikacija and place it into " + "USER_SERVICE_OAUTH_TOKEN environment variable")
      fatalError("Empty OAuth token for TUS")
    }
    let response = self.network.syncExecuteWithRetries(3, UserService.userServiceUrl, networkRequest, oauthToken)
    let json = self.jsonSerializer.deserialize((try response.tryGetValue())).getValue()
    return json as! MapJSONItem
  }

}

fileprivate class GetAccountRequest: BaseNetworkRequest {
  private var tusEnv: TusEnv
  private var tusConsumer: String
  private var tag: String!
  private var lockDuration: Int32
  private var ignoreLocks: Bool
  private var uid: String!
  public init(_ tusEnv: TusEnv, _ tusConsumer: String, _ tag: String!, _ lockDuration: Int32, _ ignoreLocks: Bool, _ uid: String!) {
    self.tusEnv = tusEnv
    self.tusConsumer = tusConsumer
    self.tag = tag
    self.lockDuration = lockDuration
    self.ignoreLocks = ignoreLocks
    self.uid = uid
    super.init()
  }

  @discardableResult
  public override func encoding() -> RequestEncoding {
    return UrlRequestEncoding()
  }

  @discardableResult
  public override func method() -> NetworkMethod {
    return NetworkMethod.`get`
  }

  @discardableResult
  public override func params() -> MapJSONItem {
    return MapJSONItem().putString("env", self.tusEnv.toString()).putString("tus_consumer", self.tusConsumer).putInt32("lock_duration", self.lockDuration).putBoolean("ignore_locks", self.ignoreLocks).putStringIfPresent("tags", self.tag).putStringIfPresent("uid", self.uid)
  }

  @discardableResult
  public override func urlExtra() -> MapJSONItem {
    return MapJSONItem()
  }

  @discardableResult
  public override func targetPath() -> String {
    return "1/get_account/"
  }

}

fileprivate class UnlockAccountRequest: BaseNetworkRequest {
  private let tusEnv: TusEnv
  private let uid: String
  public init(_ tusEnv: TusEnv, _ uid: String) {
    self.tusEnv = tusEnv
    self.uid = uid
    super.init()
  }

  @discardableResult
  public override func encoding() -> RequestEncoding {
    return UrlRequestEncoding()
  }

  @discardableResult
  public override func method() -> NetworkMethod {
    return NetworkMethod.post
  }

  @discardableResult
  public override func params() -> MapJSONItem {
    return MapJSONItem().putString("env", self.tusEnv.toString()).putString("uid", self.uid)
  }

  @discardableResult
  public override func urlExtra() -> MapJSONItem {
    return MapJSONItem()
  }

  @discardableResult
  public override func targetPath() -> String {
    return "1/unlock_account/"
  }

}

