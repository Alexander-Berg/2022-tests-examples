// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mbt/walk/dfs-walk-strategy.ts >>>

import Foundation

open class DfsWalkStrategy: ActionChooser {
  public var graph: Graph<MBTAction> = Graph()
  public var stack: Stack<Int32> = Stack<Int32>()
  public var stateStack: Stack<AppModel> = Stack<AppModel>()
  public var componentStack: Stack<MBTComponent> = Stack<MBTComponent>()
  public var hashStack: Stack<Int64> = Stack<Int64>()
  public var previousVertex: Int64 = int64(-1)
  private var used: YSSet<Int64> = YSSet<Int64>()
  private var actionStack: Stack<MBTAction> = Stack<MBTAction>()
  private var numberOfEdge: Int32 = -1
  private var hashProvider: HashProvider
  private var actionLimits: ActionLimitsStrategy
  public init(_ hashProvider: HashProvider, _ actionLimits: ActionLimitsStrategy) {
    self.hashProvider = hashProvider
    self.actionLimits = actionLimits
  }

  @discardableResult
  open func choose(_ possibleActions: YSArray<MBTAction>, _ component: MBTComponent) -> MBTAction! {
    let currentHash: Int64 = self.hashProvider.getHash()
    self.stateStack.push(self.hashProvider.getModelCopy()!)
    self.hashStack.push(currentHash)
    self.componentStack.push(component)
    if self.numberOfEdge >= 0 {
      self.graph.addEdgeVV(self.previousVertex, currentHash, self.actionStack.top())
    }
    if self.used.has(currentHash) {
      self.stepBack()
      return nil
    }
    self.used.add(currentHash)
    self.graph.addVertex(currentHash)
    let actionIndex = self.graph.getDegreeV(currentHash)
    if possibleActions.length <= actionIndex || !self.actionLimits.check(self.actionStack) {
      self.stepBack()
      return nil
    }
    self.previousVertex = currentHash
    self.numberOfEdge = actionIndex
    self.stack.push(self.numberOfEdge)
    self.actionStack.push(possibleActions[self.numberOfEdge])
    return possibleActions[self.numberOfEdge]
  }

  private func stepBack() -> Void {
    self.stateStack.pop()
    self.hashStack.pop()
    self.componentStack.pop()
    self.stack.pop()
    self.actionStack.pop()
    self.used.delete(self.previousVertex)
    self.numberOfEdge = -1
  }

}

open class MultiRunner {
  public let walkStrategyWithState: DfsWalkStrategy
  private let hashProvider: HashProvider
  private var component: MBTComponent
  private var behaviour: UserBehaviour
  private var supportedFeatures: YSArray<FeatureID>
  private var logger: Logger
  public init(_ component: MBTComponent, _ behaviour: UserBehaviour, _ actionLimits: ActionLimitsStrategy, _ supportedFeatures: YSArray<FeatureID>, _ logger: Logger) {
    self.component = component
    self.behaviour = behaviour
    self.supportedFeatures = supportedFeatures
    self.logger = logger
    self.hashProvider = HashProvider()
    self.walkStrategyWithState = DfsWalkStrategy(self.hashProvider, actionLimits)
  }

  @discardableResult
  open func preparePath(_ model: AppModel) -> YSArray<MBTAction> {
    var model2 = model.copy()
    model2.supportedFeatures = self.supportedFeatures
    var model3 = model.copy()
    model3.supportedFeatures = self.supportedFeatures
    self.logger.info("DFS started")
    while true {
      self.hashProvider.setModel(model2)
      let modelVsModel = StateMachine(model2, model3, UserBehaviourWalkStrategy(self.behaviour, self.walkStrategyWithState), self.logger)
      do {
        (try modelVsModel.go(self.component))
      } catch {
        let e = error
        if e is YSError {
          fail((e as! YSError).message)
        } else {
          fatalError("Only YSError supported!")
        }
      }
      if self.walkStrategyWithState.stateStack.size() == 0 {
        break
      }
      self.component = self.walkStrategyWithState.componentStack.top()
      model2 = self.walkStrategyWithState.stateStack.top().copy()
      model3 = self.walkStrategyWithState.stateStack.top().copy()
      self.walkStrategyWithState.stateStack.pop()
      self.walkStrategyWithState.hashStack.pop()
      self.walkStrategyWithState.componentStack.pop()
      if self.walkStrategyWithState.hashStack.size() > 0 {
        self.walkStrategyWithState.previousVertex = self.walkStrategyWithState.hashStack.top()
      }
    }
    self.logger.info("DFS finished\n")
    self.logger.info("Count of vertexes = \(self.walkStrategyWithState.graph.size())")
    self.logger.info("Count of edges = \(self.walkStrategyWithState.graph.countOfEdges())")
    return LongestPathAlgo.getLongestPath(self.walkStrategyWithState.graph, self.logger)
  }

}

open class HashProvider {
  private var model: AppModel! = nil
  public init() {
  }

  open func setModel(_ model: AppModel) -> Void {
    self.model = model
  }

  @discardableResult
  open func getHash() -> Int64 {
    if self.model != nil {
      return self.model!.getCurrentStateHash()
    }
    return int64(-1)
  }

  @discardableResult
  open func getModelCopy() -> AppModel! {
    let modelSnapshot: AppModel! = self.model
    if modelSnapshot != nil {
      return modelSnapshot.copy()
    }
    return nil
  }

}

