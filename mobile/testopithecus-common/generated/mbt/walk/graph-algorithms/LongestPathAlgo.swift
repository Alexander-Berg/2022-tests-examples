// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mbt/walk/graph-algorithms/longest-path-algo.ts >>>

import Foundation

open class LongestPathAlgo {
  @discardableResult
  open class func getLongestPath<T>(_ graph: CompressedGraph<T>, _ logger: Logger) -> YSArray<T> {
    if graph.size() == 0 || graph.countOfEdges() == 0 {
      return YSArray()
    }
    let components = StrongComponentAlgo.getStrongConnectedComponents(graph)
    let condensedGraph = StrongComponentAlgo.getCondensedGraph(graph)
    let longestPath = LongestPathAlgo.getLongestPathInCondensedGraph(condensedGraph, components)
    var currentComponent: Int32 = 0
    var currentVertex: Int32 = 0
    for i in stride(from: 0, to: components.size(), by: 1) {
      if components.`get`(i).has(currentVertex) {
        currentComponent = i
      }
    }
    logger.info("Current component id = \(currentComponent), size = \(components.`get`(currentComponent).size)")
    var path: YSArray<T> = EulerGraphAlgo.getEulerCircleInComponent(graph, components.`get`(currentComponent), currentVertex).map({
      (eid) in
      graph.edges[eid].getAction()
    })
    var edgeId: Int32
    while longestPath.getEdgesId(currentComponent).length > 0 {
      edgeId = longestPath.getEdgesId(currentComponent)[0]
      let condensedEdge = longestPath.edges[edgeId]
      let edge = condensedEdge.getAction()
      let distances = DistanceAlgo.getDistances(graph, currentVertex, components.`get`(currentComponent))
      let connectedPath = DistanceAlgo.getPathTo(edge.getFrom(), distances, graph).map({
        (eid) in
        graph.edges[eid].getAction()
      })
      path = path.concat(connectedPath)
      path.push(edge.getAction())
      currentComponent = condensedEdge.getTo()
      currentVertex = edge.getTo()
      logger.info("Current component id = \(currentComponent), size = \(components.`get`(currentComponent).size)")
      let componentPath = EulerGraphAlgo.getEulerCircleInComponent(graph, components.`get`(currentComponent), currentVertex).map({
        (eid) in
        graph.edges[eid].getAction()
      })
      path = path.concat(componentPath)
    }
    return path
  }

  @discardableResult
  private class func getLongestPathInCondensedGraph<T, VertexType>(_ condensed: CompressedGraph<T>, _ components: Stack<YSSet<VertexType>>) -> CompressedGraph<T> {
    let path: CompressedGraph<T> = CompressedGraph()
    let size: YSArray<Int32> = YSArray()
    for `_` in stride(from: 0, to: condensed.size(), by: 1) {
      size.push(0)
    }
    let topSort = TopSortAlgo.getTopSort(condensed)
    for i in stride(from: 0, to: topSort.size(), by: 1) {
      let vertex = topSort.`get`(i)
      size[vertex] += components.`get`(vertex).size
      var mx: Int32 = -1
      var edgeIndex: Int32 = -1
      for edgeId in condensed.getEdgesId(vertex) {
        let to = condensed.edges[edgeId].getTo()
        if size[to] > mx {
          mx = size[to]
          edgeIndex = edgeId
        }
      }
      if edgeIndex >= 0 {
        size[vertex] += mx
        path.addEdge(vertex, condensed.edges[edgeIndex].getTo(), condensed.edges[edgeIndex].getAction())
      }
    }
    return path
  }

}

