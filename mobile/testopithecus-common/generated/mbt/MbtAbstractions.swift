// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM mbt/mbt-abstractions.ts >>>

import Foundation

public typealias MBTComponentType = String

public protocol MBTComponent {
  @discardableResult
  func assertMatches(_ model: App, _ application: App) throws -> Void
  @discardableResult
  func getComponentType() -> MBTComponentType
  @discardableResult
  func tostring() -> String
}

public typealias MBTActionType = String

public protocol MBTAction {
  @discardableResult
  func supported(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool
  @discardableResult
  func canBePerformed(_ model: App) throws -> Bool
  @discardableResult
  func perform(_ model: App, _ application: App, _ history: MBTHistory) throws -> MBTComponent
  @discardableResult
  func getActionType() -> MBTActionType
  @discardableResult
  func events() -> YSArray<EventusEvent>
  @discardableResult
  func tostring() -> String
}

public protocol MBTHistory {
  var currentComponent: MBTComponent { get }
  var previousDifferentComponent: MBTComponent! { get }
  var allPreviousComponents: YSArray<MBTComponent> { get }
}

public typealias FeatureID = String

public protocol App {
  var supportedFeatures: YSArray<FeatureID> { get set }
  @discardableResult
  func getFeature(_ feature: FeatureID) -> Any
  @discardableResult
  func dump(_ model: App) throws -> String
}

open class Feature<T> {
  public let name: FeatureID
  public let description: String
  public init(_ name: FeatureID, _ description: String) {
    self.name = name
    self.description = description
  }

  @discardableResult
  open func included(_ supportedFeatures: YSArray<FeatureID>) -> Bool {
    return supportedFeatures.includes(self.name)
  }

  @discardableResult
  open func includedAll(_ modelFeatures: YSArray<FeatureID>, _ applicationFeatures: YSArray<FeatureID>) -> Bool {
    return self.included(modelFeatures) && self.included(applicationFeatures)
  }

  @discardableResult
  open func forceCast(_ app: App) -> T {
    let t: T! = self.castIfSupported(app)
    if t == nil {
      fatalError("Feature '\(self.name)' is unsupported!")
    }
    return t!
  }

  @discardableResult
  open func castIfSupported(_ app: App) -> T! {
    if !app.supportedFeatures.includes(self.name) {
      return nil
    }
    return self.cast(app.getFeature(self.name))
  }

  @discardableResult
  open func cast(_ obj: Any) -> T {
    return obj as! T
  }

  open func performIfSupported(_ app: App, _ action: @escaping (T) -> Void) -> Void {
    let featured: T! = self.castIfSupported(app)
    if featured != nil {
      action(featured)
    }
  }

}

open class FeatureRegistry {
  private var registry: YSMap<FeatureID, Any> = YSMap()
  public init() {
  }

  @discardableResult
  open func register<T>(_ feature: Feature<T>, _ implementation: T) -> FeatureRegistry {
    self.registry.set(feature.name, castToAny(implementation))
    return self
  }

  @discardableResult
  open func `get`(_ feature: FeatureID) -> Any {
    let result = undefinedToNull(self.registry.get(feature))
    if result == nil {
      fatalError("Фича \(feature) не зарегестрирована. Реализация фичи должна быть в getFeature")
    }
    return result!
  }

}

