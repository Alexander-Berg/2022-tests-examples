// Code generated by mockery. DO NOT EDIT.

package mock

import (
	context "context"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"

	service_map "github.com/YandexClassifieds/shiva/pb/shiva/api/service_map"
)

// ServiceMapsClient is an autogenerated mock type for the ServiceMapsClient type
type ServiceMapsClient struct {
	mock.Mock
}

// AddFavorite provides a mock function with given fields: ctx, in, opts
func (_m *ServiceMapsClient) AddFavorite(ctx context.Context, in *service_map.FavoriteRequest, opts ...grpc.CallOption) (*service_map.FavoriteResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_map.FavoriteResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_map.FavoriteRequest, ...grpc.CallOption) *service_map.FavoriteResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_map.FavoriteResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_map.FavoriteRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Get provides a mock function with given fields: ctx, in, opts
func (_m *ServiceMapsClient) Get(ctx context.Context, in *service_map.GetRequest, opts ...grpc.CallOption) (*service_map.ServiceData, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_map.ServiceData
	if rf, ok := ret.Get(0).(func(context.Context, *service_map.GetRequest, ...grpc.CallOption) *service_map.ServiceData); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_map.ServiceData)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_map.GetRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByKeys provides a mock function with given fields: ctx, in, opts
func (_m *ServiceMapsClient) GetByKeys(ctx context.Context, in *service_map.GetByKeysRequest, opts ...grpc.CallOption) (*service_map.GetByKeysResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_map.GetByKeysResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_map.GetByKeysRequest, ...grpc.CallOption) *service_map.GetByKeysResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_map.GetByKeysResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_map.GetByKeysRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByPaths provides a mock function with given fields: ctx, in, opts
func (_m *ServiceMapsClient) GetByPaths(ctx context.Context, in *service_map.GetByPathsRequest, opts ...grpc.CallOption) (*service_map.GetByPathsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_map.GetByPathsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_map.GetByPathsRequest, ...grpc.CallOption) *service_map.GetByPathsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_map.GetByPathsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_map.GetByPathsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsOwner provides a mock function with given fields: ctx, in, opts
func (_m *ServiceMapsClient) IsOwner(ctx context.Context, in *service_map.IsOwnerRequest, opts ...grpc.CallOption) (*service_map.IsOwnerResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_map.IsOwnerResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_map.IsOwnerRequest, ...grpc.CallOption) *service_map.IsOwnerResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_map.IsOwnerResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_map.IsOwnerRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// List provides a mock function with given fields: ctx, in, opts
func (_m *ServiceMapsClient) List(ctx context.Context, in *service_map.ListRequest, opts ...grpc.CallOption) (*service_map.ListResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_map.ListResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_map.ListRequest, ...grpc.CallOption) *service_map.ListResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_map.ListResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_map.ListRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAll provides a mock function with given fields: ctx, in, opts
func (_m *ServiceMapsClient) ListAll(ctx context.Context, in *service_map.ListRequest, opts ...grpc.CallOption) (service_map.ServiceMaps_ListAllClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 service_map.ServiceMaps_ListAllClient
	if rf, ok := ret.Get(0).(func(context.Context, *service_map.ListRequest, ...grpc.CallOption) service_map.ServiceMaps_ListAllClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(service_map.ServiceMaps_ListAllClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_map.ListRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFavorite provides a mock function with given fields: ctx, in, opts
func (_m *ServiceMapsClient) ListFavorite(ctx context.Context, in *service_map.ListFavoriteRequest, opts ...grpc.CallOption) (*service_map.ListFavoriteResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_map.ListFavoriteResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_map.ListFavoriteRequest, ...grpc.CallOption) *service_map.ListFavoriteResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_map.ListFavoriteResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_map.ListFavoriteRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveFavorite provides a mock function with given fields: ctx, in, opts
func (_m *ServiceMapsClient) RemoveFavorite(ctx context.Context, in *service_map.FavoriteRequest, opts ...grpc.CallOption) (*service_map.FavoriteResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_map.FavoriteResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_map.FavoriteRequest, ...grpc.CallOption) *service_map.FavoriteResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_map.FavoriteResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_map.FavoriteRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResolveTvmID provides a mock function with given fields: ctx, in, opts
func (_m *ServiceMapsClient) ResolveTvmID(ctx context.Context, in *service_map.ResolveTvmIDRequest, opts ...grpc.CallOption) (*service_map.ResolveTvmIDResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_map.ResolveTvmIDResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_map.ResolveTvmIDRequest, ...grpc.CallOption) *service_map.ResolveTvmIDResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_map.ResolveTvmIDResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_map.ResolveTvmIDRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewServiceMapsClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewServiceMapsClient creates a new instance of ServiceMapsClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewServiceMapsClient(t mockConstructorTestingTNewServiceMapsClient) *ServiceMapsClient {
	mock := &ServiceMapsClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
