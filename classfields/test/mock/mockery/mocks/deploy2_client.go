// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	deploy2 "github.com/YandexClassifieds/shiva/pb/shiva/api/deploy2"
	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"
)

// DeployServiceClient is an autogenerated mock type for the DeployServiceClient type
type DeployServiceClient struct {
	mock.Mock
}

// Approve provides a mock function with given fields: ctx, in, opts
func (_m *DeployServiceClient) Approve(ctx context.Context, in *deploy2.ApproveRequest, opts ...grpc.CallOption) (*deploy2.DeploymentResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *deploy2.DeploymentResponse
	if rf, ok := ret.Get(0).(func(context.Context, *deploy2.ApproveRequest, ...grpc.CallOption) *deploy2.DeploymentResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy2.DeploymentResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *deploy2.ApproveRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApproveList provides a mock function with given fields: ctx, in, opts
func (_m *DeployServiceClient) ApproveList(ctx context.Context, in *deploy2.ApproveListRequest, opts ...grpc.CallOption) (*deploy2.ApproveListResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *deploy2.ApproveListResponse
	if rf, ok := ret.Get(0).(func(context.Context, *deploy2.ApproveListRequest, ...grpc.CallOption) *deploy2.ApproveListResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy2.ApproveListResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *deploy2.ApproveListRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BalancerStatus provides a mock function with given fields: ctx, in, opts
func (_m *DeployServiceClient) BalancerStatus(ctx context.Context, in *deploy2.BalancerStatusRequest, opts ...grpc.CallOption) (*deploy2.BalancerStatusResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *deploy2.BalancerStatusResponse
	if rf, ok := ret.Get(0).(func(context.Context, *deploy2.BalancerStatusRequest, ...grpc.CallOption) *deploy2.BalancerStatusResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy2.BalancerStatusResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *deploy2.BalancerStatusRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchTaskHistory provides a mock function with given fields: ctx, in, opts
func (_m *DeployServiceClient) BatchTaskHistory(ctx context.Context, in *deploy2.BatchTaskHistoryRequest, opts ...grpc.CallOption) (*deploy2.BatchTaskHistoryResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *deploy2.BatchTaskHistoryResponse
	if rf, ok := ret.Get(0).(func(context.Context, *deploy2.BatchTaskHistoryRequest, ...grpc.CallOption) *deploy2.BatchTaskHistoryResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy2.BatchTaskHistoryResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *deploy2.BatchTaskHistoryRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cancel provides a mock function with given fields: ctx, in, opts
func (_m *DeployServiceClient) Cancel(ctx context.Context, in *deploy2.CancelRequest, opts ...grpc.CallOption) (*deploy2.DeploymentResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *deploy2.DeploymentResponse
	if rf, ok := ret.Get(0).(func(context.Context, *deploy2.CancelRequest, ...grpc.CallOption) *deploy2.DeploymentResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy2.DeploymentResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *deploy2.CancelRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Envs provides a mock function with given fields: ctx, in, opts
func (_m *DeployServiceClient) Envs(ctx context.Context, in *deploy2.EnvsRequest, opts ...grpc.CallOption) (*deploy2.EnvsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *deploy2.EnvsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *deploy2.EnvsRequest, ...grpc.CallOption) *deploy2.EnvsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy2.EnvsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *deploy2.EnvsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Promote provides a mock function with given fields: ctx, in, opts
func (_m *DeployServiceClient) Promote(ctx context.Context, in *deploy2.PromoteRequest, opts ...grpc.CallOption) (*deploy2.DeploymentResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *deploy2.DeploymentResponse
	if rf, ok := ret.Get(0).(func(context.Context, *deploy2.PromoteRequest, ...grpc.CallOption) *deploy2.DeploymentResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy2.DeploymentResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *deploy2.PromoteRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Restart provides a mock function with given fields: ctx, in, opts
func (_m *DeployServiceClient) Restart(ctx context.Context, in *deploy2.RestartRequest, opts ...grpc.CallOption) (*deploy2.DeploymentResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *deploy2.DeploymentResponse
	if rf, ok := ret.Get(0).(func(context.Context, *deploy2.RestartRequest, ...grpc.CallOption) *deploy2.DeploymentResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy2.DeploymentResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *deploy2.RestartRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Revert provides a mock function with given fields: ctx, in, opts
func (_m *DeployServiceClient) Revert(ctx context.Context, in *deploy2.RevertRequest, opts ...grpc.CallOption) (*deploy2.DeploymentResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *deploy2.DeploymentResponse
	if rf, ok := ret.Get(0).(func(context.Context, *deploy2.RevertRequest, ...grpc.CallOption) *deploy2.DeploymentResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy2.DeploymentResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *deploy2.RevertRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Run provides a mock function with given fields: ctx, in, opts
func (_m *DeployServiceClient) Run(ctx context.Context, in *deploy2.RunRequest, opts ...grpc.CallOption) (*deploy2.DeploymentResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *deploy2.DeploymentResponse
	if rf, ok := ret.Get(0).(func(context.Context, *deploy2.RunRequest, ...grpc.CallOption) *deploy2.DeploymentResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy2.DeploymentResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *deploy2.RunRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Settings provides a mock function with given fields: ctx, in, opts
func (_m *DeployServiceClient) Settings(ctx context.Context, in *deploy2.SettingsRequest, opts ...grpc.CallOption) (*deploy2.SettingsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *deploy2.SettingsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *deploy2.SettingsRequest, ...grpc.CallOption) *deploy2.SettingsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy2.SettingsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *deploy2.SettingsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// State provides a mock function with given fields: ctx, in, opts
func (_m *DeployServiceClient) State(ctx context.Context, in *deploy2.StateRequest, opts ...grpc.CallOption) (*deploy2.StateResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *deploy2.StateResponse
	if rf, ok := ret.Get(0).(func(context.Context, *deploy2.StateRequest, ...grpc.CallOption) *deploy2.StateResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy2.StateResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *deploy2.StateRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Status provides a mock function with given fields: ctx, in, opts
func (_m *DeployServiceClient) Status(ctx context.Context, in *deploy2.StatusRequest, opts ...grpc.CallOption) (*deploy2.StatusResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *deploy2.StatusResponse
	if rf, ok := ret.Get(0).(func(context.Context, *deploy2.StatusRequest, ...grpc.CallOption) *deploy2.StatusResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy2.StatusResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *deploy2.StatusRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stop provides a mock function with given fields: ctx, in, opts
func (_m *DeployServiceClient) Stop(ctx context.Context, in *deploy2.StopRequest, opts ...grpc.CallOption) (*deploy2.DeploymentResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *deploy2.DeploymentResponse
	if rf, ok := ret.Get(0).(func(context.Context, *deploy2.StopRequest, ...grpc.CallOption) *deploy2.DeploymentResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy2.DeploymentResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *deploy2.StopRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateEnvs provides a mock function with given fields: ctx, in, opts
func (_m *DeployServiceClient) UpdateEnvs(ctx context.Context, in *deploy2.EnvsUpdateRequest, opts ...grpc.CallOption) (*deploy2.EnvsUpdateResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *deploy2.EnvsUpdateResponse
	if rf, ok := ret.Get(0).(func(context.Context, *deploy2.EnvsUpdateRequest, ...grpc.CallOption) *deploy2.EnvsUpdateResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy2.EnvsUpdateResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *deploy2.EnvsUpdateRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewDeployServiceClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewDeployServiceClient creates a new instance of DeployServiceClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewDeployServiceClient(t mockConstructorTestingTNewDeployServiceClient) *DeployServiceClient {
	mock := &DeployServiceClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
